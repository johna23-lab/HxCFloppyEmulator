<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>zlib.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>zlib.h</h1><div class="fragment"><pre>00001 <span class="comment">/* zlib.h -- interface of the 'zlib' general purpose compression library</span>
00002 <span class="comment">  version 1.1.4, March 11th, 2002</span>
00003 <span class="comment"></span>
00004 <span class="comment">  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler</span>
00005 <span class="comment"></span>
00006 <span class="comment">  This software is provided 'as-is', without any express or implied</span>
00007 <span class="comment">  warranty.  In no event will the authors be held liable for any damages</span>
00008 <span class="comment">  arising from the use of this software.</span>
00009 <span class="comment"></span>
00010 <span class="comment">  Permission is granted to anyone to use this software for any purpose,</span>
00011 <span class="comment">  including commercial applications, and to alter it and redistribute it</span>
00012 <span class="comment">  freely, subject to the following restrictions:</span>
00013 <span class="comment"></span>
00014 <span class="comment">  1. The origin of this software must not be misrepresented; you must not</span>
00015 <span class="comment">     claim that you wrote the original software. If you use this software</span>
00016 <span class="comment">     in a product, an acknowledgment in the product documentation would be</span>
00017 <span class="comment">     appreciated but is not required.</span>
00018 <span class="comment">  2. Altered source versions must be plainly marked as such, and must not be</span>
00019 <span class="comment">     misrepresented as being the original software.</span>
00020 <span class="comment">  3. This notice may not be removed or altered from any source distribution.</span>
00021 <span class="comment"></span>
00022 <span class="comment">  Jean-loup Gailly        Mark Adler</span>
00023 <span class="comment">  jloup@gzip.org          madler@alumni.caltech.edu</span>
00024 <span class="comment"></span>
00025 <span class="comment"></span>
00026 <span class="comment">  The data format used by the zlib library is described by RFCs (Request for</span>
00027 <span class="comment">  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt</span>
00028 <span class="comment">  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).</span>
00029 <span class="comment">*/</span>
00030 
00031 <span class="preprocessor">#ifndef _ZLIB_H</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define _ZLIB_H</span>
00033 <span class="preprocessor"></span>
00034 <span class="preprocessor">#include "zconf.h"</span>
00035 
00036 <span class="preprocessor">#ifdef __cplusplus</span>
00037 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="stringliteral">"C"</span> {
00038 <span class="preprocessor">#endif</span>
00039 <span class="preprocessor"></span>
00040 <span class="preprocessor">#define ZLIB_VERSION "1.1.4"</span>
00041 <span class="preprocessor"></span>
00042 <span class="comment">/* </span>
00043 <span class="comment">     The 'zlib' compression library provides in-memory compression and</span>
00044 <span class="comment">  decompression functions, including integrity checks of the uncompressed</span>
00045 <span class="comment">  data.  This version of the library supports only one compression method</span>
00046 <span class="comment">  (deflation) but other algorithms will be added later and will have the same</span>
00047 <span class="comment">  stream interface.</span>
00048 <span class="comment"></span>
00049 <span class="comment">     Compression can be done in a single step if the buffers are large</span>
00050 <span class="comment">  enough (for example if an input file is mmap'ed), or can be done by</span>
00051 <span class="comment">  repeated calls of the compression function.  In the latter case, the</span>
00052 <span class="comment">  application must provide more input and/or consume the output</span>
00053 <span class="comment">  (providing more output space) before each call.</span>
00054 <span class="comment"></span>
00055 <span class="comment">     The library also supports reading and writing files in gzip (.gz) format</span>
00056 <span class="comment">  with an interface similar to that of stdio.</span>
00057 <span class="comment"></span>
00058 <span class="comment">     The library does not install any signal handler. The decoder checks</span>
00059 <span class="comment">  the consistency of the compressed data, so the library should never</span>
00060 <span class="comment">  crash even in case of corrupted input.</span>
00061 <span class="comment">*/</span>
00062 
00063 <span class="keyword">typedef</span> voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
00064 <span class="keyword">typedef</span> void   (*free_func)  OF((voidpf opaque, voidpf address));
00065 
00066 <span class="keyword">struct </span>internal_state;
00067 
00068 <span class="keyword">typedef</span> <span class="keyword">struct </span>z_stream_s {
00069     Bytef    *next_in;  <span class="comment">/* next input byte */</span>
00070     uInt     avail_in;  <span class="comment">/* number of bytes available at next_in */</span>
00071     uLong    total_in;  <span class="comment">/* total nb of input bytes read so far */</span>
00072 
00073     Bytef    *next_out; <span class="comment">/* next output byte should be put there */</span>
00074     uInt     avail_out; <span class="comment">/* remaining free space at next_out */</span>
00075     uLong    total_out; <span class="comment">/* total nb of bytes output so far */</span>
00076 
00077     <span class="keywordtype">char</span>     *msg;      <span class="comment">/* last error message, NULL if no error */</span>
00078     <span class="keyword">struct </span>internal_state FAR *state; <span class="comment">/* not visible by applications */</span>
00079 
00080     alloc_func zalloc;  <span class="comment">/* used to allocate the internal state */</span>
00081     free_func  zfree;   <span class="comment">/* used to free the internal state */</span>
00082     voidpf     opaque;  <span class="comment">/* private data object passed to zalloc and zfree */</span>
00083 
00084     <span class="keywordtype">int</span>     data_type;  <span class="comment">/* best guess about the data type: ascii or binary */</span>
00085     uLong   adler;      <span class="comment">/* adler32 value of the uncompressed data */</span>
00086     uLong   reserved;   <span class="comment">/* reserved for future use */</span>
00087 } z_stream;
00088 
00089 <span class="keyword">typedef</span> z_stream FAR *z_streamp;
00090 
00091 <span class="comment">/*</span>
00092 <span class="comment">   The application must update next_in and avail_in when avail_in has</span>
00093 <span class="comment">   dropped to zero. It must update next_out and avail_out when avail_out</span>
00094 <span class="comment">   has dropped to zero. The application must initialize zalloc, zfree and</span>
00095 <span class="comment">   opaque before calling the init function. All other fields are set by the</span>
00096 <span class="comment">   compression library and must not be updated by the application.</span>
00097 <span class="comment"></span>
00098 <span class="comment">   The opaque value provided by the application will be passed as the first</span>
00099 <span class="comment">   parameter for calls of zalloc and zfree. This can be useful for custom</span>
00100 <span class="comment">   memory management. The compression library attaches no meaning to the</span>
00101 <span class="comment">   opaque value.</span>
00102 <span class="comment"></span>
00103 <span class="comment">   zalloc must return Z_NULL if there is not enough memory for the object.</span>
00104 <span class="comment">   If zlib is used in a multi-threaded application, zalloc and zfree must be</span>
00105 <span class="comment">   thread safe.</span>
00106 <span class="comment"></span>
00107 <span class="comment">   On 16-bit systems, the functions zalloc and zfree must be able to allocate</span>
00108 <span class="comment">   exactly 65536 bytes, but will not be required to allocate more than this</span>
00109 <span class="comment">   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,</span>
00110 <span class="comment">   pointers returned by zalloc for objects of exactly 65536 bytes *must*</span>
00111 <span class="comment">   have their offset normalized to zero. The default allocation function</span>
00112 <span class="comment">   provided by this library ensures this (see zutil.c). To reduce memory</span>
00113 <span class="comment">   requirements and avoid any allocation of 64K objects, at the expense of</span>
00114 <span class="comment">   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).</span>
00115 <span class="comment"></span>
00116 <span class="comment">   The fields total_in and total_out can be used for statistics or</span>
00117 <span class="comment">   progress reports. After compression, total_in holds the total size of</span>
00118 <span class="comment">   the uncompressed data and may be saved for use in the decompressor</span>
00119 <span class="comment">   (particularly if the decompressor wants to decompress everything in</span>
00120 <span class="comment">   a single step).</span>
00121 <span class="comment">*/</span>
00122 
00123                         <span class="comment">/* constants */</span>
00124 
00125 <span class="preprocessor">#define Z_NO_FLUSH      0</span>
00126 <span class="preprocessor"></span><span class="preprocessor">#define Z_PARTIAL_FLUSH 1 </span><span class="comment">/* will be removed, use Z_SYNC_FLUSH instead */</span>
00127 <span class="preprocessor">#define Z_SYNC_FLUSH    2</span>
00128 <span class="preprocessor"></span><span class="preprocessor">#define Z_FULL_FLUSH    3</span>
00129 <span class="preprocessor"></span><span class="preprocessor">#define Z_FINISH        4</span>
00130 <span class="preprocessor"></span><span class="comment">/* Allowed flush values; see deflate() below for details */</span>
00131 
00132 <span class="preprocessor">#define Z_OK            0</span>
00133 <span class="preprocessor"></span><span class="preprocessor">#define Z_STREAM_END    1</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#define Z_NEED_DICT     2</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#define Z_ERRNO        (-1)</span>
00136 <span class="preprocessor"></span><span class="preprocessor">#define Z_STREAM_ERROR (-2)</span>
00137 <span class="preprocessor"></span><span class="preprocessor">#define Z_DATA_ERROR   (-3)</span>
00138 <span class="preprocessor"></span><span class="preprocessor">#define Z_MEM_ERROR    (-4)</span>
00139 <span class="preprocessor"></span><span class="preprocessor">#define Z_BUF_ERROR    (-5)</span>
00140 <span class="preprocessor"></span><span class="preprocessor">#define Z_VERSION_ERROR (-6)</span>
00141 <span class="preprocessor"></span><span class="comment">/* Return codes for the compression/decompression functions. Negative</span>
00142 <span class="comment"> * values are errors, positive values are used for special but normal events.</span>
00143 <span class="comment"> */</span>
00144 
00145 <span class="preprocessor">#define Z_NO_COMPRESSION         0</span>
00146 <span class="preprocessor"></span><span class="preprocessor">#define Z_BEST_SPEED             1</span>
00147 <span class="preprocessor"></span><span class="preprocessor">#define Z_BEST_COMPRESSION       9</span>
00148 <span class="preprocessor"></span><span class="preprocessor">#define Z_DEFAULT_COMPRESSION  (-1)</span>
00149 <span class="preprocessor"></span><span class="comment">/* compression levels */</span>
00150 
00151 <span class="preprocessor">#define Z_FILTERED            1</span>
00152 <span class="preprocessor"></span><span class="preprocessor">#define Z_HUFFMAN_ONLY        2</span>
00153 <span class="preprocessor"></span><span class="preprocessor">#define Z_DEFAULT_STRATEGY    0</span>
00154 <span class="preprocessor"></span><span class="comment">/* compression strategy; see deflateInit2() below for details */</span>
00155 
00156 <span class="preprocessor">#define Z_BINARY   0</span>
00157 <span class="preprocessor"></span><span class="preprocessor">#define Z_ASCII    1</span>
00158 <span class="preprocessor"></span><span class="preprocessor">#define Z_UNKNOWN  2</span>
00159 <span class="preprocessor"></span><span class="comment">/* Possible values of the data_type field */</span>
00160 
00161 <span class="preprocessor">#define Z_DEFLATED   8</span>
00162 <span class="preprocessor"></span><span class="comment">/* The deflate compression method (the only one supported in this version) */</span>
00163 
00164 <span class="preprocessor">#define Z_NULL  0  </span><span class="comment">/* for initializing zalloc, zfree, opaque */</span>
00165 
00166 <span class="preprocessor">#define zlib_version zlibVersion()</span>
00167 <span class="preprocessor"></span><span class="comment">/* for compatibility with versions &lt; 1.0.2 */</span>
00168 
00169                         <span class="comment">/* basic functions */</span>
00170 
00171 ZEXTERN <span class="keyword">const</span> <span class="keywordtype">char</span> * ZEXPORT zlibVersion OF((<span class="keywordtype">void</span>));
00172 <span class="comment">/* The application can compare zlibVersion and ZLIB_VERSION for consistency.</span>
00173 <span class="comment">   If the first character differs, the library code actually used is</span>
00174 <span class="comment">   not compatible with the zlib.h header file used by the application.</span>
00175 <span class="comment">   This check is automatically made by deflateInit and inflateInit.</span>
00176 <span class="comment"> */</span>
00177 
00178 <span class="comment">/* </span>
00179 <span class="comment">ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));</span>
00180 <span class="comment"></span>
00181 <span class="comment">     Initializes the internal stream state for compression. The fields</span>
00182 <span class="comment">   zalloc, zfree and opaque must be initialized before by the caller.</span>
00183 <span class="comment">   If zalloc and zfree are set to Z_NULL, deflateInit updates them to</span>
00184 <span class="comment">   use default allocation functions.</span>
00185 <span class="comment"></span>
00186 <span class="comment">     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:</span>
00187 <span class="comment">   1 gives best speed, 9 gives best compression, 0 gives no compression at</span>
00188 <span class="comment">   all (the input data is simply copied a block at a time).</span>
00189 <span class="comment">   Z_DEFAULT_COMPRESSION requests a default compromise between speed and</span>
00190 <span class="comment">   compression (currently equivalent to level 6).</span>
00191 <span class="comment"></span>
00192 <span class="comment">     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not</span>
00193 <span class="comment">   enough memory, Z_STREAM_ERROR if level is not a valid compression level,</span>
00194 <span class="comment">   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible</span>
00195 <span class="comment">   with the version assumed by the caller (ZLIB_VERSION).</span>
00196 <span class="comment">   msg is set to null if there is no error message.  deflateInit does not</span>
00197 <span class="comment">   perform any compression: this will be done by deflate().</span>
00198 <span class="comment">*/</span>
00199 
00200 
00201 ZEXTERN <span class="keywordtype">int</span> ZEXPORT deflate OF((z_streamp strm, <span class="keywordtype">int</span> flush));
00202 <span class="comment">/*</span>
00203 <span class="comment">    deflate compresses as much data as possible, and stops when the input</span>
00204 <span class="comment">  buffer becomes empty or the output buffer becomes full. It may introduce some</span>
00205 <span class="comment">  output latency (reading input without producing any output) except when</span>
00206 <span class="comment">  forced to flush.</span>
00207 <span class="comment"></span>
00208 <span class="comment">    The detailed semantics are as follows. deflate performs one or both of the</span>
00209 <span class="comment">  following actions:</span>
00210 <span class="comment"></span>
00211 <span class="comment">  - Compress more input starting at next_in and update next_in and avail_in</span>
00212 <span class="comment">    accordingly. If not all input can be processed (because there is not</span>
00213 <span class="comment">    enough room in the output buffer), next_in and avail_in are updated and</span>
00214 <span class="comment">    processing will resume at this point for the next call of deflate().</span>
00215 <span class="comment"></span>
00216 <span class="comment">  - Provide more output starting at next_out and update next_out and avail_out</span>
00217 <span class="comment">    accordingly. This action is forced if the parameter flush is non zero.</span>
00218 <span class="comment">    Forcing flush frequently degrades the compression ratio, so this parameter</span>
00219 <span class="comment">    should be set only when necessary (in interactive applications).</span>
00220 <span class="comment">    Some output may be provided even if flush is not set.</span>
00221 <span class="comment"></span>
00222 <span class="comment">  Before the call of deflate(), the application should ensure that at least</span>
00223 <span class="comment">  one of the actions is possible, by providing more input and/or consuming</span>
00224 <span class="comment">  more output, and updating avail_in or avail_out accordingly; avail_out</span>
00225 <span class="comment">  should never be zero before the call. The application can consume the</span>
00226 <span class="comment">  compressed output when it wants, for example when the output buffer is full</span>
00227 <span class="comment">  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK</span>
00228 <span class="comment">  and with zero avail_out, it must be called again after making room in the</span>
00229 <span class="comment">  output buffer because there might be more output pending.</span>
00230 <span class="comment"></span>
00231 <span class="comment">    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is</span>
00232 <span class="comment">  flushed to the output buffer and the output is aligned on a byte boundary, so</span>
00233 <span class="comment">  that the decompressor can get all input data available so far. (In particular</span>
00234 <span class="comment">  avail_in is zero after the call if enough output space has been provided</span>
00235 <span class="comment">  before the call.)  Flushing may degrade compression for some compression</span>
00236 <span class="comment">  algorithms and so it should be used only when necessary.</span>
00237 <span class="comment"></span>
00238 <span class="comment">    If flush is set to Z_FULL_FLUSH, all output is flushed as with</span>
00239 <span class="comment">  Z_SYNC_FLUSH, and the compression state is reset so that decompression can</span>
00240 <span class="comment">  restart from this point if previous compressed data has been damaged or if</span>
00241 <span class="comment">  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade</span>
00242 <span class="comment">  the compression.</span>
00243 <span class="comment"></span>
00244 <span class="comment">    If deflate returns with avail_out == 0, this function must be called again</span>
00245 <span class="comment">  with the same value of the flush parameter and more output space (updated</span>
00246 <span class="comment">  avail_out), until the flush is complete (deflate returns with non-zero</span>
00247 <span class="comment">  avail_out).</span>
00248 <span class="comment"></span>
00249 <span class="comment">    If the parameter flush is set to Z_FINISH, pending input is processed,</span>
00250 <span class="comment">  pending output is flushed and deflate returns with Z_STREAM_END if there</span>
00251 <span class="comment">  was enough output space; if deflate returns with Z_OK, this function must be</span>
00252 <span class="comment">  called again with Z_FINISH and more output space (updated avail_out) but no</span>
00253 <span class="comment">  more input data, until it returns with Z_STREAM_END or an error. After</span>
00254 <span class="comment">  deflate has returned Z_STREAM_END, the only possible operations on the</span>
00255 <span class="comment">  stream are deflateReset or deflateEnd.</span>
00256 <span class="comment">  </span>
00257 <span class="comment">    Z_FINISH can be used immediately after deflateInit if all the compression</span>
00258 <span class="comment">  is to be done in a single step. In this case, avail_out must be at least</span>
00259 <span class="comment">  0.1% larger than avail_in plus 12 bytes.  If deflate does not return</span>
00260 <span class="comment">  Z_STREAM_END, then it must be called again as described above.</span>
00261 <span class="comment"></span>
00262 <span class="comment">    deflate() sets strm-&gt;adler to the adler32 checksum of all input read</span>
00263 <span class="comment">  so far (that is, total_in bytes).</span>
00264 <span class="comment"></span>
00265 <span class="comment">    deflate() may update data_type if it can make a good guess about</span>
00266 <span class="comment">  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered</span>
00267 <span class="comment">  binary. This field is only for information purposes and does not affect</span>
00268 <span class="comment">  the compression algorithm in any manner.</span>
00269 <span class="comment"></span>
00270 <span class="comment">    deflate() returns Z_OK if some progress has been made (more input</span>
00271 <span class="comment">  processed or more output produced), Z_STREAM_END if all input has been</span>
00272 <span class="comment">  consumed and all output has been produced (only when flush is set to</span>
00273 <span class="comment">  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example</span>
00274 <span class="comment">  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible</span>
00275 <span class="comment">  (for example avail_in or avail_out was zero).</span>
00276 <span class="comment">*/</span>
00277 
00278 
00279 ZEXTERN <span class="keywordtype">int</span> ZEXPORT deflateEnd OF((z_streamp strm));
00280 <span class="comment">/*</span>
00281 <span class="comment">     All dynamically allocated data structures for this stream are freed.</span>
00282 <span class="comment">   This function discards any unprocessed input and does not flush any</span>
00283 <span class="comment">   pending output.</span>
00284 <span class="comment"></span>
00285 <span class="comment">     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the</span>
00286 <span class="comment">   stream state was inconsistent, Z_DATA_ERROR if the stream was freed</span>
00287 <span class="comment">   prematurely (some input or output was discarded). In the error case,</span>
00288 <span class="comment">   msg may be set but then points to a static string (which must not be</span>
00289 <span class="comment">   deallocated).</span>
00290 <span class="comment">*/</span>
00291 
00292 
00293 <span class="comment">/* </span>
00294 <span class="comment">ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));</span>
00295 <span class="comment"></span>
00296 <span class="comment">     Initializes the internal stream state for decompression. The fields</span>
00297 <span class="comment">   next_in, avail_in, zalloc, zfree and opaque must be initialized before by</span>
00298 <span class="comment">   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact</span>
00299 <span class="comment">   value depends on the compression method), inflateInit determines the</span>
00300 <span class="comment">   compression method from the zlib header and allocates all data structures</span>
00301 <span class="comment">   accordingly; otherwise the allocation will be deferred to the first call of</span>
00302 <span class="comment">   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to</span>
00303 <span class="comment">   use default allocation functions.</span>
00304 <span class="comment"></span>
00305 <span class="comment">     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
00306 <span class="comment">   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the</span>
00307 <span class="comment">   version assumed by the caller.  msg is set to null if there is no error</span>
00308 <span class="comment">   message. inflateInit does not perform any decompression apart from reading</span>
00309 <span class="comment">   the zlib header if present: this will be done by inflate().  (So next_in and</span>
00310 <span class="comment">   avail_in may be modified, but next_out and avail_out are unchanged.)</span>
00311 <span class="comment">*/</span>
00312 
00313 
00314 ZEXTERN <span class="keywordtype">int</span> ZEXPORT inflate OF((z_streamp strm, <span class="keywordtype">int</span> flush));
00315 <span class="comment">/*</span>
00316 <span class="comment">    inflate decompresses as much data as possible, and stops when the input</span>
00317 <span class="comment">  buffer becomes empty or the output buffer becomes full. It may some</span>
00318 <span class="comment">  introduce some output latency (reading input without producing any output)</span>
00319 <span class="comment">  except when forced to flush.</span>
00320 <span class="comment"></span>
00321 <span class="comment">  The detailed semantics are as follows. inflate performs one or both of the</span>
00322 <span class="comment">  following actions:</span>
00323 <span class="comment"></span>
00324 <span class="comment">  - Decompress more input starting at next_in and update next_in and avail_in</span>
00325 <span class="comment">    accordingly. If not all input can be processed (because there is not</span>
00326 <span class="comment">    enough room in the output buffer), next_in is updated and processing</span>
00327 <span class="comment">    will resume at this point for the next call of inflate().</span>
00328 <span class="comment"></span>
00329 <span class="comment">  - Provide more output starting at next_out and update next_out and avail_out</span>
00330 <span class="comment">    accordingly.  inflate() provides as much output as possible, until there</span>
00331 <span class="comment">    is no more input data or no more space in the output buffer (see below</span>
00332 <span class="comment">    about the flush parameter).</span>
00333 <span class="comment"></span>
00334 <span class="comment">  Before the call of inflate(), the application should ensure that at least</span>
00335 <span class="comment">  one of the actions is possible, by providing more input and/or consuming</span>
00336 <span class="comment">  more output, and updating the next_* and avail_* values accordingly.</span>
00337 <span class="comment">  The application can consume the uncompressed output when it wants, for</span>
00338 <span class="comment">  example when the output buffer is full (avail_out == 0), or after each</span>
00339 <span class="comment">  call of inflate(). If inflate returns Z_OK and with zero avail_out, it</span>
00340 <span class="comment">  must be called again after making room in the output buffer because there</span>
00341 <span class="comment">  might be more output pending.</span>
00342 <span class="comment"></span>
00343 <span class="comment">    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much</span>
00344 <span class="comment">  output as possible to the output buffer. The flushing behavior of inflate is</span>
00345 <span class="comment">  not specified for values of the flush parameter other than Z_SYNC_FLUSH</span>
00346 <span class="comment">  and Z_FINISH, but the current implementation actually flushes as much output</span>
00347 <span class="comment">  as possible anyway.</span>
00348 <span class="comment"></span>
00349 <span class="comment">    inflate() should normally be called until it returns Z_STREAM_END or an</span>
00350 <span class="comment">  error. However if all decompression is to be performed in a single step</span>
00351 <span class="comment">  (a single call of inflate), the parameter flush should be set to</span>
00352 <span class="comment">  Z_FINISH. In this case all pending input is processed and all pending</span>
00353 <span class="comment">  output is flushed; avail_out must be large enough to hold all the</span>
00354 <span class="comment">  uncompressed data. (The size of the uncompressed data may have been saved</span>
00355 <span class="comment">  by the compressor for this purpose.) The next operation on this stream must</span>
00356 <span class="comment">  be inflateEnd to deallocate the decompression state. The use of Z_FINISH</span>
00357 <span class="comment">  is never required, but can be used to inform inflate that a faster routine</span>
00358 <span class="comment">  may be used for the single inflate() call.</span>
00359 <span class="comment"></span>
00360 <span class="comment">     If a preset dictionary is needed at this point (see inflateSetDictionary</span>
00361 <span class="comment">  below), inflate sets strm-adler to the adler32 checksum of the</span>
00362 <span class="comment">  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise </span>
00363 <span class="comment">  it sets strm-&gt;adler to the adler32 checksum of all output produced</span>
00364 <span class="comment">  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or</span>
00365 <span class="comment">  an error code as described below. At the end of the stream, inflate()</span>
00366 <span class="comment">  checks that its computed adler32 checksum is equal to that saved by the</span>
00367 <span class="comment">  compressor and returns Z_STREAM_END only if the checksum is correct.</span>
00368 <span class="comment"></span>
00369 <span class="comment">    inflate() returns Z_OK if some progress has been made (more input processed</span>
00370 <span class="comment">  or more output produced), Z_STREAM_END if the end of the compressed data has</span>
00371 <span class="comment">  been reached and all uncompressed output has been produced, Z_NEED_DICT if a</span>
00372 <span class="comment">  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was</span>
00373 <span class="comment">  corrupted (input stream not conforming to the zlib format or incorrect</span>
00374 <span class="comment">  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent</span>
00375 <span class="comment">  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not</span>
00376 <span class="comment">  enough memory, Z_BUF_ERROR if no progress is possible or if there was not</span>
00377 <span class="comment">  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR</span>
00378 <span class="comment">  case, the application may then call inflateSync to look for a good</span>
00379 <span class="comment">  compression block.</span>
00380 <span class="comment">*/</span>
00381 
00382 
00383 ZEXTERN <span class="keywordtype">int</span> ZEXPORT inflateEnd OF((z_streamp strm));
00384 <span class="comment">/*</span>
00385 <span class="comment">     All dynamically allocated data structures for this stream are freed.</span>
00386 <span class="comment">   This function discards any unprocessed input and does not flush any</span>
00387 <span class="comment">   pending output.</span>
00388 <span class="comment"></span>
00389 <span class="comment">     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state</span>
00390 <span class="comment">   was inconsistent. In the error case, msg may be set but then points to a</span>
00391 <span class="comment">   static string (which must not be deallocated).</span>
00392 <span class="comment">*/</span>
00393 
00394                         <span class="comment">/* Advanced functions */</span>
00395 
00396 <span class="comment">/*</span>
00397 <span class="comment">    The following functions are needed only in some special applications.</span>
00398 <span class="comment">*/</span>
00399 
00400 <span class="comment">/*   </span>
00401 <span class="comment">ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,</span>
00402 <span class="comment">                                     int  level,</span>
00403 <span class="comment">                                     int  method,</span>
00404 <span class="comment">                                     int  windowBits,</span>
00405 <span class="comment">                                     int  memLevel,</span>
00406 <span class="comment">                                     int  strategy));</span>
00407 <span class="comment"></span>
00408 <span class="comment">     This is another version of deflateInit with more compression options. The</span>
00409 <span class="comment">   fields next_in, zalloc, zfree and opaque must be initialized before by</span>
00410 <span class="comment">   the caller.</span>
00411 <span class="comment"></span>
00412 <span class="comment">     The method parameter is the compression method. It must be Z_DEFLATED in</span>
00413 <span class="comment">   this version of the library.</span>
00414 <span class="comment"></span>
00415 <span class="comment">     The windowBits parameter is the base two logarithm of the window size</span>
00416 <span class="comment">   (the size of the history buffer).  It should be in the range 8..15 for this</span>
00417 <span class="comment">   version of the library. Larger values of this parameter result in better</span>
00418 <span class="comment">   compression at the expense of memory usage. The default value is 15 if</span>
00419 <span class="comment">   deflateInit is used instead.</span>
00420 <span class="comment"></span>
00421 <span class="comment">     The memLevel parameter specifies how much memory should be allocated</span>
00422 <span class="comment">   for the internal compression state. memLevel=1 uses minimum memory but</span>
00423 <span class="comment">   is slow and reduces compression ratio; memLevel=9 uses maximum memory</span>
00424 <span class="comment">   for optimal speed. The default value is 8. See zconf.h for total memory</span>
00425 <span class="comment">   usage as a function of windowBits and memLevel.</span>
00426 <span class="comment"></span>
00427 <span class="comment">     The strategy parameter is used to tune the compression algorithm. Use the</span>
00428 <span class="comment">   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a</span>
00429 <span class="comment">   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no</span>
00430 <span class="comment">   string match).  Filtered data consists mostly of small values with a</span>
00431 <span class="comment">   somewhat random distribution. In this case, the compression algorithm is</span>
00432 <span class="comment">   tuned to compress them better. The effect of Z_FILTERED is to force more</span>
00433 <span class="comment">   Huffman coding and less string matching; it is somewhat intermediate</span>
00434 <span class="comment">   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects</span>
00435 <span class="comment">   the compression ratio but not the correctness of the compressed output even</span>
00436 <span class="comment">   if it is not set appropriately.</span>
00437 <span class="comment"></span>
00438 <span class="comment">      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
00439 <span class="comment">   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid</span>
00440 <span class="comment">   method). msg is set to null if there is no error message.  deflateInit2 does</span>
00441 <span class="comment">   not perform any compression: this will be done by deflate().</span>
00442 <span class="comment">*/</span>
00443                             
00444 ZEXTERN <span class="keywordtype">int</span> ZEXPORT deflateSetDictionary OF((z_streamp strm,
00445                                              <span class="keyword">const</span> Bytef *dictionary,
00446                                              uInt  dictLength));
00447 <span class="comment">/*</span>
00448 <span class="comment">     Initializes the compression dictionary from the given byte sequence</span>
00449 <span class="comment">   without producing any compressed output. This function must be called</span>
00450 <span class="comment">   immediately after deflateInit, deflateInit2 or deflateReset, before any</span>
00451 <span class="comment">   call of deflate. The compressor and decompressor must use exactly the same</span>
00452 <span class="comment">   dictionary (see inflateSetDictionary).</span>
00453 <span class="comment"></span>
00454 <span class="comment">     The dictionary should consist of strings (byte sequences) that are likely</span>
00455 <span class="comment">   to be encountered later in the data to be compressed, with the most commonly</span>
00456 <span class="comment">   used strings preferably put towards the end of the dictionary. Using a</span>
00457 <span class="comment">   dictionary is most useful when the data to be compressed is short and can be</span>
00458 <span class="comment">   predicted with good accuracy; the data can then be compressed better than</span>
00459 <span class="comment">   with the default empty dictionary.</span>
00460 <span class="comment"></span>
00461 <span class="comment">     Depending on the size of the compression data structures selected by</span>
00462 <span class="comment">   deflateInit or deflateInit2, a part of the dictionary may in effect be</span>
00463 <span class="comment">   discarded, for example if the dictionary is larger than the window size in</span>
00464 <span class="comment">   deflate or deflate2. Thus the strings most likely to be useful should be</span>
00465 <span class="comment">   put at the end of the dictionary, not at the front.</span>
00466 <span class="comment"></span>
00467 <span class="comment">     Upon return of this function, strm-&gt;adler is set to the Adler32 value</span>
00468 <span class="comment">   of the dictionary; the decompressor may later use this value to determine</span>
00469 <span class="comment">   which dictionary has been used by the compressor. (The Adler32 value</span>
00470 <span class="comment">   applies to the whole dictionary even if only a subset of the dictionary is</span>
00471 <span class="comment">   actually used by the compressor.)</span>
00472 <span class="comment"></span>
00473 <span class="comment">     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a</span>
00474 <span class="comment">   parameter is invalid (such as NULL dictionary) or the stream state is</span>
00475 <span class="comment">   inconsistent (for example if deflate has already been called for this stream</span>
00476 <span class="comment">   or if the compression method is bsort). deflateSetDictionary does not</span>
00477 <span class="comment">   perform any compression: this will be done by deflate().</span>
00478 <span class="comment">*/</span>
00479 
00480 ZEXTERN <span class="keywordtype">int</span> ZEXPORT deflateCopy OF((z_streamp dest,
00481                                     z_streamp source));
00482 <span class="comment">/*</span>
00483 <span class="comment">     Sets the destination stream as a complete copy of the source stream.</span>
00484 <span class="comment"></span>
00485 <span class="comment">     This function can be useful when several compression strategies will be</span>
00486 <span class="comment">   tried, for example when there are several ways of pre-processing the input</span>
00487 <span class="comment">   data with a filter. The streams that will be discarded should then be freed</span>
00488 <span class="comment">   by calling deflateEnd.  Note that deflateCopy duplicates the internal</span>
00489 <span class="comment">   compression state which can be quite large, so this strategy is slow and</span>
00490 <span class="comment">   can consume lots of memory.</span>
00491 <span class="comment"></span>
00492 <span class="comment">     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not</span>
00493 <span class="comment">   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent</span>
00494 <span class="comment">   (such as zalloc being NULL). msg is left unchanged in both source and</span>
00495 <span class="comment">   destination.</span>
00496 <span class="comment">*/</span>
00497 
00498 ZEXTERN <span class="keywordtype">int</span> ZEXPORT deflateReset OF((z_streamp strm));
00499 <span class="comment">/*</span>
00500 <span class="comment">     This function is equivalent to deflateEnd followed by deflateInit,</span>
00501 <span class="comment">   but does not free and reallocate all the internal compression state.</span>
00502 <span class="comment">   The stream will keep the same compression level and any other attributes</span>
00503 <span class="comment">   that may have been set by deflateInit2.</span>
00504 <span class="comment"></span>
00505 <span class="comment">      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
00506 <span class="comment">   stream state was inconsistent (such as zalloc or state being NULL).</span>
00507 <span class="comment">*/</span>
00508 
00509 ZEXTERN <span class="keywordtype">int</span> ZEXPORT deflateParams OF((z_streamp strm,
00510                       <span class="keywordtype">int</span> level,
00511                       <span class="keywordtype">int</span> strategy));
00512 <span class="comment">/*</span>
00513 <span class="comment">     Dynamically update the compression level and compression strategy.  The</span>
00514 <span class="comment">   interpretation of level and strategy is as in deflateInit2.  This can be</span>
00515 <span class="comment">   used to switch between compression and straight copy of the input data, or</span>
00516 <span class="comment">   to switch to a different kind of input data requiring a different</span>
00517 <span class="comment">   strategy. If the compression level is changed, the input available so far</span>
00518 <span class="comment">   is compressed with the old level (and may be flushed); the new level will</span>
00519 <span class="comment">   take effect only at the next call of deflate().</span>
00520 <span class="comment"></span>
00521 <span class="comment">     Before the call of deflateParams, the stream state must be set as for</span>
00522 <span class="comment">   a call of deflate(), since the currently available input may have to</span>
00523 <span class="comment">   be compressed and flushed. In particular, strm-&gt;avail_out must be non-zero.</span>
00524 <span class="comment"></span>
00525 <span class="comment">     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source</span>
00526 <span class="comment">   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR</span>
00527 <span class="comment">   if strm-&gt;avail_out was zero.</span>
00528 <span class="comment">*/</span>
00529 
00530 <span class="comment">/*   </span>
00531 <span class="comment">ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,</span>
00532 <span class="comment">                                     int  windowBits));</span>
00533 <span class="comment"></span>
00534 <span class="comment">     This is another version of inflateInit with an extra parameter. The</span>
00535 <span class="comment">   fields next_in, avail_in, zalloc, zfree and opaque must be initialized</span>
00536 <span class="comment">   before by the caller.</span>
00537 <span class="comment"></span>
00538 <span class="comment">     The windowBits parameter is the base two logarithm of the maximum window</span>
00539 <span class="comment">   size (the size of the history buffer).  It should be in the range 8..15 for</span>
00540 <span class="comment">   this version of the library. The default value is 15 if inflateInit is used</span>
00541 <span class="comment">   instead. If a compressed stream with a larger window size is given as</span>
00542 <span class="comment">   input, inflate() will return with the error code Z_DATA_ERROR instead of</span>
00543 <span class="comment">   trying to allocate a larger window.</span>
00544 <span class="comment"></span>
00545 <span class="comment">      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
00546 <span class="comment">   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative</span>
00547 <span class="comment">   memLevel). msg is set to null if there is no error message.  inflateInit2</span>
00548 <span class="comment">   does not perform any decompression apart from reading the zlib header if</span>
00549 <span class="comment">   present: this will be done by inflate(). (So next_in and avail_in may be</span>
00550 <span class="comment">   modified, but next_out and avail_out are unchanged.)</span>
00551 <span class="comment">*/</span>
00552 
00553 ZEXTERN <span class="keywordtype">int</span> ZEXPORT inflateSetDictionary OF((z_streamp strm,
00554                                              <span class="keyword">const</span> Bytef *dictionary,
00555                                              uInt  dictLength));
00556 <span class="comment">/*</span>
00557 <span class="comment">     Initializes the decompression dictionary from the given uncompressed byte</span>
00558 <span class="comment">   sequence. This function must be called immediately after a call of inflate</span>
00559 <span class="comment">   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor</span>
00560 <span class="comment">   can be determined from the Adler32 value returned by this call of</span>
00561 <span class="comment">   inflate. The compressor and decompressor must use exactly the same</span>
00562 <span class="comment">   dictionary (see deflateSetDictionary).</span>
00563 <span class="comment"></span>
00564 <span class="comment">     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a</span>
00565 <span class="comment">   parameter is invalid (such as NULL dictionary) or the stream state is</span>
00566 <span class="comment">   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the</span>
00567 <span class="comment">   expected one (incorrect Adler32 value). inflateSetDictionary does not</span>
00568 <span class="comment">   perform any decompression: this will be done by subsequent calls of</span>
00569 <span class="comment">   inflate().</span>
00570 <span class="comment">*/</span>
00571 
00572 ZEXTERN <span class="keywordtype">int</span> ZEXPORT inflateSync OF((z_streamp strm));
00573 <span class="comment">/* </span>
00574 <span class="comment">    Skips invalid compressed data until a full flush point (see above the</span>
00575 <span class="comment">  description of deflate with Z_FULL_FLUSH) can be found, or until all</span>
00576 <span class="comment">  available input is skipped. No output is provided.</span>
00577 <span class="comment"></span>
00578 <span class="comment">    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR</span>
00579 <span class="comment">  if no more input was provided, Z_DATA_ERROR if no flush point has been found,</span>
00580 <span class="comment">  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success</span>
00581 <span class="comment">  case, the application may save the current current value of total_in which</span>
00582 <span class="comment">  indicates where valid compressed data was found. In the error case, the</span>
00583 <span class="comment">  application may repeatedly call inflateSync, providing more input each time,</span>
00584 <span class="comment">  until success or end of the input data.</span>
00585 <span class="comment">*/</span>
00586 
00587 ZEXTERN <span class="keywordtype">int</span> ZEXPORT inflateReset OF((z_streamp strm));
00588 <span class="comment">/*</span>
00589 <span class="comment">     This function is equivalent to inflateEnd followed by inflateInit,</span>
00590 <span class="comment">   but does not free and reallocate all the internal decompression state.</span>
00591 <span class="comment">   The stream will keep attributes that may have been set by inflateInit2.</span>
00592 <span class="comment"></span>
00593 <span class="comment">      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source</span>
00594 <span class="comment">   stream state was inconsistent (such as zalloc or state being NULL).</span>
00595 <span class="comment">*/</span>
00596 
00597 
00598                         <span class="comment">/* utility functions */</span>
00599 
00600 <span class="comment">/*</span>
00601 <span class="comment">     The following utility functions are implemented on top of the</span>
00602 <span class="comment">   basic stream-oriented functions. To simplify the interface, some</span>
00603 <span class="comment">   default options are assumed (compression level and memory usage,</span>
00604 <span class="comment">   standard memory allocation functions). The source code of these</span>
00605 <span class="comment">   utility functions can easily be modified if you need special options.</span>
00606 <span class="comment">*/</span>
00607 
00608 ZEXTERN <span class="keywordtype">int</span> ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
00609                                  <span class="keyword">const</span> Bytef *source, uLong sourceLen));
00610 <span class="comment">/*</span>
00611 <span class="comment">     Compresses the source buffer into the destination buffer.  sourceLen is</span>
00612 <span class="comment">   the byte length of the source buffer. Upon entry, destLen is the total</span>
00613 <span class="comment">   size of the destination buffer, which must be at least 0.1% larger than</span>
00614 <span class="comment">   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the</span>
00615 <span class="comment">   compressed buffer.</span>
00616 <span class="comment">     This function can be used to compress a whole file at once if the</span>
00617 <span class="comment">   input file is mmap'ed.</span>
00618 <span class="comment">     compress returns Z_OK if success, Z_MEM_ERROR if there was not</span>
00619 <span class="comment">   enough memory, Z_BUF_ERROR if there was not enough room in the output</span>
00620 <span class="comment">   buffer.</span>
00621 <span class="comment">*/</span>
00622 
00623 ZEXTERN <span class="keywordtype">int</span> ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
00624                                   <span class="keyword">const</span> Bytef *source, uLong sourceLen,
00625                                   <span class="keywordtype">int</span> level));
00626 <span class="comment">/*</span>
00627 <span class="comment">     Compresses the source buffer into the destination buffer. The level</span>
00628 <span class="comment">   parameter has the same meaning as in deflateInit.  sourceLen is the byte</span>
00629 <span class="comment">   length of the source buffer. Upon entry, destLen is the total size of the</span>
00630 <span class="comment">   destination buffer, which must be at least 0.1% larger than sourceLen plus</span>
00631 <span class="comment">   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.</span>
00632 <span class="comment"></span>
00633 <span class="comment">     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough</span>
00634 <span class="comment">   memory, Z_BUF_ERROR if there was not enough room in the output buffer,</span>
00635 <span class="comment">   Z_STREAM_ERROR if the level parameter is invalid.</span>
00636 <span class="comment">*/</span>
00637 
00638 ZEXTERN <span class="keywordtype">int</span> ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
00639                                    <span class="keyword">const</span> Bytef *source, uLong sourceLen));
00640 <span class="comment">/*</span>
00641 <span class="comment">     Decompresses the source buffer into the destination buffer.  sourceLen is</span>
00642 <span class="comment">   the byte length of the source buffer. Upon entry, destLen is the total</span>
00643 <span class="comment">   size of the destination buffer, which must be large enough to hold the</span>
00644 <span class="comment">   entire uncompressed data. (The size of the uncompressed data must have</span>
00645 <span class="comment">   been saved previously by the compressor and transmitted to the decompressor</span>
00646 <span class="comment">   by some mechanism outside the scope of this compression library.)</span>
00647 <span class="comment">   Upon exit, destLen is the actual size of the compressed buffer.</span>
00648 <span class="comment">     This function can be used to decompress a whole file at once if the</span>
00649 <span class="comment">   input file is mmap'ed.</span>
00650 <span class="comment"></span>
00651 <span class="comment">     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not</span>
00652 <span class="comment">   enough memory, Z_BUF_ERROR if there was not enough room in the output</span>
00653 <span class="comment">   buffer, or Z_DATA_ERROR if the input data was corrupted.</span>
00654 <span class="comment">*/</span>
00655 
00656 
00657 <span class="keyword">typedef</span> voidp gzFile;
00658 
00659 ZEXTERN gzFile ZEXPORT gzopen  OF((<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keywordtype">char</span> *mode));
00660 <span class="comment">/*</span>
00661 <span class="comment">     Opens a gzip (.gz) file for reading or writing. The mode parameter</span>
00662 <span class="comment">   is as in fopen ("rb" or "wb") but can also include a compression level</span>
00663 <span class="comment">   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for</span>
00664 <span class="comment">   Huffman only compression as in "wb1h". (See the description</span>
00665 <span class="comment">   of deflateInit2 for more information about the strategy parameter.)</span>
00666 <span class="comment"></span>
00667 <span class="comment">     gzopen can be used to read a file which is not in gzip format; in this</span>
00668 <span class="comment">   case gzread will directly read from the file without decompression.</span>
00669 <span class="comment"></span>
00670 <span class="comment">     gzopen returns NULL if the file could not be opened or if there was</span>
00671 <span class="comment">   insufficient memory to allocate the (de)compression state; errno</span>
00672 <span class="comment">   can be checked to distinguish the two cases (if errno is zero, the</span>
00673 <span class="comment">   zlib error is Z_MEM_ERROR).  */</span>
00674 
00675 ZEXTERN gzFile ZEXPORT gzdopen  OF((<span class="keywordtype">int</span> fd, <span class="keyword">const</span> <span class="keywordtype">char</span> *mode));
00676 <span class="comment">/*</span>
00677 <span class="comment">     gzdopen() associates a gzFile with the file descriptor fd.  File</span>
00678 <span class="comment">   descriptors are obtained from calls like open, dup, creat, pipe or</span>
00679 <span class="comment">   fileno (in the file has been previously opened with fopen).</span>
00680 <span class="comment">   The mode parameter is as in gzopen.</span>
00681 <span class="comment">     The next call of gzclose on the returned gzFile will also close the</span>
00682 <span class="comment">   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file</span>
00683 <span class="comment">   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).</span>
00684 <span class="comment">     gzdopen returns NULL if there was insufficient memory to allocate</span>
00685 <span class="comment">   the (de)compression state.</span>
00686 <span class="comment">*/</span>
00687 
00688 ZEXTERN <span class="keywordtype">int</span> ZEXPORT gzsetparams OF((gzFile file, <span class="keywordtype">int</span> level, <span class="keywordtype">int</span> strategy));
00689 <span class="comment">/*</span>
00690 <span class="comment">     Dynamically update the compression level or strategy. See the description</span>
00691 <span class="comment">   of deflateInit2 for the meaning of these parameters.</span>
00692 <span class="comment">     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not</span>
00693 <span class="comment">   opened for writing.</span>
00694 <span class="comment">*/</span>
00695 
00696 ZEXTERN <span class="keywordtype">int</span> ZEXPORT    gzread  OF((gzFile file, voidp buf, <span class="keywordtype">unsigned</span> len));
00697 <span class="comment">/*</span>
00698 <span class="comment">     Reads the given number of uncompressed bytes from the compressed file.</span>
00699 <span class="comment">   If the input file was not in gzip format, gzread copies the given number</span>
00700 <span class="comment">   of bytes into the buffer.</span>
00701 <span class="comment">     gzread returns the number of uncompressed bytes actually read (0 for</span>
00702 <span class="comment">   end of file, -1 for error). */</span>
00703 
00704 ZEXTERN <span class="keywordtype">int</span> ZEXPORT    gzwrite OF((gzFile file, 
00705                    <span class="keyword">const</span> voidp buf, <span class="keywordtype">unsigned</span> len));
00706 <span class="comment">/*</span>
00707 <span class="comment">     Writes the given number of uncompressed bytes into the compressed file.</span>
00708 <span class="comment">   gzwrite returns the number of uncompressed bytes actually written</span>
00709 <span class="comment">   (0 in case of error).</span>
00710 <span class="comment">*/</span>
00711 
00712 ZEXTERN <span class="keywordtype">int</span> ZEXPORTVA   gzprintf OF((gzFile file, <span class="keyword">const</span> <span class="keywordtype">char</span> *format, ...));
00713 <span class="comment">/*</span>
00714 <span class="comment">     Converts, formats, and writes the args to the compressed file under</span>
00715 <span class="comment">   control of the format string, as in fprintf. gzprintf returns the number of</span>
00716 <span class="comment">   uncompressed bytes actually written (0 in case of error).</span>
00717 <span class="comment">*/</span>
00718 
00719 ZEXTERN <span class="keywordtype">int</span> ZEXPORT gzputs OF((gzFile file, <span class="keyword">const</span> <span class="keywordtype">char</span> *s));
00720 <span class="comment">/*</span>
00721 <span class="comment">      Writes the given null-terminated string to the compressed file, excluding</span>
00722 <span class="comment">   the terminating null character.</span>
00723 <span class="comment">      gzputs returns the number of characters written, or -1 in case of error.</span>
00724 <span class="comment">*/</span>
00725 
00726 ZEXTERN <span class="keywordtype">char</span> * ZEXPORT gzgets OF((gzFile file, <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> len));
00727 <span class="comment">/*</span>
00728 <span class="comment">      Reads bytes from the compressed file until len-1 characters are read, or</span>
00729 <span class="comment">   a newline character is read and transferred to buf, or an end-of-file</span>
00730 <span class="comment">   condition is encountered.  The string is then terminated with a null</span>
00731 <span class="comment">   character.</span>
00732 <span class="comment">      gzgets returns buf, or Z_NULL in case of error.</span>
00733 <span class="comment">*/</span>
00734 
00735 ZEXTERN <span class="keywordtype">int</span> ZEXPORT    gzputc OF((gzFile file, <span class="keywordtype">int</span> c));
00736 <span class="comment">/*</span>
00737 <span class="comment">      Writes c, converted to an unsigned char, into the compressed file.</span>
00738 <span class="comment">   gzputc returns the value that was written, or -1 in case of error.</span>
00739 <span class="comment">*/</span>
00740 
00741 ZEXTERN <span class="keywordtype">int</span> ZEXPORT    gzgetc OF((gzFile file));
00742 <span class="comment">/*</span>
00743 <span class="comment">      Reads one byte from the compressed file. gzgetc returns this byte</span>
00744 <span class="comment">   or -1 in case of end of file or error.</span>
00745 <span class="comment">*/</span>
00746 
00747 ZEXTERN <span class="keywordtype">int</span> ZEXPORT    gzflush OF((gzFile file, <span class="keywordtype">int</span> flush));
00748 <span class="comment">/*</span>
00749 <span class="comment">     Flushes all pending output into the compressed file. The parameter</span>
00750 <span class="comment">   flush is as in the deflate() function. The return value is the zlib</span>
00751 <span class="comment">   error number (see function gzerror below). gzflush returns Z_OK if</span>
00752 <span class="comment">   the flush parameter is Z_FINISH and all output could be flushed.</span>
00753 <span class="comment">     gzflush should be called only when strictly necessary because it can</span>
00754 <span class="comment">   degrade compression.</span>
00755 <span class="comment">*/</span>
00756 
00757 ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
00758                       z_off_t offset, <span class="keywordtype">int</span> whence));
00759 <span class="comment">/* </span>
00760 <span class="comment">      Sets the starting position for the next gzread or gzwrite on the</span>
00761 <span class="comment">   given compressed file. The offset represents a number of bytes in the</span>
00762 <span class="comment">   uncompressed data stream. The whence parameter is defined as in lseek(2);</span>
00763 <span class="comment">   the value SEEK_END is not supported.</span>
00764 <span class="comment">     If the file is opened for reading, this function is emulated but can be</span>
00765 <span class="comment">   extremely slow. If the file is opened for writing, only forward seeks are</span>
00766 <span class="comment">   supported; gzseek then compresses a sequence of zeroes up to the new</span>
00767 <span class="comment">   starting position.</span>
00768 <span class="comment"></span>
00769 <span class="comment">      gzseek returns the resulting offset location as measured in bytes from</span>
00770 <span class="comment">   the beginning of the uncompressed stream, or -1 in case of error, in</span>
00771 <span class="comment">   particular if the file is opened for writing and the new starting position</span>
00772 <span class="comment">   would be before the current position.</span>
00773 <span class="comment">*/</span>
00774 
00775 ZEXTERN <span class="keywordtype">int</span> ZEXPORT    gzrewind OF((gzFile file));
00776 <span class="comment">/*</span>
00777 <span class="comment">     Rewinds the given file. This function is supported only for reading.</span>
00778 <span class="comment"></span>
00779 <span class="comment">   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)</span>
00780 <span class="comment">*/</span>
00781 
00782 ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
00783 <span class="comment">/*</span>
00784 <span class="comment">     Returns the starting position for the next gzread or gzwrite on the</span>
00785 <span class="comment">   given compressed file. This position represents a number of bytes in the</span>
00786 <span class="comment">   uncompressed data stream.</span>
00787 <span class="comment"></span>
00788 <span class="comment">   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)</span>
00789 <span class="comment">*/</span>
00790 
00791 ZEXTERN <span class="keywordtype">int</span> ZEXPORT gzeof OF((gzFile file));
00792 <span class="comment">/*</span>
00793 <span class="comment">     Returns 1 when EOF has previously been detected reading the given</span>
00794 <span class="comment">   input stream, otherwise zero.</span>
00795 <span class="comment">*/</span>
00796 
00797 ZEXTERN <span class="keywordtype">int</span> ZEXPORT    gzclose OF((gzFile file));
00798 <span class="comment">/*</span>
00799 <span class="comment">     Flushes all pending output if necessary, closes the compressed file</span>
00800 <span class="comment">   and deallocates all the (de)compression state. The return value is the zlib</span>
00801 <span class="comment">   error number (see function gzerror below).</span>
00802 <span class="comment">*/</span>
00803 
00804 ZEXTERN <span class="keyword">const</span> <span class="keywordtype">char</span> * ZEXPORT gzerror OF((gzFile file, <span class="keywordtype">int</span> *errnum));
00805 <span class="comment">/*</span>
00806 <span class="comment">     Returns the error message for the last error which occurred on the</span>
00807 <span class="comment">   given compressed file. errnum is set to zlib error number. If an</span>
00808 <span class="comment">   error occurred in the file system and not in the compression library,</span>
00809 <span class="comment">   errnum is set to Z_ERRNO and the application may consult errno</span>
00810 <span class="comment">   to get the exact error code.</span>
00811 <span class="comment">*/</span>
00812 
00813                         <span class="comment">/* checksum functions */</span>
00814 
00815 <span class="comment">/*</span>
00816 <span class="comment">     These functions are not related to compression but are exported</span>
00817 <span class="comment">   anyway because they might be useful in applications using the</span>
00818 <span class="comment">   compression library.</span>
00819 <span class="comment">*/</span>
00820 
00821 ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, <span class="keyword">const</span> Bytef *buf, uInt len));
00822 
00823 <span class="comment">/*</span>
00824 <span class="comment">     Update a running Adler-32 checksum with the bytes buf[0..len-1] and</span>
00825 <span class="comment">   return the updated checksum. If buf is NULL, this function returns</span>
00826 <span class="comment">   the required initial value for the checksum.</span>
00827 <span class="comment">   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed</span>
00828 <span class="comment">   much faster. Usage example:</span>
00829 <span class="comment"></span>
00830 <span class="comment">     uLong adler = adler32(0L, Z_NULL, 0);</span>
00831 <span class="comment"></span>
00832 <span class="comment">     while (read_buffer(buffer, length) != EOF) {</span>
00833 <span class="comment">       adler = adler32(adler, buffer, length);</span>
00834 <span class="comment">     }</span>
00835 <span class="comment">     if (adler != original_adler) error();</span>
00836 <span class="comment">*/</span>
00837 
00838 ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, <span class="keyword">const</span> Bytef *buf, uInt len));
00839 <span class="comment">/*</span>
00840 <span class="comment">     Update a running crc with the bytes buf[0..len-1] and return the updated</span>
00841 <span class="comment">   crc. If buf is NULL, this function returns the required initial value</span>
00842 <span class="comment">   for the crc. Pre- and post-conditioning (one's complement) is performed</span>
00843 <span class="comment">   within this function so it shouldn't be done by the application.</span>
00844 <span class="comment">   Usage example:</span>
00845 <span class="comment"></span>
00846 <span class="comment">     uLong crc = crc32(0L, Z_NULL, 0);</span>
00847 <span class="comment"></span>
00848 <span class="comment">     while (read_buffer(buffer, length) != EOF) {</span>
00849 <span class="comment">       crc = crc32(crc, buffer, length);</span>
00850 <span class="comment">     }</span>
00851 <span class="comment">     if (crc != original_crc) error();</span>
00852 <span class="comment">*/</span>
00853 
00854 
00855                         <span class="comment">/* various hacks, don't look :) */</span>
00856 
00857 <span class="comment">/* deflateInit and inflateInit are macros to allow checking the zlib version</span>
00858 <span class="comment"> * and the compiler's view of z_stream:</span>
00859 <span class="comment"> */</span>
00860 ZEXTERN <span class="keywordtype">int</span> ZEXPORT deflateInit_ OF((z_streamp strm, <span class="keywordtype">int</span> level,
00861                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *version, <span class="keywordtype">int</span> stream_size));
00862 ZEXTERN <span class="keywordtype">int</span> ZEXPORT inflateInit_ OF((z_streamp strm,
00863                                      <span class="keyword">const</span> <span class="keywordtype">char</span> *version, <span class="keywordtype">int</span> stream_size));
00864 ZEXTERN <span class="keywordtype">int</span> ZEXPORT deflateInit2_ OF((z_streamp strm, <span class="keywordtype">int</span>  level, <span class="keywordtype">int</span>  method,
00865                                       <span class="keywordtype">int</span> windowBits, <span class="keywordtype">int</span> memLevel,
00866                                       <span class="keywordtype">int</span> strategy, <span class="keyword">const</span> <span class="keywordtype">char</span> *version,
00867                                       <span class="keywordtype">int</span> stream_size));
00868 ZEXTERN <span class="keywordtype">int</span> ZEXPORT inflateInit2_ OF((z_streamp strm, <span class="keywordtype">int</span>  windowBits,
00869                                       <span class="keyword">const</span> <span class="keywordtype">char</span> *version, <span class="keywordtype">int</span> stream_size));
00870 <span class="preprocessor">#define deflateInit(strm, level) \</span>
00871 <span class="preprocessor">        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))</span>
00872 <span class="preprocessor"></span><span class="preprocessor">#define inflateInit(strm) \</span>
00873 <span class="preprocessor">        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))</span>
00874 <span class="preprocessor"></span><span class="preprocessor">#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \</span>
00875 <span class="preprocessor">        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\</span>
00876 <span class="preprocessor">                      (strategy),           ZLIB_VERSION, sizeof(z_stream))</span>
00877 <span class="preprocessor"></span><span class="preprocessor">#define inflateInit2(strm, windowBits) \</span>
00878 <span class="preprocessor">        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))</span>
00879 <span class="preprocessor"></span>
00880 
00881 <span class="preprocessor">#if !defined(_Z_UTIL_H) &amp;&amp; !defined(NO_DUMMY_DECL)</span>
00882 <span class="preprocessor"></span>    <span class="keyword">struct </span>internal_state {<span class="keywordtype">int</span> dummy;}; <span class="comment">/* hack for buggy compilers */</span>
00883 <span class="preprocessor">#endif</span>
00884 <span class="preprocessor"></span>
00885 ZEXTERN <span class="keyword">const</span> <span class="keywordtype">char</span>   * ZEXPORT zError           OF((<span class="keywordtype">int</span> err));
00886 ZEXTERN <span class="keywordtype">int</span>            ZEXPORT inflateSyncPoint OF((z_streamp z));
00887 ZEXTERN <span class="keyword">const</span> uLongf * ZEXPORT get_crc_table    OF((<span class="keywordtype">void</span>));
00888 
00889 <span class="preprocessor">#ifdef __cplusplus</span>
00890 <span class="preprocessor"></span>}
00891 <span class="preprocessor">#endif</span>
00892 <span class="preprocessor"></span>
00893 <span class="preprocessor">#endif </span><span class="comment">/* _ZLIB_H */</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:43 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

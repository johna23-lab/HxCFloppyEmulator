<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>deflate.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>deflate.h</h1><div class="fragment"><pre>00001 <span class="comment">/* deflate.h -- internal compression state</span>
00002 <span class="comment"> * Copyright (C) 1995-2002 Jean-loup Gailly</span>
00003 <span class="comment"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
00004 <span class="comment"> */</span>
00005 
00006 <span class="comment">/* WARNING: this file should *not* be used by applications. It is</span>
00007 <span class="comment">   part of the implementation of the compression library and is</span>
00008 <span class="comment">   subject to change. Applications should only use zlib.h.</span>
00009 <span class="comment"> */</span>
00010 
00011 <span class="comment">/* @(#) $Id: deflate_8h-source.html,v 1.1 2002/11/14 01:50:01 garyjharris Exp $ */</span>
00012 
00013 <span class="preprocessor">#ifndef _DEFLATE_H</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#define _DEFLATE_H</span>
00015 <span class="preprocessor"></span>
00016 <span class="preprocessor">#include "zutil.h"</span>
00017 
00018 <span class="comment">/* ===========================================================================</span>
00019 <span class="comment"> * Internal compression state.</span>
00020 <span class="comment"> */</span>
00021 
00022 <span class="preprocessor">#define LENGTH_CODES 29</span>
00023 <span class="preprocessor"></span><span class="comment">/* number of length codes, not counting the special END_BLOCK code */</span>
00024 
00025 <span class="preprocessor">#define LITERALS  256</span>
00026 <span class="preprocessor"></span><span class="comment">/* number of literal bytes 0..255 */</span>
00027 
00028 <span class="preprocessor">#define L_CODES (LITERALS+1+LENGTH_CODES)</span>
00029 <span class="preprocessor"></span><span class="comment">/* number of Literal or Length codes, including the END_BLOCK code */</span>
00030 
00031 <span class="preprocessor">#define D_CODES   30</span>
00032 <span class="preprocessor"></span><span class="comment">/* number of distance codes */</span>
00033 
00034 <span class="preprocessor">#define BL_CODES  19</span>
00035 <span class="preprocessor"></span><span class="comment">/* number of codes used to transfer the bit lengths */</span>
00036 
00037 <span class="preprocessor">#define HEAP_SIZE (2*L_CODES+1)</span>
00038 <span class="preprocessor"></span><span class="comment">/* maximum heap size */</span>
00039 
00040 <span class="preprocessor">#define MAX_BITS 15</span>
00041 <span class="preprocessor"></span><span class="comment">/* All codes must not exceed MAX_BITS bits */</span>
00042 
00043 <span class="preprocessor">#define INIT_STATE    42</span>
00044 <span class="preprocessor"></span><span class="preprocessor">#define BUSY_STATE   113</span>
00045 <span class="preprocessor"></span><span class="preprocessor">#define FINISH_STATE 666</span>
00046 <span class="preprocessor"></span><span class="comment">/* Stream status */</span>
00047 
00048 
00049 <span class="comment">/* Data structure describing a single value and its code string. */</span>
00050 <span class="keyword">typedef</span> <span class="keyword">struct </span>ct_data_s {
00051     <span class="keyword">union </span>{
00052         ush  freq;       <span class="comment">/* frequency count */</span>
00053         ush  code;       <span class="comment">/* bit string */</span>
00054     } fc;
00055     <span class="keyword">union </span>{
00056         ush  dad;        <span class="comment">/* father node in Huffman tree */</span>
00057         ush  len;        <span class="comment">/* length of bit string */</span>
00058     } dl;
00059 } FAR ct_data;
00060 
00061 <span class="preprocessor">#define Freq fc.freq</span>
00062 <span class="preprocessor"></span><span class="preprocessor">#define Code fc.code</span>
00063 <span class="preprocessor"></span><span class="preprocessor">#define Dad  dl.dad</span>
00064 <span class="preprocessor"></span><span class="preprocessor">#define Len  dl.len</span>
00065 <span class="preprocessor"></span>
00066 <span class="keyword">typedef</span> <span class="keyword">struct </span>static_tree_desc_s  static_tree_desc;
00067 
00068 <span class="keyword">typedef</span> <span class="keyword">struct </span>tree_desc_s {
00069     ct_data *dyn_tree;           <span class="comment">/* the dynamic tree */</span>
00070     <span class="keywordtype">int</span>     max_code;            <span class="comment">/* largest code with non zero frequency */</span>
00071     static_tree_desc *stat_desc; <span class="comment">/* the corresponding static tree */</span>
00072 } FAR tree_desc;
00073 
00074 <span class="keyword">typedef</span> ush Pos;
00075 <span class="keyword">typedef</span> Pos FAR Posf;
00076 <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> IPos;
00077 
00078 <span class="comment">/* A Pos is an index in the character window. We use short instead of int to</span>
00079 <span class="comment"> * save space in the various tables. IPos is used only for parameter passing.</span>
00080 <span class="comment"> */</span>
00081 
00082 <span class="keyword">typedef</span> <span class="keyword">struct </span>internal_state {
00083     z_streamp strm;      <span class="comment">/* pointer back to this zlib stream */</span>
00084     <span class="keywordtype">int</span>   status;        <span class="comment">/* as the name implies */</span>
00085     Bytef *pending_buf;  <span class="comment">/* output still pending */</span>
00086     ulg   pending_buf_size; <span class="comment">/* size of pending_buf */</span>
00087     Bytef *pending_out;  <span class="comment">/* next pending byte to output to the stream */</span>
00088     <span class="keywordtype">int</span>   pending;       <span class="comment">/* nb of bytes in the pending buffer */</span>
00089     <span class="keywordtype">int</span>   noheader;      <span class="comment">/* suppress zlib header and adler32 */</span>
00090     Byte  data_type;     <span class="comment">/* UNKNOWN, BINARY or ASCII */</span>
00091     Byte  method;        <span class="comment">/* STORED (for zip only) or DEFLATED */</span>
00092     <span class="keywordtype">int</span>   last_flush;    <span class="comment">/* value of flush param for previous deflate call */</span>
00093 
00094                 <span class="comment">/* used by deflate.c: */</span>
00095 
00096     uInt  w_size;        <span class="comment">/* LZ77 window size (32K by default) */</span>
00097     uInt  w_bits;        <span class="comment">/* log2(w_size)  (8..16) */</span>
00098     uInt  w_mask;        <span class="comment">/* w_size - 1 */</span>
00099 
00100     Bytef *window;
00101     <span class="comment">/* Sliding window. Input bytes are read into the second half of the window,</span>
00102 <span class="comment">     * and move to the first half later to keep a dictionary of at least wSize</span>
00103 <span class="comment">     * bytes. With this organization, matches are limited to a distance of</span>
00104 <span class="comment">     * wSize-MAX_MATCH bytes, but this ensures that IO is always</span>
00105 <span class="comment">     * performed with a length multiple of the block size. Also, it limits</span>
00106 <span class="comment">     * the window size to 64K, which is quite useful on MSDOS.</span>
00107 <span class="comment">     * To do: use the user input buffer as sliding window.</span>
00108 <span class="comment">     */</span>
00109 
00110     ulg window_size;
00111     <span class="comment">/* Actual size of window: 2*wSize, except when the user input buffer</span>
00112 <span class="comment">     * is directly used as sliding window.</span>
00113 <span class="comment">     */</span>
00114 
00115     Posf *prev;
00116     <span class="comment">/* Link to older string with same hash index. To limit the size of this</span>
00117 <span class="comment">     * array to 64K, this link is maintained only for the last 32K strings.</span>
00118 <span class="comment">     * An index in this array is thus a window index modulo 32K.</span>
00119 <span class="comment">     */</span>
00120 
00121     Posf *head; <span class="comment">/* Heads of the hash chains or NIL. */</span>
00122 
00123     uInt  ins_h;          <span class="comment">/* hash index of string to be inserted */</span>
00124     uInt  hash_size;      <span class="comment">/* number of elements in hash table */</span>
00125     uInt  hash_bits;      <span class="comment">/* log2(hash_size) */</span>
00126     uInt  hash_mask;      <span class="comment">/* hash_size-1 */</span>
00127 
00128     uInt  hash_shift;
00129     <span class="comment">/* Number of bits by which ins_h must be shifted at each input</span>
00130 <span class="comment">     * step. It must be such that after MIN_MATCH steps, the oldest</span>
00131 <span class="comment">     * byte no longer takes part in the hash key, that is:</span>
00132 <span class="comment">     *   hash_shift * MIN_MATCH &gt;= hash_bits</span>
00133 <span class="comment">     */</span>
00134 
00135     <span class="keywordtype">long</span> block_start;
00136     <span class="comment">/* Window position at the beginning of the current output block. Gets</span>
00137 <span class="comment">     * negative when the window is moved backwards.</span>
00138 <span class="comment">     */</span>
00139 
00140     uInt match_length;           <span class="comment">/* length of best match */</span>
00141     IPos prev_match;             <span class="comment">/* previous match */</span>
00142     <span class="keywordtype">int</span> match_available;         <span class="comment">/* set if previous match exists */</span>
00143     uInt strstart;               <span class="comment">/* start of string to insert */</span>
00144     uInt match_start;            <span class="comment">/* start of matching string */</span>
00145     uInt lookahead;              <span class="comment">/* number of valid bytes ahead in window */</span>
00146 
00147     uInt prev_length;
00148     <span class="comment">/* Length of the best match at previous step. Matches not greater than this</span>
00149 <span class="comment">     * are discarded. This is used in the lazy match evaluation.</span>
00150 <span class="comment">     */</span>
00151 
00152     uInt max_chain_length;
00153     <span class="comment">/* To speed up deflation, hash chains are never searched beyond this</span>
00154 <span class="comment">     * length.  A higher limit improves compression ratio but degrades the</span>
00155 <span class="comment">     * speed.</span>
00156 <span class="comment">     */</span>
00157 
00158     uInt max_lazy_match;
00159     <span class="comment">/* Attempt to find a better match only when the current match is strictly</span>
00160 <span class="comment">     * smaller than this value. This mechanism is used only for compression</span>
00161 <span class="comment">     * levels &gt;= 4.</span>
00162 <span class="comment">     */</span>
00163 <span class="preprocessor">#   define max_insert_length  max_lazy_match</span>
00164 <span class="preprocessor"></span>    <span class="comment">/* Insert new strings in the hash table only if the match length is not</span>
00165 <span class="comment">     * greater than this length. This saves time but degrades compression.</span>
00166 <span class="comment">     * max_insert_length is used only for compression levels &lt;= 3.</span>
00167 <span class="comment">     */</span>
00168 
00169     <span class="keywordtype">int</span> level;    <span class="comment">/* compression level (1..9) */</span>
00170     <span class="keywordtype">int</span> strategy; <span class="comment">/* favor or force Huffman coding*/</span>
00171 
00172     uInt good_match;
00173     <span class="comment">/* Use a faster search when the previous match is longer than this */</span>
00174 
00175     <span class="keywordtype">int</span> nice_match; <span class="comment">/* Stop searching when current match exceeds this */</span>
00176 
00177                 <span class="comment">/* used by trees.c: */</span>
00178     <span class="comment">/* Didn't use ct_data typedef below to supress compiler warning */</span>
00179     <span class="keyword">struct </span>ct_data_s dyn_ltree[HEAP_SIZE];   <span class="comment">/* literal and length tree */</span>
00180     <span class="keyword">struct </span>ct_data_s dyn_dtree[2*D_CODES+1]; <span class="comment">/* distance tree */</span>
00181     <span class="keyword">struct </span>ct_data_s bl_tree[2*BL_CODES+1];  <span class="comment">/* Huffman tree for bit lengths */</span>
00182 
00183     <span class="keyword">struct </span>tree_desc_s l_desc;               <span class="comment">/* desc. for literal tree */</span>
00184     <span class="keyword">struct </span>tree_desc_s d_desc;               <span class="comment">/* desc. for distance tree */</span>
00185     <span class="keyword">struct </span>tree_desc_s bl_desc;              <span class="comment">/* desc. for bit length tree */</span>
00186 
00187     ush bl_count[MAX_BITS+1];
00188     <span class="comment">/* number of codes at each bit length for an optimal tree */</span>
00189 
00190     <span class="keywordtype">int</span> heap[2*L_CODES+1];      <span class="comment">/* heap used to build the Huffman trees */</span>
00191     <span class="keywordtype">int</span> heap_len;               <span class="comment">/* number of elements in the heap */</span>
00192     <span class="keywordtype">int</span> heap_max;               <span class="comment">/* element of largest frequency */</span>
00193     <span class="comment">/* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.</span>
00194 <span class="comment">     * The same heap array is used to build all trees.</span>
00195 <span class="comment">     */</span>
00196 
00197     uch depth[2*L_CODES+1];
00198     <span class="comment">/* Depth of each subtree used as tie breaker for trees of equal frequency</span>
00199 <span class="comment">     */</span>
00200 
00201     uchf *l_buf;          <span class="comment">/* buffer for literals or lengths */</span>
00202 
00203     uInt  lit_bufsize;
00204     <span class="comment">/* Size of match buffer for literals/lengths.  There are 4 reasons for</span>
00205 <span class="comment">     * limiting lit_bufsize to 64K:</span>
00206 <span class="comment">     *   - frequencies can be kept in 16 bit counters</span>
00207 <span class="comment">     *   - if compression is not successful for the first block, all input</span>
00208 <span class="comment">     *     data is still in the window so we can still emit a stored block even</span>
00209 <span class="comment">     *     when input comes from standard input.  (This can also be done for</span>
00210 <span class="comment">     *     all blocks if lit_bufsize is not greater than 32K.)</span>
00211 <span class="comment">     *   - if compression is not successful for a file smaller than 64K, we can</span>
00212 <span class="comment">     *     even emit a stored file instead of a stored block (saving 5 bytes).</span>
00213 <span class="comment">     *     This is applicable only for zip (not gzip or zlib).</span>
00214 <span class="comment">     *   - creating new Huffman trees less frequently may not provide fast</span>
00215 <span class="comment">     *     adaptation to changes in the input data statistics. (Take for</span>
00216 <span class="comment">     *     example a binary file with poorly compressible code followed by</span>
00217 <span class="comment">     *     a highly compressible string table.) Smaller buffer sizes give</span>
00218 <span class="comment">     *     fast adaptation but have of course the overhead of transmitting</span>
00219 <span class="comment">     *     trees more frequently.</span>
00220 <span class="comment">     *   - I can't count above 4</span>
00221 <span class="comment">     */</span>
00222 
00223     uInt last_lit;      <span class="comment">/* running index in l_buf */</span>
00224 
00225     ushf *d_buf;
00226     <span class="comment">/* Buffer for distances. To simplify the code, d_buf and l_buf have</span>
00227 <span class="comment">     * the same number of elements. To use different lengths, an extra flag</span>
00228 <span class="comment">     * array would be necessary.</span>
00229 <span class="comment">     */</span>
00230 
00231     ulg opt_len;        <span class="comment">/* bit length of current block with optimal trees */</span>
00232     ulg static_len;     <span class="comment">/* bit length of current block with static trees */</span>
00233     uInt matches;       <span class="comment">/* number of string matches in current block */</span>
00234     <span class="keywordtype">int</span> last_eob_len;   <span class="comment">/* bit length of EOB code for last block */</span>
00235 
00236 <span class="preprocessor">#ifdef DEBUG</span>
00237 <span class="preprocessor"></span>    ulg compressed_len; <span class="comment">/* total bit length of compressed file mod 2^32 */</span>
00238     ulg bits_sent;      <span class="comment">/* bit length of compressed data sent mod 2^32 */</span>
00239 <span class="preprocessor">#endif</span>
00240 <span class="preprocessor"></span>
00241     ush bi_buf;
00242     <span class="comment">/* Output buffer. bits are inserted starting at the bottom (least</span>
00243 <span class="comment">     * significant bits).</span>
00244 <span class="comment">     */</span>
00245     <span class="keywordtype">int</span> bi_valid;
00246     <span class="comment">/* Number of valid bits in bi_buf.  All bits above the last valid bit</span>
00247 <span class="comment">     * are always zero.</span>
00248 <span class="comment">     */</span>
00249 
00250 } FAR deflate_state;
00251 
00252 <span class="comment">/* Output a byte on the stream.</span>
00253 <span class="comment"> * IN assertion: there is enough room in pending_buf.</span>
00254 <span class="comment"> */</span>
00255 <span class="preprocessor">#define put_byte(s, c) {s-&gt;pending_buf[s-&gt;pending++] = (c);}</span>
00256 <span class="preprocessor"></span>
00257 
00258 <span class="preprocessor">#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)</span>
00259 <span class="preprocessor"></span><span class="comment">/* Minimum amount of lookahead, except at the end of the input file.</span>
00260 <span class="comment"> * See deflate.c for comments about the MIN_MATCH+1.</span>
00261 <span class="comment"> */</span>
00262 
00263 <span class="preprocessor">#define MAX_DIST(s)  ((s)-&gt;w_size-MIN_LOOKAHEAD)</span>
00264 <span class="preprocessor"></span><span class="comment">/* In order to simplify the code, particularly on 16 bit machines, match</span>
00265 <span class="comment"> * distances are limited to MAX_DIST instead of WSIZE.</span>
00266 <span class="comment"> */</span>
00267 
00268         <span class="comment">/* in trees.c */</span>
00269 <span class="keywordtype">void</span> _tr_init         OF((deflate_state *s));
00270 <span class="keywordtype">int</span>  _tr_tally        OF((deflate_state *s, <span class="keywordtype">unsigned</span> dist, <span class="keywordtype">unsigned</span> lc));
00271 <span class="keywordtype">void</span> _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
00272               <span class="keywordtype">int</span> eof));
00273 <span class="keywordtype">void</span> _tr_align        OF((deflate_state *s));
00274 <span class="keywordtype">void</span> _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
00275                           <span class="keywordtype">int</span> eof));
00276 
00277 <span class="preprocessor">#define d_code(dist) \</span>
00278 <span class="preprocessor">   ((dist) &lt; 256 ? _dist_code[dist] : _dist_code[256+((dist)&gt;&gt;7)])</span>
00279 <span class="preprocessor"></span><span class="comment">/* Mapping from a distance to a distance code. dist is the distance - 1 and</span>
00280 <span class="comment"> * must not have side effects. _dist_code[256] and _dist_code[257] are never</span>
00281 <span class="comment"> * used.</span>
00282 <span class="comment"> */</span>
00283 
00284 <span class="preprocessor">#ifndef DEBUG</span>
00285 <span class="preprocessor"></span><span class="comment">/* Inline versions of _tr_tally for speed: */</span>
00286 
00287 <span class="preprocessor">#if defined(GEN_TREES_H) || !defined(STDC)</span>
00288 <span class="preprocessor"></span>  <span class="keyword">extern</span> uch _length_code[];
00289   <span class="keyword">extern</span> uch _dist_code[];
00290 <span class="preprocessor">#else</span>
00291 <span class="preprocessor"></span>  <span class="keyword">extern</span> <span class="keyword">const</span> uch _length_code[];
00292   <span class="keyword">extern</span> <span class="keyword">const</span> uch _dist_code[];
00293 <span class="preprocessor">#endif</span>
00294 <span class="preprocessor"></span>
00295 <span class="preprocessor"># define _tr_tally_lit(s, c, flush) \</span>
00296 <span class="preprocessor">  { uch cc = (c); \</span>
00297 <span class="preprocessor">    s-&gt;d_buf[s-&gt;last_lit] = 0; \</span>
00298 <span class="preprocessor">    s-&gt;l_buf[s-&gt;last_lit++] = cc; \</span>
00299 <span class="preprocessor">    s-&gt;dyn_ltree[cc].Freq++; \</span>
00300 <span class="preprocessor">    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \</span>
00301 <span class="preprocessor">   }</span>
00302 <span class="preprocessor"></span><span class="preprocessor"># define _tr_tally_dist(s, distance, length, flush) \</span>
00303 <span class="preprocessor">  { uch len = (length); \</span>
00304 <span class="preprocessor">    ush dist = (distance); \</span>
00305 <span class="preprocessor">    s-&gt;d_buf[s-&gt;last_lit] = dist; \</span>
00306 <span class="preprocessor">    s-&gt;l_buf[s-&gt;last_lit++] = len; \</span>
00307 <span class="preprocessor">    dist--; \</span>
00308 <span class="preprocessor">    s-&gt;dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \</span>
00309 <span class="preprocessor">    s-&gt;dyn_dtree[d_code(dist)].Freq++; \</span>
00310 <span class="preprocessor">    flush = (s-&gt;last_lit == s-&gt;lit_bufsize-1); \</span>
00311 <span class="preprocessor">  }</span>
00312 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00313 <span class="preprocessor"></span><span class="preprocessor"># define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)</span>
00314 <span class="preprocessor"></span><span class="preprocessor"># define _tr_tally_dist(s, distance, length, flush) \</span>
00315 <span class="preprocessor">              flush = _tr_tally(s, distance, length) </span>
00316 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00317 <span class="preprocessor"></span>
00318 <span class="preprocessor">#endif</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:40 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

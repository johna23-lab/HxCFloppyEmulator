<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>u_heavy.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>u_heavy.c</h1><div class="fragment"><pre>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> *     xDMS  v1.3  -  Portable DMS archive unpacker  -  Public Domain</span>
00004 <span class="comment"> *     Written by     Andre Rodrigues de la Rocha  &lt;adlroc@usa.net&gt;</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *     Lempel-Ziv-Huffman decompression functions used in Heavy 1 &amp; 2 </span>
00007 <span class="comment"> *     compression modes. Based on LZH decompression functions from</span>
00008 <span class="comment"> *     UNIX LHA made by Masaru Oki</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> */</span>
00011 
00012 
00013 <span class="preprocessor">#include "cdata.h"</span>
00014 <span class="preprocessor">#include "u_heavy.h"</span>
00015 <span class="preprocessor">#include "getbits.h"</span>
00016 <span class="preprocessor">#include "maketbl.h"</span>
00017 
00018 
00019 <span class="preprocessor">#define NC 510</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define NPT 20</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define N1 510</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define OFFSET 253</span>
00023 <span class="preprocessor"></span>
00024 USHORT left[2 * NC - 1], right[2 * NC - 1 + 9];
00025 <span class="keyword">static</span> UCHAR c_len[NC], pt_len[NPT];
00026 <span class="keyword">static</span> USHORT c_table[4096], pt_table[256];
00027 <span class="keyword">static</span> USHORT lastlen, np;
00028 USHORT heavy_text_loc;
00029 
00030 
00031 <span class="keyword">static</span> USHORT read_tree_c(<span class="keywordtype">void</span>);
00032 <span class="keyword">static</span> USHORT read_tree_p(<span class="keywordtype">void</span>);
00033 INLINE USHORT decode_c(<span class="keywordtype">void</span>);
00034 INLINE USHORT decode_p(<span class="keywordtype">void</span>);
00035 
00036 
00037 
00038 USHORT Unpack_HEAVY(UCHAR *in, UCHAR *out, UCHAR flags, USHORT origsize){
00039     USHORT j, i, c, bitmask;
00040     UCHAR *outend;
00041 
00042     <span class="comment">/*  Heavy 1 uses a 4Kb dictionary,  Heavy 2 uses 8Kb  */</span>
00043 
00044     <span class="keywordflow">if</span> (flags &amp; 8) {
00045         np = 15;
00046         bitmask = 0x1fff;
00047     } <span class="keywordflow">else</span> {
00048         np = 14;
00049         bitmask = 0x0fff;
00050     }
00051 
00052     initbitbuf(in);
00053 
00054     <span class="keywordflow">if</span> (flags &amp; 2) {
00055         <span class="keywordflow">if</span> (read_tree_c()) <span class="keywordflow">return</span> 1;
00056         <span class="keywordflow">if</span> (read_tree_p()) <span class="keywordflow">return</span> 2;
00057     }
00058 
00059     outend = out+origsize;
00060 
00061     <span class="keywordflow">while</span> (out&lt;outend) {
00062         c = decode_c();
00063         <span class="keywordflow">if</span> (c &lt; 256) {
00064             *out++ = text[heavy_text_loc++ &amp; bitmask] = (UCHAR)c;
00065         } <span class="keywordflow">else</span> {
00066             j = (USHORT) (c - OFFSET);
00067             i = (USHORT) (heavy_text_loc - decode_p() - 1);
00068             <span class="keywordflow">while</span>(j--) *out++ = text[heavy_text_loc++ &amp; bitmask] = text[i++ &amp; bitmask];
00069         }
00070     }
00071 
00072     <span class="keywordflow">return</span> 0;
00073 }
00074 
00075 
00076 
00077 INLINE USHORT decode_c(<span class="keywordtype">void</span>){
00078     USHORT i, j, m;
00079 
00080     j = c_table[GETBITS(12)];
00081     <span class="keywordflow">if</span> (j &lt; N1) {
00082         DROPBITS(c_len[j]);
00083     } <span class="keywordflow">else</span> {
00084         DROPBITS(12);
00085         i = GETBITS(16);
00086         m = 0x8000;
00087         <span class="keywordflow">do</span> {
00088             <span class="keywordflow">if</span> (i &amp; m) j = right[j];
00089             <span class="keywordflow">else</span>              j = left [j];
00090             m &gt;&gt;= 1;
00091         } <span class="keywordflow">while</span> (j &gt;= N1);
00092         DROPBITS(c_len[j] - 12);
00093     }
00094     <span class="keywordflow">return</span> j;
00095 }
00096 
00097 
00098 
00099 INLINE USHORT decode_p(<span class="keywordtype">void</span>){
00100     USHORT i, j, m;
00101 
00102     j = pt_table[GETBITS(8)];
00103     <span class="keywordflow">if</span> (j &lt; np) {
00104         DROPBITS(pt_len[j]);
00105     } <span class="keywordflow">else</span> {
00106         DROPBITS(8);
00107         i = GETBITS(16);
00108         m = 0x8000;
00109         <span class="keywordflow">do</span> {
00110             <span class="keywordflow">if</span> (i &amp; m) j = right[j];
00111             <span class="keywordflow">else</span>             j = left [j];
00112             m &gt;&gt;= 1;
00113         } <span class="keywordflow">while</span> (j &gt;= np);
00114         DROPBITS(pt_len[j] - 8);
00115     }
00116 
00117     <span class="keywordflow">if</span> (j != np-1) {
00118         <span class="keywordflow">if</span> (j &gt; 0) {
00119             j = (USHORT)(GETBITS(i=(USHORT)(j-1)) | (1U &lt;&lt; (j-1)));
00120             DROPBITS(i);
00121         }
00122         lastlen=j;
00123     }
00124 
00125     <span class="keywordflow">return</span> lastlen;
00126 
00127 }
00128 
00129 
00130 
00131 <span class="keyword">static</span> USHORT read_tree_c(<span class="keywordtype">void</span>){
00132     USHORT i,n;
00133 
00134     n = GETBITS(9);
00135     DROPBITS(9);
00136     <span class="keywordflow">if</span> (n&gt;0){
00137         <span class="keywordflow">for</span> (i=0; i&lt;n; i++) {
00138             c_len[i] = (UCHAR)GETBITS(5);
00139             DROPBITS(5);
00140         }
00141         <span class="keywordflow">for</span> (i=n; i&lt;510; i++) c_len[i] = 0;
00142         <span class="keywordflow">if</span> (make_table(510,c_len,12,c_table)) <span class="keywordflow">return</span> 1;
00143     } <span class="keywordflow">else</span> {
00144         n = GETBITS(9);
00145         DROPBITS(9);
00146         <span class="keywordflow">for</span> (i=0; i&lt;510; i++) c_len[i] = 0;
00147         <span class="keywordflow">for</span> (i=0; i&lt;4096; i++) c_table[i] = n;
00148     }
00149     <span class="keywordflow">return</span> 0;
00150 }
00151 
00152 
00153 
00154 <span class="keyword">static</span> USHORT read_tree_p(<span class="keywordtype">void</span>){
00155     USHORT i,n;
00156 
00157     n = GETBITS(5);
00158     DROPBITS(5);
00159     <span class="keywordflow">if</span> (n&gt;0){
00160         <span class="keywordflow">for</span> (i=0; i&lt;n; i++) {
00161             pt_len[i] = (UCHAR)GETBITS(4);
00162             DROPBITS(4);
00163         }
00164         <span class="keywordflow">for</span> (i=n; i&lt;np; i++) pt_len[i] = 0;
00165         <span class="keywordflow">if</span> (make_table(np,pt_len,8,pt_table)) <span class="keywordflow">return</span> 1;
00166     } <span class="keywordflow">else</span> {
00167         n = GETBITS(5);
00168         DROPBITS(5);
00169         <span class="keywordflow">for</span> (i=0; i&lt;np; i++) pt_len[i] = 0;
00170         <span class="keywordflow">for</span> (i=0; i&lt;256; i++) pt_table[i] = n;
00171     }
00172     <span class="keywordflow">return</span> 0;
00173 }
00174 
00175 
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:43 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

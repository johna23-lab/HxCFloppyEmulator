<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>inftrees.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>inftrees.c</h1><div class="fragment"><pre>00001 <span class="comment">/* inftrees.c -- generate Huffman trees for efficient decoding</span>
00002 <span class="comment"> * Copyright (C) 1995-2002 Mark Adler</span>
00003 <span class="comment"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
00004 <span class="comment"> */</span>
00005 
00006 <span class="preprocessor">#include "zutil.h"</span>
00007 <span class="preprocessor">#include "inftrees.h"</span>
00008 
00009 <span class="preprocessor">#if !defined(BUILDFIXED) &amp;&amp; !defined(STDC)</span>
00010 <span class="preprocessor"></span><span class="preprocessor">#  define BUILDFIXED   </span><span class="comment">/* non ANSI compilers may not accept inffixed.h */</span>
00011 <span class="preprocessor">#endif</span>
00012 <span class="preprocessor"></span>
00013 <span class="keyword">const</span> <span class="keywordtype">char</span> inflate_copyright[] =
00014    <span class="stringliteral">" inflate 1.1.4 Copyright 1995-2002 Mark Adler "</span>;
00015 <span class="comment">/*</span>
00016 <span class="comment">  If you use the zlib library in a product, an acknowledgment is welcome</span>
00017 <span class="comment">  in the documentation of your product. If for some reason you cannot</span>
00018 <span class="comment">  include such an acknowledgment, I would appreciate that you keep this</span>
00019 <span class="comment">  copyright string in the executable of your product.</span>
00020 <span class="comment"> */</span>
00021 <span class="keyword">struct </span>internal_state  {<span class="keywordtype">int</span> dummy;}; <span class="comment">/* for buggy compilers */</span>
00022 
00023 <span class="comment">/* simplify the use of the inflate_huft type with some defines */</span>
00024 <span class="preprocessor">#define exop word.what.Exop</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#define bits word.what.Bits</span>
00026 <span class="preprocessor"></span>
00027 
00028 local <span class="keywordtype">int</span> huft_build OF((
00029     uIntf *,            <span class="comment">/* code lengths in bits */</span>
00030     uInt,               <span class="comment">/* number of codes */</span>
00031     uInt,               <span class="comment">/* number of "simple" codes */</span>
00032     <span class="keyword">const</span> uIntf *,      <span class="comment">/* list of base values for non-simple codes */</span>
00033     <span class="keyword">const</span> uIntf *,      <span class="comment">/* list of extra bits for non-simple codes */</span>
00034     inflate_huft * FAR*,<span class="comment">/* result: starting table */</span>
00035     uIntf *,            <span class="comment">/* maximum lookup bits (returns actual) */</span>
00036     inflate_huft *,     <span class="comment">/* space for trees */</span>
00037     uInt *,             <span class="comment">/* hufts used in space */</span>
00038     uIntf * ));         <span class="comment">/* space for values */</span>
00039 
00040 <span class="comment">/* Tables for deflate from PKZIP's appnote.txt. */</span>
00041 local <span class="keyword">const</span> uInt cplens[31] = { <span class="comment">/* Copy lengths for literal codes 257..285 */</span>
00042         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
00043         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
00044         <span class="comment">/* see note #13 above about 258 */</span>
00045 local <span class="keyword">const</span> uInt cplext[31] = { <span class="comment">/* Extra bits for literal codes 257..285 */</span>
00046         0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
00047         3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; <span class="comment">/* 112==invalid */</span>
00048 local <span class="keyword">const</span> uInt cpdist[30] = { <span class="comment">/* Copy offsets for distance codes 0..29 */</span>
00049         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
00050         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
00051         8193, 12289, 16385, 24577};
00052 local <span class="keyword">const</span> uInt cpdext[30] = { <span class="comment">/* Extra bits for distance codes */</span>
00053         0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
00054         7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
00055         12, 12, 13, 13};
00056 
00057 <span class="comment">/*</span>
00058 <span class="comment">   Huffman code decoding is performed using a multi-level table lookup.</span>
00059 <span class="comment">   The fastest way to decode is to simply build a lookup table whose</span>
00060 <span class="comment">   size is determined by the longest code.  However, the time it takes</span>
00061 <span class="comment">   to build this table can also be a factor if the data being decoded</span>
00062 <span class="comment">   is not very long.  The most common codes are necessarily the</span>
00063 <span class="comment">   shortest codes, so those codes dominate the decoding time, and hence</span>
00064 <span class="comment">   the speed.  The idea is you can have a shorter table that decodes the</span>
00065 <span class="comment">   shorter, more probable codes, and then point to subsidiary tables for</span>
00066 <span class="comment">   the longer codes.  The time it costs to decode the longer codes is</span>
00067 <span class="comment">   then traded against the time it takes to make longer tables.</span>
00068 <span class="comment"></span>
00069 <span class="comment">   This results of this trade are in the variables lbits and dbits</span>
00070 <span class="comment">   below.  lbits is the number of bits the first level table for literal/</span>
00071 <span class="comment">   length codes can decode in one step, and dbits is the same thing for</span>
00072 <span class="comment">   the distance codes.  Subsequent tables are also less than or equal to</span>
00073 <span class="comment">   those sizes.  These values may be adjusted either when all of the</span>
00074 <span class="comment">   codes are shorter than that, in which case the longest code length in</span>
00075 <span class="comment">   bits is used, or when the shortest code is *longer* than the requested</span>
00076 <span class="comment">   table size, in which case the length of the shortest code in bits is</span>
00077 <span class="comment">   used.</span>
00078 <span class="comment"></span>
00079 <span class="comment">   There are two different values for the two tables, since they code a</span>
00080 <span class="comment">   different number of possibilities each.  The literal/length table</span>
00081 <span class="comment">   codes 286 possible values, or in a flat code, a little over eight</span>
00082 <span class="comment">   bits.  The distance table codes 30 possible values, or a little less</span>
00083 <span class="comment">   than five bits, flat.  The optimum values for speed end up being</span>
00084 <span class="comment">   about one bit more than those, so lbits is 8+1 and dbits is 5+1.</span>
00085 <span class="comment">   The optimum values may differ though from machine to machine, and</span>
00086 <span class="comment">   possibly even between compilers.  Your mileage may vary.</span>
00087 <span class="comment"> */</span>
00088 
00089 
00090 <span class="comment">/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */</span>
00091 <span class="preprocessor">#define BMAX 15         </span><span class="comment">/* maximum bit length of any code */</span>
00092 
00093 local <span class="keywordtype">int</span> huft_build(b, n, s, d, e, t, m, hp, hn, v)
00094 uIntf *b;               <span class="comment">/* code lengths in bits (all assumed &lt;= BMAX) */</span>
00095 uInt n;                 <span class="comment">/* number of codes (assumed &lt;= 288) */</span>
00096 uInt s;                 <span class="comment">/* number of simple-valued codes (0..s-1) */</span>
00097 <span class="keyword">const</span> uIntf *d;         <span class="comment">/* list of base values for non-simple codes */</span>
00098 <span class="keyword">const</span> uIntf *e;         <span class="comment">/* list of extra bits for non-simple codes */</span>
00099 inflate_huft * FAR *t;  <span class="comment">/* result: starting table */</span>
00100 uIntf *m;               <span class="comment">/* maximum lookup bits, returns actual */</span>
00101 inflate_huft *hp;       <span class="comment">/* space for trees */</span>
00102 uInt *hn;               <span class="comment">/* hufts used in space */</span>
00103 uIntf *v;               <span class="comment">/* working area: values in order of bit length */</span>
00104 <span class="comment">/* Given a list of code lengths and a maximum table size, make a set of</span>
00105 <span class="comment">   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR</span>
00106 <span class="comment">   if the given code set is incomplete (the tables are still built in this</span>
00107 <span class="comment">   case), or Z_DATA_ERROR if the input is invalid. */</span>
00108 {
00109 
00110   uInt a;                       <span class="comment">/* counter for codes of length k */</span>
00111   uInt c[BMAX+1];               <span class="comment">/* bit length count table */</span>
00112   uInt f;                       <span class="comment">/* i repeats in table every f entries */</span>
00113   <span class="keywordtype">int</span> g;                        <span class="comment">/* maximum code length */</span>
00114   <span class="keywordtype">int</span> h;                        <span class="comment">/* table level */</span>
00115   <span class="keyword">register</span> uInt i;              <span class="comment">/* counter, current code */</span>
00116   <span class="keyword">register</span> uInt j;              <span class="comment">/* counter */</span>
00117   <span class="keyword">register</span> <span class="keywordtype">int</span> k;               <span class="comment">/* number of bits in current code */</span>
00118   <span class="keywordtype">int</span> l;                        <span class="comment">/* bits per table (returned in m) */</span>
00119   uInt mask;                    <span class="comment">/* (1 &lt;&lt; w) - 1, to avoid cc -O bug on HP */</span>
00120   <span class="keyword">register</span> uIntf *p;            <span class="comment">/* pointer into c[], b[], or v[] */</span>
00121   inflate_huft *q;              <span class="comment">/* points to current table */</span>
00122   <span class="keyword">struct </span>inflate_huft_s r;      <span class="comment">/* table entry for structure assignment */</span>
00123   inflate_huft *u[BMAX];        <span class="comment">/* table stack */</span>
00124   <span class="keyword">register</span> <span class="keywordtype">int</span> w;               <span class="comment">/* bits before this table == (l * h) */</span>
00125   uInt x[BMAX+1];               <span class="comment">/* bit offsets, then code stack */</span>
00126   uIntf *xp;                    <span class="comment">/* pointer into x */</span>
00127   <span class="keywordtype">int</span> y;                        <span class="comment">/* number of dummy codes added */</span>
00128   uInt z;                       <span class="comment">/* number of entries in current table */</span>
00129 
00130 
00131   <span class="comment">/* Generate counts for each bit length */</span>
00132   p = c;
00133 <span class="preprocessor">#define C0 *p++ = 0;</span>
00134 <span class="preprocessor"></span><span class="preprocessor">#define C2 C0 C0 C0 C0</span>
00135 <span class="preprocessor"></span><span class="preprocessor">#define C4 C2 C2 C2 C2</span>
00136 <span class="preprocessor"></span>  C4                            <span class="comment">/* clear c[]--assume BMAX+1 is 16 */</span>
00137   p = b;  i = n;
00138   <span class="keywordflow">do</span> {
00139     c[*p++]++;                  <span class="comment">/* assume all entries &lt;= BMAX */</span>
00140   } <span class="keywordflow">while</span> (--i);
00141   <span class="keywordflow">if</span> (c[0] == n)                <span class="comment">/* null input--all zero length codes */</span>
00142   {
00143     *t = (inflate_huft *)Z_NULL;
00144     *m = 0;
00145     <span class="keywordflow">return</span> Z_OK;
00146   }
00147 
00148 
00149   <span class="comment">/* Find minimum and maximum length, bound *m by those */</span>
00150   l = *m;
00151   <span class="keywordflow">for</span> (j = 1; j &lt;= BMAX; j++)
00152     <span class="keywordflow">if</span> (c[j])
00153       <span class="keywordflow">break</span>;
00154   k = j;                        <span class="comment">/* minimum code length */</span>
00155   <span class="keywordflow">if</span> ((uInt)l &lt; j)
00156     l = j;
00157   <span class="keywordflow">for</span> (i = BMAX; i; i--)
00158     <span class="keywordflow">if</span> (c[i])
00159       <span class="keywordflow">break</span>;
00160   g = i;                        <span class="comment">/* maximum code length */</span>
00161   <span class="keywordflow">if</span> ((uInt)l &gt; i)
00162     l = i;
00163   *m = l;
00164 
00165 
00166   <span class="comment">/* Adjust last length count to fill out codes, if needed */</span>
00167   <span class="keywordflow">for</span> (y = 1 &lt;&lt; j; j &lt; i; j++, y &lt;&lt;= 1)
00168     <span class="keywordflow">if</span> ((y -= c[j]) &lt; 0)
00169       <span class="keywordflow">return</span> Z_DATA_ERROR;
00170   <span class="keywordflow">if</span> ((y -= c[i]) &lt; 0)
00171     <span class="keywordflow">return</span> Z_DATA_ERROR;
00172   c[i] += y;
00173 
00174 
00175   <span class="comment">/* Generate starting offsets into the value table for each length */</span>
00176   x[1] = j = 0;
00177   p = c + 1;  xp = x + 2;
00178   <span class="keywordflow">while</span> (--i) {                 <span class="comment">/* note that i == g from above */</span>
00179     *xp++ = (j += *p++);
00180   }
00181 
00182 
00183   <span class="comment">/* Make a table of values in order of bit lengths */</span>
00184   p = b;  i = 0;
00185   <span class="keywordflow">do</span> {
00186     <span class="keywordflow">if</span> ((j = *p++) != 0)
00187       v[x[j]++] = i;
00188   } <span class="keywordflow">while</span> (++i &lt; n);
00189   n = x[g];                     <span class="comment">/* set n to length of v */</span>
00190 
00191 
00192   <span class="comment">/* Generate the Huffman codes and for each, make the table entries */</span>
00193   x[0] = i = 0;                 <span class="comment">/* first Huffman code is zero */</span>
00194   p = v;                        <span class="comment">/* grab values in bit order */</span>
00195   h = -1;                       <span class="comment">/* no tables yet--level -1 */</span>
00196   w = -l;                       <span class="comment">/* bits decoded == (l * h) */</span>
00197   u[0] = (inflate_huft *)Z_NULL;        <span class="comment">/* just to keep compilers happy */</span>
00198   q = (inflate_huft *)Z_NULL;   <span class="comment">/* ditto */</span>
00199   z = 0;                        <span class="comment">/* ditto */</span>
00200 
00201   <span class="comment">/* go through the bit lengths (k already is bits in shortest code) */</span>
00202   <span class="keywordflow">for</span> (; k &lt;= g; k++)
00203   {
00204     a = c[k];
00205     <span class="keywordflow">while</span> (a--)
00206     {
00207       <span class="comment">/* here i is the Huffman code of length k bits for value *p */</span>
00208       <span class="comment">/* make tables up to required level */</span>
00209       <span class="keywordflow">while</span> (k &gt; w + l)
00210       {
00211         h++;
00212         w += l;                 <span class="comment">/* previous table always l bits */</span>
00213 
00214         <span class="comment">/* compute minimum size table less than or equal to l bits */</span>
00215         z = g - w;
00216         z = z &gt; (uInt)l ? l : z;        <span class="comment">/* table size upper limit */</span>
00217         <span class="keywordflow">if</span> ((f = 1 &lt;&lt; (j = k - w)) &gt; a + 1)     <span class="comment">/* try a k-w bit table */</span>
00218         {                       <span class="comment">/* too few codes for k-w bit table */</span>
00219           f -= a + 1;           <span class="comment">/* deduct codes from patterns left */</span>
00220           xp = c + k;
00221           <span class="keywordflow">if</span> (j &lt; z)
00222             <span class="keywordflow">while</span> (++j &lt; z)     <span class="comment">/* try smaller tables up to z bits */</span>
00223             {
00224               <span class="keywordflow">if</span> ((f &lt;&lt;= 1) &lt;= *++xp)
00225                 <span class="keywordflow">break</span>;          <span class="comment">/* enough codes to use up j bits */</span>
00226               f -= *xp;         <span class="comment">/* else deduct codes from patterns */</span>
00227             }
00228         }
00229         z = 1 &lt;&lt; j;             <span class="comment">/* table entries for j-bit table */</span>
00230 
00231         <span class="comment">/* allocate new table */</span>
00232         <span class="keywordflow">if</span> (*hn + z &gt; MANY)     <span class="comment">/* (note: doesn't matter for fixed) */</span>
00233           <span class="keywordflow">return</span> Z_DATA_ERROR;  <span class="comment">/* overflow of MANY */</span>
00234         u[h] = q = hp + *hn;
00235         *hn += z;
00236 
00237         <span class="comment">/* connect to last table, if there is one */</span>
00238         <span class="keywordflow">if</span> (h)
00239         {
00240           x[h] = i;             <span class="comment">/* save pattern for backing up */</span>
00241           r.bits = (Byte)l;     <span class="comment">/* bits to dump before this table */</span>
00242           r.exop = (Byte)j;     <span class="comment">/* bits in this table */</span>
00243           j = i &gt;&gt; (w - l);
00244           r.base = (uInt)(q - u[h-1] - j);   <span class="comment">/* offset to this table */</span>
00245           u[h-1][j] = r;        <span class="comment">/* connect to last table */</span>
00246         }
00247         <span class="keywordflow">else</span>
00248           *t = q;               <span class="comment">/* first table is returned result */</span>
00249       }
00250 
00251       <span class="comment">/* set up table entry in r */</span>
00252       r.bits = (Byte)(k - w);
00253       <span class="keywordflow">if</span> (p &gt;= v + n)
00254         r.exop = 128 + 64;      <span class="comment">/* out of values--invalid code */</span>
00255       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*p &lt; s)
00256       {
00257         r.exop = (Byte)(*p &lt; 256 ? 0 : 32 + 64);     <span class="comment">/* 256 is end-of-block */</span>
00258         r.base = *p++;          <span class="comment">/* simple code is just the value */</span>
00259       }
00260       <span class="keywordflow">else</span>
00261       {
00262         r.exop = (Byte)(e[*p - s] + 16 + 64);<span class="comment">/* non-simple--look up in lists */</span>
00263         r.base = d[*p++ - s];
00264       }
00265 
00266       <span class="comment">/* fill code-like entries with r */</span>
00267       f = 1 &lt;&lt; (k - w);
00268       <span class="keywordflow">for</span> (j = i &gt;&gt; w; j &lt; z; j += f)
00269         q[j] = r;
00270 
00271       <span class="comment">/* backwards increment the k-bit code i */</span>
00272       <span class="keywordflow">for</span> (j = 1 &lt;&lt; (k - 1); i &amp; j; j &gt;&gt;= 1)
00273         i ^= j;
00274       i ^= j;
00275 
00276       <span class="comment">/* backup over finished tables */</span>
00277       mask = (1 &lt;&lt; w) - 1;      <span class="comment">/* needed on HP, cc -O bug */</span>
00278       <span class="keywordflow">while</span> ((i &amp; mask) != x[h])
00279       {
00280         h--;                    <span class="comment">/* don't need to update q */</span>
00281         w -= l;
00282         mask = (1 &lt;&lt; w) - 1;
00283       }
00284     }
00285   }
00286 
00287 
00288   <span class="comment">/* Return Z_BUF_ERROR if we were given an incomplete table */</span>
00289   <span class="keywordflow">return</span> y != 0 &amp;&amp; g != 1 ? Z_BUF_ERROR : Z_OK;
00290 }
00291 
00292 
00293 <span class="keywordtype">int</span> inflate_trees_bits(c, bb, tb, hp, z)
00294 uIntf *c;               <span class="comment">/* 19 code lengths */</span>
00295 uIntf *bb;              <span class="comment">/* bits tree desired/actual depth */</span>
00296 inflate_huft * FAR *tb; <span class="comment">/* bits tree result */</span>
00297 inflate_huft *hp;       <span class="comment">/* space for trees */</span>
00298 z_streamp z;            <span class="comment">/* for messages */</span>
00299 {
00300   <span class="keywordtype">int</span> r;
00301   uInt hn = 0;          <span class="comment">/* hufts used in space */</span>
00302   uIntf *v;             <span class="comment">/* work area for huft_build */</span>
00303 
00304   <span class="keywordflow">if</span> ((v = (uIntf*)ZALLOC(z, 19, <span class="keyword">sizeof</span>(uInt))) == Z_NULL)
00305     <span class="keywordflow">return</span> Z_MEM_ERROR;
00306   r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
00307                  tb, bb, hp, &amp;hn, v);
00308   <span class="keywordflow">if</span> (r == Z_DATA_ERROR)
00309     z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"oversubscribed dynamic bit lengths tree"</span>;
00310   <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r == Z_BUF_ERROR || *bb == 0)
00311   {
00312     z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"incomplete dynamic bit lengths tree"</span>;
00313     r = Z_DATA_ERROR;
00314   }
00315   ZFREE(z, v);
00316   <span class="keywordflow">return</span> r;
00317 }
00318 
00319 
00320 <span class="keywordtype">int</span> inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)
00321 uInt nl;                <span class="comment">/* number of literal/length codes */</span>
00322 uInt nd;                <span class="comment">/* number of distance codes */</span>
00323 uIntf *c;               <span class="comment">/* that many (total) code lengths */</span>
00324 uIntf *bl;              <span class="comment">/* literal desired/actual bit depth */</span>
00325 uIntf *bd;              <span class="comment">/* distance desired/actual bit depth */</span>
00326 inflate_huft * FAR *tl; <span class="comment">/* literal/length tree result */</span>
00327 inflate_huft * FAR *td; <span class="comment">/* distance tree result */</span>
00328 inflate_huft *hp;       <span class="comment">/* space for trees */</span>
00329 z_streamp z;            <span class="comment">/* for messages */</span>
00330 {
00331   <span class="keywordtype">int</span> r;
00332   uInt hn = 0;          <span class="comment">/* hufts used in space */</span>
00333   uIntf *v;             <span class="comment">/* work area for huft_build */</span>
00334 
00335   <span class="comment">/* allocate work area */</span>
00336   <span class="keywordflow">if</span> ((v = (uIntf*)ZALLOC(z, 288, <span class="keyword">sizeof</span>(uInt))) == Z_NULL)
00337     <span class="keywordflow">return</span> Z_MEM_ERROR;
00338 
00339   <span class="comment">/* build literal/length tree */</span>
00340   r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &amp;hn, v);
00341   <span class="keywordflow">if</span> (r != Z_OK || *bl == 0)
00342   {
00343     <span class="keywordflow">if</span> (r == Z_DATA_ERROR)
00344       z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"oversubscribed literal/length tree"</span>;
00345     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r != Z_MEM_ERROR)
00346     {
00347       z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"incomplete literal/length tree"</span>;
00348       r = Z_DATA_ERROR;
00349     }
00350     ZFREE(z, v);
00351     <span class="keywordflow">return</span> r;
00352   }
00353 
00354   <span class="comment">/* build distance tree */</span>
00355   r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &amp;hn, v);
00356   <span class="keywordflow">if</span> (r != Z_OK || (*bd == 0 &amp;&amp; nl &gt; 257))
00357   {
00358     <span class="keywordflow">if</span> (r == Z_DATA_ERROR)
00359       z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"oversubscribed distance tree"</span>;
00360     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r == Z_BUF_ERROR) {
00361 <span class="preprocessor">#ifdef PKZIP_BUG_WORKAROUND</span>
00362 <span class="preprocessor"></span>      r = Z_OK;
00363     }
00364 <span class="preprocessor">#else</span>
00365 <span class="preprocessor"></span>      z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"incomplete distance tree"</span>;
00366       r = Z_DATA_ERROR;
00367     }
00368     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (r != Z_MEM_ERROR)
00369     {
00370       z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"empty distance tree with lengths"</span>;
00371       r = Z_DATA_ERROR;
00372     }
00373     ZFREE(z, v);
00374     <span class="keywordflow">return</span> r;
00375 <span class="preprocessor">#endif</span>
00376 <span class="preprocessor"></span>  }
00377 
00378   <span class="comment">/* done */</span>
00379   ZFREE(z, v);
00380   <span class="keywordflow">return</span> Z_OK;
00381 }
00382 
00383 
00384 <span class="comment">/* build fixed tables only once--keep them here */</span>
00385 <span class="preprocessor">#ifdef BUILDFIXED</span>
00386 <span class="preprocessor"></span>local <span class="keywordtype">int</span> fixed_built = 0;
00387 <span class="preprocessor">#define FIXEDH 544      </span><span class="comment">/* number of hufts used by fixed tables */</span>
00388 local inflate_huft fixed_mem[FIXEDH];
00389 local uInt fixed_bl;
00390 local uInt fixed_bd;
00391 local inflate_huft *fixed_tl;
00392 local inflate_huft *fixed_td;
00393 <span class="preprocessor">#else</span>
00394 <span class="preprocessor"></span><span class="preprocessor">#include "inffixed.h"</span>
00395 <span class="preprocessor">#endif</span>
00396 <span class="preprocessor"></span>
00397 
00398 <span class="keywordtype">int</span> inflate_trees_fixed(bl, bd, tl, td, z)
00399 uIntf *bl;               <span class="comment">/* literal desired/actual bit depth */</span>
00400 uIntf *bd;               <span class="comment">/* distance desired/actual bit depth */</span>
00401 inflate_huft * FAR *tl;  <span class="comment">/* literal/length tree result */</span>
00402 inflate_huft * FAR *td;  <span class="comment">/* distance tree result */</span>
00403 z_streamp z;             <span class="comment">/* for memory allocation */</span>
00404 {
00405 <span class="preprocessor">#ifdef BUILDFIXED</span>
00406 <span class="preprocessor"></span>  <span class="comment">/* build fixed tables if not already */</span>
00407   <span class="keywordflow">if</span> (!fixed_built)
00408   {
00409     <span class="keywordtype">int</span> k;              <span class="comment">/* temporary variable */</span>
00410     uInt f = 0;         <span class="comment">/* number of hufts used in fixed_mem */</span>
00411     uIntf *c;           <span class="comment">/* length list for huft_build */</span>
00412     uIntf *v;           <span class="comment">/* work area for huft_build */</span>
00413 
00414     <span class="comment">/* allocate memory */</span>
00415     <span class="keywordflow">if</span> ((c = (uIntf*)ZALLOC(z, 288, <span class="keyword">sizeof</span>(uInt))) == Z_NULL)
00416       <span class="keywordflow">return</span> Z_MEM_ERROR;
00417     <span class="keywordflow">if</span> ((v = (uIntf*)ZALLOC(z, 288, <span class="keyword">sizeof</span>(uInt))) == Z_NULL)
00418     {
00419       ZFREE(z, c);
00420       <span class="keywordflow">return</span> Z_MEM_ERROR;
00421     }
00422 
00423     <span class="comment">/* literal table */</span>
00424     <span class="keywordflow">for</span> (k = 0; k &lt; 144; k++)
00425       c[k] = 8;
00426     <span class="keywordflow">for</span> (; k &lt; 256; k++)
00427       c[k] = 9;
00428     <span class="keywordflow">for</span> (; k &lt; 280; k++)
00429       c[k] = 7;
00430     <span class="keywordflow">for</span> (; k &lt; 288; k++)
00431       c[k] = 8;
00432     fixed_bl = 9;
00433     huft_build(c, 288, 257, cplens, cplext, &amp;fixed_tl, &amp;fixed_bl,
00434                fixed_mem, &amp;f, v);
00435 
00436     <span class="comment">/* distance table */</span>
00437     <span class="keywordflow">for</span> (k = 0; k &lt; 30; k++)
00438       c[k] = 5;
00439     fixed_bd = 5;
00440     huft_build(c, 30, 0, cpdist, cpdext, &amp;fixed_td, &amp;fixed_bd,
00441                fixed_mem, &amp;f, v);
00442 
00443     <span class="comment">/* done */</span>
00444     ZFREE(z, v);
00445     ZFREE(z, c);
00446     fixed_built = 1;
00447   }
00448 <span class="preprocessor">#endif</span>
00449 <span class="preprocessor"></span>  *bl = fixed_bl;
00450   *bd = fixed_bd;
00451   *tl = fixed_tl;
00452   *td = fixed_td;
00453   <span class="keywordflow">return</span> Z_OK;
00454 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:42 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>gzio.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>gzio.c</h1><div class="fragment"><pre>00001 <span class="comment">/* gzio.c -- IO on .gz files</span>
00002 <span class="comment"> * Copyright (C) 1995-2002 Jean-loup Gailly.</span>
00003 <span class="comment"> * For conditions of distribution and use, see copyright notice in zlib.h</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * Compile this file with -DNO_DEFLATE to avoid the compression code.</span>
00006 <span class="comment"> */</span>
00007 
00008 <span class="comment">/* @(#) $Id: gzio_8c-source.html,v 1.1 2002/11/14 01:50:02 garyjharris Exp $ */</span>
00009 
00010 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00011 
00012 <span class="preprocessor">#include "zutil.h"</span>
00013 
00014 <span class="keyword">struct </span>internal_state {<span class="keywordtype">int</span> dummy;}; <span class="comment">/* for buggy compilers */</span>
00015 
00016 <span class="preprocessor">#ifndef Z_BUFSIZE</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#  ifdef MAXSEG_64K</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#    define Z_BUFSIZE 4096 </span><span class="comment">/* minimize memory usage for 16-bit DOS */</span>
00019 <span class="preprocessor">#  else</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#    define Z_BUFSIZE 16384</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#ifndef Z_PRINTF_BUFSIZE</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#  define Z_PRINTF_BUFSIZE 4096</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00026 <span class="preprocessor"></span>
00027 <span class="preprocessor">#define ALLOC(size) malloc(size)</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#define TRYFREE(p) {if (p) free(p);}</span>
00029 <span class="preprocessor"></span>
00030 <span class="keyword">static</span> <span class="keywordtype">int</span> gz_magic[2] = {0x1f, 0x8b}; <span class="comment">/* gzip magic header */</span>
00031 
00032 <span class="comment">/* gzip flag byte */</span>
00033 <span class="preprocessor">#define ASCII_FLAG   0x01 </span><span class="comment">/* bit 0 set: file probably ascii text */</span>
00034 <span class="preprocessor">#define HEAD_CRC     0x02 </span><span class="comment">/* bit 1 set: header CRC present */</span>
00035 <span class="preprocessor">#define EXTRA_FIELD  0x04 </span><span class="comment">/* bit 2 set: extra field present */</span>
00036 <span class="preprocessor">#define ORIG_NAME    0x08 </span><span class="comment">/* bit 3 set: original file name present */</span>
00037 <span class="preprocessor">#define COMMENT      0x10 </span><span class="comment">/* bit 4 set: file comment present */</span>
00038 <span class="preprocessor">#define RESERVED     0xE0 </span><span class="comment">/* bits 5..7: reserved */</span>
00039 
00040 <span class="keyword">typedef</span> <span class="keyword">struct </span>gz_stream {
00041     z_stream stream;
00042     <span class="keywordtype">int</span>      z_err;   <span class="comment">/* error code for last stream operation */</span>
00043     <span class="keywordtype">int</span>      z_eof;   <span class="comment">/* set if end of input file */</span>
00044     FILE     *file;   <span class="comment">/* .gz file */</span>
00045     Byte     *inbuf;  <span class="comment">/* input buffer */</span>
00046     Byte     *outbuf; <span class="comment">/* output buffer */</span>
00047     uLong    crc;     <span class="comment">/* crc32 of uncompressed data */</span>
00048     <span class="keywordtype">char</span>     *msg;    <span class="comment">/* error message */</span>
00049     <span class="keywordtype">char</span>     *path;   <span class="comment">/* path name for debugging only */</span>
00050     <span class="keywordtype">int</span>      transparent; <span class="comment">/* 1 if input file is not a .gz file */</span>
00051     <span class="keywordtype">char</span>     mode;    <span class="comment">/* 'w' or 'r' */</span>
00052     <span class="keywordtype">long</span>     startpos; <span class="comment">/* start of compressed data in file (header skipped) */</span>
00053 } gz_stream;
00054 
00055 
00056 local gzFile gz_open      OF((<span class="keyword">const</span> <span class="keywordtype">char</span> *path, <span class="keyword">const</span> <span class="keywordtype">char</span> *mode, <span class="keywordtype">int</span>  fd));
00057 local <span class="keywordtype">int</span> do_flush        OF((gzFile file, <span class="keywordtype">int</span> flush));
00058 local <span class="keywordtype">int</span>    get_byte     OF((gz_stream *s));
00059 local <span class="keywordtype">void</span>   check_header OF((gz_stream *s));
00060 local <span class="keywordtype">int</span>    destroy      OF((gz_stream *s));
00061 local <span class="keywordtype">void</span>   putLong      OF((FILE *file, uLong x));
00062 local uLong  getLong      OF((gz_stream *s));
00063 
00064 <span class="comment">/* ===========================================================================</span>
00065 <span class="comment">     Opens a gzip (.gz) file for reading or writing. The mode parameter</span>
00066 <span class="comment">   is as in fopen ("rb" or "wb"). The file is given either by file descriptor</span>
00067 <span class="comment">   or path name (if fd == -1).</span>
00068 <span class="comment">     gz_open return NULL if the file could not be opened or if there was</span>
00069 <span class="comment">   insufficient memory to allocate the (de)compression state; errno</span>
00070 <span class="comment">   can be checked to distinguish the two cases (if errno is zero, the</span>
00071 <span class="comment">   zlib error is Z_MEM_ERROR).</span>
00072 <span class="comment">*/</span>
00073 local gzFile gz_open (path, mode, fd)
00074     <span class="keyword">const</span> <span class="keywordtype">char</span> *path;
00075     <span class="keyword">const</span> <span class="keywordtype">char</span> *mode;
00076     <span class="keywordtype">int</span>  fd;
00077 {
00078     <span class="keywordtype">int</span> err;
00079     <span class="keywordtype">int</span> level = Z_DEFAULT_COMPRESSION; <span class="comment">/* compression level */</span>
00080     <span class="keywordtype">int</span> strategy = Z_DEFAULT_STRATEGY; <span class="comment">/* compression strategy */</span>
00081     <span class="keywordtype">char</span> *p = (<span class="keywordtype">char</span>*)mode;
00082     gz_stream *s;
00083     <span class="keywordtype">char</span> fmode[80]; <span class="comment">/* copy of mode, without the compression level */</span>
00084     <span class="keywordtype">char</span> *m = fmode;
00085 
00086     <span class="keywordflow">if</span> (!path || !mode) <span class="keywordflow">return</span> Z_NULL;
00087 
00088     s = (gz_stream *)ALLOC(<span class="keyword">sizeof</span>(gz_stream));
00089     <span class="keywordflow">if</span> (!s) <span class="keywordflow">return</span> Z_NULL;
00090 
00091     s-&gt;stream.zalloc = (alloc_func)0;
00092     s-&gt;stream.zfree = (free_func)0;
00093     s-&gt;stream.opaque = (voidpf)0;
00094     s-&gt;stream.next_in = s-&gt;inbuf = Z_NULL;
00095     s-&gt;stream.next_out = s-&gt;outbuf = Z_NULL;
00096     s-&gt;stream.avail_in = s-&gt;stream.avail_out = 0;
00097     s-&gt;file = NULL;
00098     s-&gt;z_err = Z_OK;
00099     s-&gt;z_eof = 0;
00100     s-&gt;crc = crc32(0L, Z_NULL, 0);
00101     s-&gt;msg = NULL;
00102     s-&gt;transparent = 0;
00103 
00104     s-&gt;path = (<span class="keywordtype">char</span>*)ALLOC(strlen(path)+1);
00105     <span class="keywordflow">if</span> (s-&gt;path == NULL) {
00106         <span class="keywordflow">return</span> destroy(s), (gzFile)Z_NULL;
00107     }
00108     strcpy(s-&gt;path, path); <span class="comment">/* do this early for debugging */</span>
00109 
00110     s-&gt;mode = <span class="charliteral">'\0'</span>;
00111     <span class="keywordflow">do</span> {
00112         <span class="keywordflow">if</span> (*p == <span class="charliteral">'r'</span>) s-&gt;mode = <span class="charliteral">'r'</span>;
00113         <span class="keywordflow">if</span> (*p == <span class="charliteral">'w'</span> || *p == <span class="charliteral">'a'</span>) s-&gt;mode = <span class="charliteral">'w'</span>;
00114         <span class="keywordflow">if</span> (*p &gt;= <span class="charliteral">'0'</span> &amp;&amp; *p &lt;= <span class="charliteral">'9'</span>) {
00115         level = *p - <span class="charliteral">'0'</span>;
00116     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*p == <span class="charliteral">'f'</span>) {
00117       strategy = Z_FILTERED;
00118     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*p == <span class="charliteral">'h'</span>) {
00119       strategy = Z_HUFFMAN_ONLY;
00120     } <span class="keywordflow">else</span> {
00121         *m++ = *p; <span class="comment">/* copy the mode */</span>
00122     }
00123     } <span class="keywordflow">while</span> (*p++ &amp;&amp; m != fmode + <span class="keyword">sizeof</span>(fmode));
00124     <span class="keywordflow">if</span> (s-&gt;mode == <span class="charliteral">'\0'</span>) <span class="keywordflow">return</span> destroy(s), (gzFile)Z_NULL;
00125     
00126     <span class="keywordflow">if</span> (s-&gt;mode == <span class="charliteral">'w'</span>) {
00127 <span class="preprocessor">#ifdef NO_DEFLATE</span>
00128 <span class="preprocessor"></span>        err = Z_STREAM_ERROR;
00129 <span class="preprocessor">#else</span>
00130 <span class="preprocessor"></span>        err = deflateInit2(&amp;(s-&gt;stream), level,
00131                            Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
00132         <span class="comment">/* windowBits is passed &lt; 0 to suppress zlib header */</span>
00133 
00134         s-&gt;stream.next_out = s-&gt;outbuf = (Byte*)ALLOC(Z_BUFSIZE);
00135 <span class="preprocessor">#endif</span>
00136 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (err != Z_OK || s-&gt;outbuf == Z_NULL) {
00137             <span class="keywordflow">return</span> destroy(s), (gzFile)Z_NULL;
00138         }
00139     } <span class="keywordflow">else</span> {
00140         s-&gt;stream.next_in  = s-&gt;inbuf = (Byte*)ALLOC(Z_BUFSIZE);
00141 
00142         err = inflateInit2(&amp;(s-&gt;stream), -MAX_WBITS);
00143         <span class="comment">/* windowBits is passed &lt; 0 to tell that there is no zlib header.</span>
00144 <span class="comment">         * Note that in this case inflate *requires* an extra "dummy" byte</span>
00145 <span class="comment">         * after the compressed stream in order to complete decompression and</span>
00146 <span class="comment">         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are</span>
00147 <span class="comment">         * present after the compressed stream.</span>
00148 <span class="comment">         */</span>
00149         <span class="keywordflow">if</span> (err != Z_OK || s-&gt;inbuf == Z_NULL) {
00150             <span class="keywordflow">return</span> destroy(s), (gzFile)Z_NULL;
00151         }
00152     }
00153     s-&gt;stream.avail_out = Z_BUFSIZE;
00154 
00155     errno = 0;
00156     s-&gt;file = fd &lt; 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);
00157 
00158     <span class="keywordflow">if</span> (s-&gt;file == NULL) {
00159         <span class="keywordflow">return</span> destroy(s), (gzFile)Z_NULL;
00160     }
00161     <span class="keywordflow">if</span> (s-&gt;mode == <span class="charliteral">'w'</span>) {
00162         <span class="comment">/* Write a very simple .gz header:</span>
00163 <span class="comment">         */</span>
00164         fprintf(s-&gt;file, <span class="stringliteral">"%c%c%c%c%c%c%c%c%c%c"</span>, gz_magic[0], gz_magic[1],
00165              Z_DEFLATED, 0 <span class="comment">/*flags*/</span>, 0,0,0,0 <span class="comment">/*time*/</span>, 0 <span class="comment">/*xflags*/</span>, OS_CODE);
00166     s-&gt;startpos = 10L;
00167     <span class="comment">/* We use 10L instead of ftell(s-&gt;file) to because ftell causes an</span>
00168 <span class="comment">         * fflush on some systems. This version of the library doesn't use</span>
00169 <span class="comment">         * startpos anyway in write mode, so this initialization is not</span>
00170 <span class="comment">         * necessary.</span>
00171 <span class="comment">         */</span>
00172     } <span class="keywordflow">else</span> {
00173     check_header(s); <span class="comment">/* skip the .gz header */</span>
00174     s-&gt;startpos = (ftell(s-&gt;file) - s-&gt;stream.avail_in);
00175     }
00176     
00177     <span class="keywordflow">return</span> (gzFile)s;
00178 }
00179 
00180 <span class="comment">/* ===========================================================================</span>
00181 <span class="comment">     Opens a gzip (.gz) file for reading or writing.</span>
00182 <span class="comment">*/</span>
00183 gzFile ZEXPORT gzopen (path, mode)
00184     <span class="keyword">const</span> <span class="keywordtype">char</span> *path;
00185     <span class="keyword">const</span> <span class="keywordtype">char</span> *mode;
00186 {
00187     <span class="keywordflow">return</span> gz_open (path, mode, -1);
00188 }
00189 
00190 <span class="comment">/* ===========================================================================</span>
00191 <span class="comment">     Associate a gzFile with the file descriptor fd. fd is not dup'ed here</span>
00192 <span class="comment">   to mimic the behavio(u)r of fdopen.</span>
00193 <span class="comment">*/</span>
00194 gzFile ZEXPORT gzdopen (fd, mode)
00195     <span class="keywordtype">int</span> fd;
00196     <span class="keyword">const</span> <span class="keywordtype">char</span> *mode;
00197 {
00198     <span class="keywordtype">char</span> name[20];
00199 
00200     <span class="keywordflow">if</span> (fd &lt; 0) <span class="keywordflow">return</span> (gzFile)Z_NULL;
00201     sprintf(name, <span class="stringliteral">"&lt;fd:%d&gt;"</span>, fd); <span class="comment">/* for debugging */</span>
00202 
00203     <span class="keywordflow">return</span> gz_open (name, mode, fd);
00204 }
00205 
00206 <span class="comment">/* ===========================================================================</span>
00207 <span class="comment"> * Update the compression level and strategy</span>
00208 <span class="comment"> */</span>
00209 <span class="keywordtype">int</span> ZEXPORT gzsetparams (file, level, strategy)
00210     gzFile file;
00211     <span class="keywordtype">int</span> level;
00212     <span class="keywordtype">int</span> strategy;
00213 {
00214     gz_stream *s = (gz_stream*)file;
00215 
00216     <span class="keywordflow">if</span> (s == NULL || s-&gt;mode != <span class="charliteral">'w'</span>) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00217 
00218     <span class="comment">/* Make room to allow flushing */</span>
00219     <span class="keywordflow">if</span> (s-&gt;stream.avail_out == 0) {
00220 
00221     s-&gt;stream.next_out = s-&gt;outbuf;
00222     <span class="keywordflow">if</span> (fwrite(s-&gt;outbuf, 1, Z_BUFSIZE, s-&gt;file) != Z_BUFSIZE) {
00223         s-&gt;z_err = Z_ERRNO;
00224     }
00225     s-&gt;stream.avail_out = Z_BUFSIZE;
00226     }
00227 
00228     <span class="keywordflow">return</span> deflateParams (&amp;(s-&gt;stream), level, strategy);
00229 }
00230 
00231 <span class="comment">/* ===========================================================================</span>
00232 <span class="comment">     Read a byte from a gz_stream; update next_in and avail_in. Return EOF</span>
00233 <span class="comment">   for end of file.</span>
00234 <span class="comment">   IN assertion: the stream s has been sucessfully opened for reading.</span>
00235 <span class="comment">*/</span>
00236 local <span class="keywordtype">int</span> get_byte(s)
00237     gz_stream *s;
00238 {
00239     <span class="keywordflow">if</span> (s-&gt;z_eof) <span class="keywordflow">return</span> EOF;
00240     <span class="keywordflow">if</span> (s-&gt;stream.avail_in == 0) {
00241     errno = 0;
00242     s-&gt;stream.avail_in = fread(s-&gt;inbuf, 1, Z_BUFSIZE, s-&gt;file);
00243     <span class="keywordflow">if</span> (s-&gt;stream.avail_in == 0) {
00244         s-&gt;z_eof = 1;
00245         <span class="keywordflow">if</span> (ferror(s-&gt;file)) s-&gt;z_err = Z_ERRNO;
00246         <span class="keywordflow">return</span> EOF;
00247     }
00248     s-&gt;stream.next_in = s-&gt;inbuf;
00249     }
00250     s-&gt;stream.avail_in--;
00251     <span class="keywordflow">return</span> *(s-&gt;stream.next_in)++;
00252 }
00253 
00254 <span class="comment">/* ===========================================================================</span>
00255 <span class="comment">      Check the gzip header of a gz_stream opened for reading. Set the stream</span>
00256 <span class="comment">    mode to transparent if the gzip magic header is not present; set s-&gt;err</span>
00257 <span class="comment">    to Z_DATA_ERROR if the magic header is present but the rest of the header</span>
00258 <span class="comment">    is incorrect.</span>
00259 <span class="comment">    IN assertion: the stream s has already been created sucessfully;</span>
00260 <span class="comment">       s-&gt;stream.avail_in is zero for the first time, but may be non-zero</span>
00261 <span class="comment">       for concatenated .gz files.</span>
00262 <span class="comment">*/</span>
00263 local <span class="keywordtype">void</span> check_header(s)
00264     gz_stream *s;
00265 {
00266     <span class="keywordtype">int</span> method; <span class="comment">/* method byte */</span>
00267     <span class="keywordtype">int</span> flags;  <span class="comment">/* flags byte */</span>
00268     uInt len;
00269     <span class="keywordtype">int</span> c;
00270 
00271     <span class="comment">/* Check the gzip magic header */</span>
00272     <span class="keywordflow">for</span> (len = 0; len &lt; 2; len++) {
00273     c = get_byte(s);
00274     <span class="keywordflow">if</span> (c != gz_magic[len]) {
00275         <span class="keywordflow">if</span> (len != 0) s-&gt;stream.avail_in++, s-&gt;stream.next_in--;
00276         <span class="keywordflow">if</span> (c != EOF) {
00277         s-&gt;stream.avail_in++, s-&gt;stream.next_in--;
00278         s-&gt;transparent = 1;
00279         }
00280         s-&gt;z_err = s-&gt;stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
00281         <span class="keywordflow">return</span>;
00282     }
00283     }
00284     method = get_byte(s);
00285     flags = get_byte(s);
00286     <span class="keywordflow">if</span> (method != Z_DEFLATED || (flags &amp; RESERVED) != 0) {
00287     s-&gt;z_err = Z_DATA_ERROR;
00288     <span class="keywordflow">return</span>;
00289     }
00290 
00291     <span class="comment">/* Discard time, xflags and OS code: */</span>
00292     <span class="keywordflow">for</span> (len = 0; len &lt; 6; len++) (void)get_byte(s);
00293 
00294     <span class="keywordflow">if</span> ((flags &amp; EXTRA_FIELD) != 0) { <span class="comment">/* skip the extra field */</span>
00295     len  =  (uInt)get_byte(s);
00296     len += ((uInt)get_byte(s))&lt;&lt;8;
00297     <span class="comment">/* len is garbage if EOF but the loop below will quit anyway */</span>
00298     <span class="keywordflow">while</span> (len-- != 0 &amp;&amp; get_byte(s) != EOF) ;
00299     }
00300     <span class="keywordflow">if</span> ((flags &amp; ORIG_NAME) != 0) { <span class="comment">/* skip the original file name */</span>
00301     <span class="keywordflow">while</span> ((c = get_byte(s)) != 0 &amp;&amp; c != EOF) ;
00302     }
00303     <span class="keywordflow">if</span> ((flags &amp; COMMENT) != 0) {   <span class="comment">/* skip the .gz file comment */</span>
00304     <span class="keywordflow">while</span> ((c = get_byte(s)) != 0 &amp;&amp; c != EOF) ;
00305     }
00306     <span class="keywordflow">if</span> ((flags &amp; HEAD_CRC) != 0) {  <span class="comment">/* skip the header crc */</span>
00307     <span class="keywordflow">for</span> (len = 0; len &lt; 2; len++) (void)get_byte(s);
00308     }
00309     s-&gt;z_err = s-&gt;z_eof ? Z_DATA_ERROR : Z_OK;
00310 }
00311 
00312  <span class="comment">/* ===========================================================================</span>
00313 <span class="comment"> * Cleanup then free the given gz_stream. Return a zlib error code.</span>
00314 <span class="comment">   Try freeing in the reverse order of allocations.</span>
00315 <span class="comment"> */</span>
00316 local <span class="keywordtype">int</span> destroy (s)
00317     gz_stream *s;
00318 {
00319     <span class="keywordtype">int</span> err = Z_OK;
00320 
00321     <span class="keywordflow">if</span> (!s) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00322 
00323     TRYFREE(s-&gt;msg);
00324 
00325     <span class="keywordflow">if</span> (s-&gt;stream.state != NULL) {
00326     <span class="keywordflow">if</span> (s-&gt;mode == <span class="charliteral">'w'</span>) {
00327 <span class="preprocessor">#ifdef NO_DEFLATE</span>
00328 <span class="preprocessor"></span>        err = Z_STREAM_ERROR;
00329 <span class="preprocessor">#else</span>
00330 <span class="preprocessor"></span>        err = deflateEnd(&amp;(s-&gt;stream));
00331 <span class="preprocessor">#endif</span>
00332 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s-&gt;mode == <span class="charliteral">'r'</span>) {
00333         err = inflateEnd(&amp;(s-&gt;stream));
00334     }
00335     }
00336     <span class="keywordflow">if</span> (s-&gt;file != NULL &amp;&amp; fclose(s-&gt;file)) {
00337 <span class="preprocessor">#ifdef ESPIPE</span>
00338 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (errno != ESPIPE) <span class="comment">/* fclose is broken for pipes in HP/UX */</span>
00339 <span class="preprocessor">#endif</span>
00340 <span class="preprocessor"></span>        err = Z_ERRNO;
00341     }
00342     <span class="keywordflow">if</span> (s-&gt;z_err &lt; 0) err = s-&gt;z_err;
00343 
00344     TRYFREE(s-&gt;inbuf);
00345     TRYFREE(s-&gt;outbuf);
00346     TRYFREE(s-&gt;path);
00347     TRYFREE(s);
00348     <span class="keywordflow">return</span> err;
00349 }
00350 
00351 <span class="comment">/* ===========================================================================</span>
00352 <span class="comment">     Reads the given number of uncompressed bytes from the compressed file.</span>
00353 <span class="comment">   gzread returns the number of bytes actually read (0 for end of file).</span>
00354 <span class="comment">*/</span>
00355 <span class="keywordtype">int</span> ZEXPORT gzread (file, buf, len)
00356     gzFile file;
00357     voidp buf;
00358     <span class="keywordtype">unsigned</span> len;
00359 {
00360     gz_stream *s = (gz_stream*)file;
00361     Bytef *start = (Bytef*)buf; <span class="comment">/* starting point for crc computation */</span>
00362     Byte  *next_out; <span class="comment">/* == stream.next_out but not forced far (for MSDOS) */</span>
00363 
00364     <span class="keywordflow">if</span> (s == NULL || s-&gt;mode != <span class="charliteral">'r'</span>) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00365 
00366     <span class="keywordflow">if</span> (s-&gt;z_err == Z_DATA_ERROR || s-&gt;z_err == Z_ERRNO) <span class="keywordflow">return</span> -1;
00367     <span class="keywordflow">if</span> (s-&gt;z_err == Z_STREAM_END) <span class="keywordflow">return</span> 0;  <span class="comment">/* EOF */</span>
00368 
00369     next_out = (Byte*)buf;
00370     s-&gt;stream.next_out = (Bytef*)buf;
00371     s-&gt;stream.avail_out = len;
00372 
00373     <span class="keywordflow">while</span> (s-&gt;stream.avail_out != 0) {
00374 
00375     <span class="keywordflow">if</span> (s-&gt;transparent) {
00376         <span class="comment">/* Copy first the lookahead bytes: */</span>
00377         uInt n = s-&gt;stream.avail_in;
00378         <span class="keywordflow">if</span> (n &gt; s-&gt;stream.avail_out) n = s-&gt;stream.avail_out;
00379         <span class="keywordflow">if</span> (n &gt; 0) {
00380         zmemcpy(s-&gt;stream.next_out, s-&gt;stream.next_in, n);
00381         next_out += n;
00382         s-&gt;stream.next_out = next_out;
00383         s-&gt;stream.next_in   += n;
00384         s-&gt;stream.avail_out -= n;
00385         s-&gt;stream.avail_in  -= n;
00386         }
00387         <span class="keywordflow">if</span> (s-&gt;stream.avail_out &gt; 0) {
00388         s-&gt;stream.avail_out -= fread(next_out, 1, s-&gt;stream.avail_out,
00389                          s-&gt;file);
00390         }
00391         len -= s-&gt;stream.avail_out;
00392         s-&gt;stream.total_in  += (uLong)len;
00393         s-&gt;stream.total_out += (uLong)len;
00394             <span class="keywordflow">if</span> (len == 0) s-&gt;z_eof = 1;
00395         <span class="keywordflow">return</span> (int)len;
00396     }
00397         <span class="keywordflow">if</span> (s-&gt;stream.avail_in == 0 &amp;&amp; !s-&gt;z_eof) {
00398 
00399             errno = 0;
00400             s-&gt;stream.avail_in = fread(s-&gt;inbuf, 1, Z_BUFSIZE, s-&gt;file);
00401             <span class="keywordflow">if</span> (s-&gt;stream.avail_in == 0) {
00402                 s-&gt;z_eof = 1;
00403         <span class="keywordflow">if</span> (ferror(s-&gt;file)) {
00404             s-&gt;z_err = Z_ERRNO;
00405             <span class="keywordflow">break</span>;
00406         }
00407             }
00408             s-&gt;stream.next_in = s-&gt;inbuf;
00409         }
00410         s-&gt;z_err = inflate(&amp;(s-&gt;stream), Z_NO_FLUSH);
00411 
00412     <span class="keywordflow">if</span> (s-&gt;z_err == Z_STREAM_END) {
00413         <span class="comment">/* Check CRC and original size */</span>
00414         s-&gt;crc = crc32(s-&gt;crc, start, (uInt)(s-&gt;stream.next_out - start));
00415         start = s-&gt;stream.next_out;
00416 
00417         <span class="keywordflow">if</span> (getLong(s) != s-&gt;crc) {
00418         s-&gt;z_err = Z_DATA_ERROR;
00419         } <span class="keywordflow">else</span> {
00420             (void)getLong(s);
00421                 <span class="comment">/* The uncompressed length returned by above getlong() may</span>
00422 <span class="comment">                 * be different from s-&gt;stream.total_out) in case of</span>
00423 <span class="comment">         * concatenated .gz files. Check for such files:</span>
00424 <span class="comment">         */</span>
00425         check_header(s);
00426         <span class="keywordflow">if</span> (s-&gt;z_err == Z_OK) {
00427             uLong total_in = s-&gt;stream.total_in;
00428             uLong total_out = s-&gt;stream.total_out;
00429 
00430             inflateReset(&amp;(s-&gt;stream));
00431             s-&gt;stream.total_in = total_in;
00432             s-&gt;stream.total_out = total_out;
00433             s-&gt;crc = crc32(0L, Z_NULL, 0);
00434         }
00435         }
00436     }
00437     <span class="keywordflow">if</span> (s-&gt;z_err != Z_OK || s-&gt;z_eof) <span class="keywordflow">break</span>;
00438     }
00439     s-&gt;crc = crc32(s-&gt;crc, start, (uInt)(s-&gt;stream.next_out - start));
00440 
00441     <span class="keywordflow">return</span> (int)(len - s-&gt;stream.avail_out);
00442 }
00443 
00444 
00445 <span class="comment">/* ===========================================================================</span>
00446 <span class="comment">      Reads one byte from the compressed file. gzgetc returns this byte</span>
00447 <span class="comment">   or -1 in case of end of file or error.</span>
00448 <span class="comment">*/</span>
00449 <span class="keywordtype">int</span> ZEXPORT gzgetc(file)
00450     gzFile file;
00451 {
00452     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c;
00453 
00454     <span class="keywordflow">return</span> gzread(file, &amp;c, 1) == 1 ? c : -1;
00455 }
00456 
00457 
00458 <span class="comment">/* ===========================================================================</span>
00459 <span class="comment">      Reads bytes from the compressed file until len-1 characters are</span>
00460 <span class="comment">   read, or a newline character is read and transferred to buf, or an</span>
00461 <span class="comment">   end-of-file condition is encountered.  The string is then terminated</span>
00462 <span class="comment">   with a null character.</span>
00463 <span class="comment">      gzgets returns buf, or Z_NULL in case of error.</span>
00464 <span class="comment"></span>
00465 <span class="comment">      The current implementation is not optimized at all.</span>
00466 <span class="comment">*/</span>
00467 <span class="keywordtype">char</span> * ZEXPORT gzgets(file, buf, len)
00468     gzFile file;
00469     <span class="keywordtype">char</span> *buf;
00470     <span class="keywordtype">int</span> len;
00471 {
00472     <span class="keywordtype">char</span> *b = buf;
00473     <span class="keywordflow">if</span> (buf == Z_NULL || len &lt;= 0) <span class="keywordflow">return</span> Z_NULL;
00474 
00475     <span class="keywordflow">while</span> (--len &gt; 0 &amp;&amp; gzread(file, buf, 1) == 1 &amp;&amp; *buf++ != <span class="charliteral">'\n'</span>) ;
00476     *buf = <span class="charliteral">'\0'</span>;
00477     <span class="keywordflow">return</span> b == buf &amp;&amp; len &gt; 0 ? Z_NULL : b;
00478 }
00479 
00480 
00481 <span class="preprocessor">#ifndef NO_DEFLATE</span>
00482 <span class="preprocessor"></span><span class="comment">/* ===========================================================================</span>
00483 <span class="comment">     Writes the given number of uncompressed bytes into the compressed file.</span>
00484 <span class="comment">   gzwrite returns the number of bytes actually written (0 in case of error).</span>
00485 <span class="comment">*/</span>
00486 <span class="keywordtype">int</span> ZEXPORT gzwrite (file, buf, len)
00487     gzFile file;
00488     <span class="keyword">const</span> voidp buf;
00489     <span class="keywordtype">unsigned</span> len;
00490 {
00491     gz_stream *s = (gz_stream*)file;
00492 
00493     <span class="keywordflow">if</span> (s == NULL || s-&gt;mode != <span class="charliteral">'w'</span>) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00494 
00495     s-&gt;stream.next_in = (Bytef*)buf;
00496     s-&gt;stream.avail_in = len;
00497 
00498     <span class="keywordflow">while</span> (s-&gt;stream.avail_in != 0) {
00499 
00500         <span class="keywordflow">if</span> (s-&gt;stream.avail_out == 0) {
00501 
00502             s-&gt;stream.next_out = s-&gt;outbuf;
00503             <span class="keywordflow">if</span> (fwrite(s-&gt;outbuf, 1, Z_BUFSIZE, s-&gt;file) != Z_BUFSIZE) {
00504                 s-&gt;z_err = Z_ERRNO;
00505                 <span class="keywordflow">break</span>;
00506             }
00507             s-&gt;stream.avail_out = Z_BUFSIZE;
00508         }
00509         s-&gt;z_err = deflate(&amp;(s-&gt;stream), Z_NO_FLUSH);
00510         <span class="keywordflow">if</span> (s-&gt;z_err != Z_OK) <span class="keywordflow">break</span>;
00511     }
00512     s-&gt;crc = crc32(s-&gt;crc, (<span class="keyword">const</span> Bytef *)buf, len);
00513 
00514     <span class="keywordflow">return</span> (int)(len - s-&gt;stream.avail_in);
00515 }
00516 
00517 <span class="comment">/* ===========================================================================</span>
00518 <span class="comment">     Converts, formats, and writes the args to the compressed file under</span>
00519 <span class="comment">   control of the format string, as in fprintf. gzprintf returns the number of</span>
00520 <span class="comment">   uncompressed bytes actually written (0 in case of error).</span>
00521 <span class="comment">*/</span>
00522 <span class="preprocessor">#ifdef STDC</span>
00523 <span class="preprocessor"></span><span class="preprocessor">#include &lt;stdarg.h&gt;</span>
00524 
00525 <span class="keywordtype">int</span> ZEXPORTVA gzprintf (gzFile file, <span class="keyword">const</span> <span class="keywordtype">char</span> *format, <span class="comment">/* args */</span> ...)
00526 {
00527     <span class="keywordtype">char</span> buf[Z_PRINTF_BUFSIZE];
00528     va_list va;
00529     <span class="keywordtype">int</span> len;
00530 
00531     va_start(va, format);
00532 <span class="preprocessor">#ifdef HAS_vsnprintf</span>
00533 <span class="preprocessor"></span>    (void)vsnprintf(buf, <span class="keyword">sizeof</span>(buf), format, va);
00534 <span class="preprocessor">#else</span>
00535 <span class="preprocessor"></span>    (void)vsprintf(buf, format, va);
00536 <span class="preprocessor">#endif</span>
00537 <span class="preprocessor"></span>    va_end(va);
00538     len = strlen(buf); <span class="comment">/* some *sprintf don't return the nb of bytes written */</span>
00539     <span class="keywordflow">if</span> (len &lt;= 0) <span class="keywordflow">return</span> 0;
00540 
00541     <span class="keywordflow">return</span> gzwrite(file, buf, (<span class="keywordtype">unsigned</span>)len);
00542 }
00543 <span class="preprocessor">#else </span><span class="comment">/* not ANSI C */</span>
00544 
00545 <span class="keywordtype">int</span> ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
00546                    a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
00547     gzFile file;
00548     <span class="keyword">const</span> <span class="keywordtype">char</span> *format;
00549     <span class="keywordtype">int</span> a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
00550     a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
00551 {
00552     <span class="keywordtype">char</span> buf[Z_PRINTF_BUFSIZE];
00553     <span class="keywordtype">int</span> len;
00554 
00555 <span class="preprocessor">#ifdef HAS_snprintf</span>
00556 <span class="preprocessor"></span>    snprintf(buf, <span class="keyword">sizeof</span>(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
00557          a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
00558 <span class="preprocessor">#else</span>
00559 <span class="preprocessor"></span>    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
00560         a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
00561 <span class="preprocessor">#endif</span>
00562 <span class="preprocessor"></span>    len = strlen(buf); <span class="comment">/* old sprintf doesn't return the nb of bytes written */</span>
00563     <span class="keywordflow">if</span> (len &lt;= 0) <span class="keywordflow">return</span> 0;
00564 
00565     <span class="keywordflow">return</span> gzwrite(file, buf, len);
00566 }
00567 <span class="preprocessor">#endif</span>
00568 <span class="preprocessor"></span>
00569 <span class="comment">/* ===========================================================================</span>
00570 <span class="comment">      Writes c, converted to an unsigned char, into the compressed file.</span>
00571 <span class="comment">   gzputc returns the value that was written, or -1 in case of error.</span>
00572 <span class="comment">*/</span>
00573 <span class="keywordtype">int</span> ZEXPORT gzputc(file, c)
00574     gzFile file;
00575     <span class="keywordtype">int</span> c;
00576 {
00577     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cc = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>) c; <span class="comment">/* required for big endian systems */</span>
00578 
00579     <span class="keywordflow">return</span> gzwrite(file, &amp;cc, 1) == 1 ? (int)cc : -1;
00580 }
00581 
00582 
00583 <span class="comment">/* ===========================================================================</span>
00584 <span class="comment">      Writes the given null-terminated string to the compressed file, excluding</span>
00585 <span class="comment">   the terminating null character.</span>
00586 <span class="comment">      gzputs returns the number of characters written, or -1 in case of error.</span>
00587 <span class="comment">*/</span>
00588 <span class="keywordtype">int</span> ZEXPORT gzputs(file, s)
00589     gzFile file;
00590     <span class="keyword">const</span> <span class="keywordtype">char</span> *s;
00591 {
00592     <span class="keywordflow">return</span> gzwrite(file, (<span class="keywordtype">char</span>*)s, (<span class="keywordtype">unsigned</span>)strlen(s));
00593 }
00594 
00595 
00596 <span class="comment">/* ===========================================================================</span>
00597 <span class="comment">     Flushes all pending output into the compressed file. The parameter</span>
00598 <span class="comment">   flush is as in the deflate() function.</span>
00599 <span class="comment">*/</span>
00600 local <span class="keywordtype">int</span> do_flush (file, flush)
00601     gzFile file;
00602     <span class="keywordtype">int</span> flush;
00603 {
00604     uInt len;
00605     <span class="keywordtype">int</span> done = 0;
00606     gz_stream *s = (gz_stream*)file;
00607 
00608     <span class="keywordflow">if</span> (s == NULL || s-&gt;mode != <span class="charliteral">'w'</span>) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00609 
00610     s-&gt;stream.avail_in = 0; <span class="comment">/* should be zero already anyway */</span>
00611 
00612     <span class="keywordflow">for</span> (;;) {
00613         len = Z_BUFSIZE - s-&gt;stream.avail_out;
00614 
00615         <span class="keywordflow">if</span> (len != 0) {
00616             <span class="keywordflow">if</span> ((uInt)fwrite(s-&gt;outbuf, 1, len, s-&gt;file) != len) {
00617                 s-&gt;z_err = Z_ERRNO;
00618                 <span class="keywordflow">return</span> Z_ERRNO;
00619             }
00620             s-&gt;stream.next_out = s-&gt;outbuf;
00621             s-&gt;stream.avail_out = Z_BUFSIZE;
00622         }
00623         <span class="keywordflow">if</span> (done) <span class="keywordflow">break</span>;
00624         s-&gt;z_err = deflate(&amp;(s-&gt;stream), flush);
00625 
00626     <span class="comment">/* Ignore the second of two consecutive flushes: */</span>
00627     <span class="keywordflow">if</span> (len == 0 &amp;&amp; s-&gt;z_err == Z_BUF_ERROR) s-&gt;z_err = Z_OK;
00628 
00629         <span class="comment">/* deflate has finished flushing only when it hasn't used up</span>
00630 <span class="comment">         * all the available space in the output buffer: </span>
00631 <span class="comment">         */</span>
00632         done = (s-&gt;stream.avail_out != 0 || s-&gt;z_err == Z_STREAM_END);
00633  
00634         <span class="keywordflow">if</span> (s-&gt;z_err != Z_OK &amp;&amp; s-&gt;z_err != Z_STREAM_END) <span class="keywordflow">break</span>;
00635     }
00636     <span class="keywordflow">return</span>  s-&gt;z_err == Z_STREAM_END ? Z_OK : s-&gt;z_err;
00637 }
00638 
00639 <span class="keywordtype">int</span> ZEXPORT gzflush (file, flush)
00640      gzFile file;
00641      <span class="keywordtype">int</span> flush;
00642 {
00643     gz_stream *s = (gz_stream*)file;
00644     <span class="keywordtype">int</span> err = do_flush (file, flush);
00645 
00646     <span class="keywordflow">if</span> (err) <span class="keywordflow">return</span> err;
00647     fflush(s-&gt;file);
00648     <span class="keywordflow">return</span>  s-&gt;z_err == Z_STREAM_END ? Z_OK : s-&gt;z_err;
00649 }
00650 <span class="preprocessor">#endif </span><span class="comment">/* NO_DEFLATE */</span>
00651 
00652 <span class="comment">/* ===========================================================================</span>
00653 <span class="comment">      Sets the starting position for the next gzread or gzwrite on the given</span>
00654 <span class="comment">   compressed file. The offset represents a number of bytes in the</span>
00655 <span class="comment">      gzseek returns the resulting offset location as measured in bytes from</span>
00656 <span class="comment">   the beginning of the uncompressed stream, or -1 in case of error.</span>
00657 <span class="comment">      SEEK_END is not implemented, returns error.</span>
00658 <span class="comment">      In this version of the library, gzseek can be extremely slow.</span>
00659 <span class="comment">*/</span>
00660 z_off_t ZEXPORT gzseek (file, offset, whence)
00661     gzFile file;
00662     z_off_t offset;
00663     <span class="keywordtype">int</span> whence;
00664 {
00665     gz_stream *s = (gz_stream*)file;
00666 
00667     <span class="keywordflow">if</span> (s == NULL || whence == SEEK_END ||
00668     s-&gt;z_err == Z_ERRNO || s-&gt;z_err == Z_DATA_ERROR) {
00669     <span class="keywordflow">return</span> -1L;
00670     }
00671     
00672     <span class="keywordflow">if</span> (s-&gt;mode == <span class="charliteral">'w'</span>) {
00673 <span class="preprocessor">#ifdef NO_DEFLATE</span>
00674 <span class="preprocessor"></span>    <span class="keywordflow">return</span> -1L;
00675 <span class="preprocessor">#else</span>
00676 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (whence == SEEK_SET) {
00677         offset -= s-&gt;stream.total_in;
00678     }
00679     <span class="keywordflow">if</span> (offset &lt; 0) <span class="keywordflow">return</span> -1L;
00680 
00681     <span class="comment">/* At this point, offset is the number of zero bytes to write. */</span>
00682     <span class="keywordflow">if</span> (s-&gt;inbuf == Z_NULL) {
00683         s-&gt;inbuf = (Byte*)ALLOC(Z_BUFSIZE); <span class="comment">/* for seeking */</span>
00684         zmemzero(s-&gt;inbuf, Z_BUFSIZE);
00685     }
00686     <span class="keywordflow">while</span> (offset &gt; 0)  {
00687         uInt size = Z_BUFSIZE;
00688         <span class="keywordflow">if</span> (offset &lt; Z_BUFSIZE) size = (uInt)offset;
00689 
00690         size = gzwrite(file, s-&gt;inbuf, size);
00691         <span class="keywordflow">if</span> (size == 0) <span class="keywordflow">return</span> -1L;
00692 
00693         offset -= size;
00694     }
00695     <span class="keywordflow">return</span> (z_off_t)s-&gt;stream.total_in;
00696 <span class="preprocessor">#endif</span>
00697 <span class="preprocessor"></span>    }
00698     <span class="comment">/* Rest of function is for reading only */</span>
00699 
00700     <span class="comment">/* compute absolute position */</span>
00701     <span class="keywordflow">if</span> (whence == SEEK_CUR) {
00702     offset += s-&gt;stream.total_out;
00703     }
00704     <span class="keywordflow">if</span> (offset &lt; 0) <span class="keywordflow">return</span> -1L;
00705 
00706     <span class="keywordflow">if</span> (s-&gt;transparent) {
00707     <span class="comment">/* map to fseek */</span>
00708     s-&gt;stream.avail_in = 0;
00709     s-&gt;stream.next_in = s-&gt;inbuf;
00710         <span class="keywordflow">if</span> (fseek(s-&gt;file, offset, SEEK_SET) &lt; 0) <span class="keywordflow">return</span> -1L;
00711 
00712     s-&gt;stream.total_in = s-&gt;stream.total_out = (uLong)offset;
00713     <span class="keywordflow">return</span> offset;
00714     }
00715 
00716     <span class="comment">/* For a negative seek, rewind and use positive seek */</span>
00717     <span class="keywordflow">if</span> ((uLong)offset &gt;= s-&gt;stream.total_out) {
00718     offset -= s-&gt;stream.total_out;
00719     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (gzrewind(file) &lt; 0) {
00720     <span class="keywordflow">return</span> -1L;
00721     }
00722     <span class="comment">/* offset is now the number of bytes to skip. */</span>
00723 
00724     <span class="keywordflow">if</span> (offset != 0 &amp;&amp; s-&gt;outbuf == Z_NULL) {
00725     s-&gt;outbuf = (Byte*)ALLOC(Z_BUFSIZE);
00726     }
00727     <span class="keywordflow">while</span> (offset &gt; 0)  {
00728     <span class="keywordtype">int</span> size = Z_BUFSIZE;
00729     <span class="keywordflow">if</span> (offset &lt; Z_BUFSIZE) size = (int)offset;
00730 
00731     size = gzread(file, s-&gt;outbuf, (uInt)size);
00732     <span class="keywordflow">if</span> (size &lt;= 0) <span class="keywordflow">return</span> -1L;
00733     offset -= size;
00734     }
00735     <span class="keywordflow">return</span> (z_off_t)s-&gt;stream.total_out;
00736 }
00737 
00738 <span class="comment">/* ===========================================================================</span>
00739 <span class="comment">     Rewinds input file. </span>
00740 <span class="comment">*/</span>
00741 <span class="keywordtype">int</span> ZEXPORT gzrewind (file)
00742     gzFile file;
00743 {
00744     gz_stream *s = (gz_stream*)file;
00745     
00746     <span class="keywordflow">if</span> (s == NULL || s-&gt;mode != <span class="charliteral">'r'</span>) <span class="keywordflow">return</span> -1;
00747 
00748     s-&gt;z_err = Z_OK;
00749     s-&gt;z_eof = 0;
00750     s-&gt;stream.avail_in = 0;
00751     s-&gt;stream.next_in = s-&gt;inbuf;
00752     s-&gt;crc = crc32(0L, Z_NULL, 0);
00753     
00754     <span class="keywordflow">if</span> (s-&gt;startpos == 0) { <span class="comment">/* not a compressed file */</span>
00755     rewind(s-&gt;file);
00756     <span class="keywordflow">return</span> 0;
00757     }
00758 
00759     (void) inflateReset(&amp;s-&gt;stream);
00760     <span class="keywordflow">return</span> fseek(s-&gt;file, s-&gt;startpos, SEEK_SET);
00761 }
00762 
00763 <span class="comment">/* ===========================================================================</span>
00764 <span class="comment">     Returns the starting position for the next gzread or gzwrite on the</span>
00765 <span class="comment">   given compressed file. This position represents a number of bytes in the</span>
00766 <span class="comment">   uncompressed data stream.</span>
00767 <span class="comment">*/</span>
00768 z_off_t ZEXPORT gztell (file)
00769     gzFile file;
00770 {
00771     <span class="keywordflow">return</span> gzseek(file, 0L, SEEK_CUR);
00772 }
00773 
00774 <span class="comment">/* ===========================================================================</span>
00775 <span class="comment">     Returns 1 when EOF has previously been detected reading the given</span>
00776 <span class="comment">   input stream, otherwise zero.</span>
00777 <span class="comment">*/</span>
00778 <span class="keywordtype">int</span> ZEXPORT gzeof (file)
00779     gzFile file;
00780 {
00781     gz_stream *s = (gz_stream*)file;
00782     
00783     <span class="keywordflow">return</span> (s == NULL || s-&gt;mode != <span class="charliteral">'r'</span>) ? 0 : s-&gt;z_eof;
00784 }
00785 
00786 <span class="comment">/* ===========================================================================</span>
00787 <span class="comment">   Outputs a long in LSB order to the given file</span>
00788 <span class="comment">*/</span>
00789 local <span class="keywordtype">void</span> putLong (file, x)
00790     FILE *file;
00791     uLong x;
00792 {
00793     <span class="keywordtype">int</span> n;
00794     <span class="keywordflow">for</span> (n = 0; n &lt; 4; n++) {
00795         fputc((<span class="keywordtype">int</span>)(x &amp; 0xff), file);
00796         x &gt;&gt;= 8;
00797     }
00798 }
00799 
00800 <span class="comment">/* ===========================================================================</span>
00801 <span class="comment">   Reads a long in LSB order from the given gz_stream. Sets z_err in case</span>
00802 <span class="comment">   of error.</span>
00803 <span class="comment">*/</span>
00804 local uLong getLong (s)
00805     gz_stream *s;
00806 {
00807     uLong x = (uLong)get_byte(s);
00808     <span class="keywordtype">int</span> c;
00809 
00810     x += ((uLong)get_byte(s))&lt;&lt;8;
00811     x += ((uLong)get_byte(s))&lt;&lt;16;
00812     c = get_byte(s);
00813     <span class="keywordflow">if</span> (c == EOF) s-&gt;z_err = Z_DATA_ERROR;
00814     x += ((uLong)c)&lt;&lt;24;
00815     <span class="keywordflow">return</span> x;
00816 }
00817 
00818 <span class="comment">/* ===========================================================================</span>
00819 <span class="comment">     Flushes all pending output if necessary, closes the compressed file</span>
00820 <span class="comment">   and deallocates all the (de)compression state.</span>
00821 <span class="comment">*/</span>
00822 <span class="keywordtype">int</span> ZEXPORT gzclose (file)
00823     gzFile file;
00824 {
00825     <span class="keywordtype">int</span> err;
00826     gz_stream *s = (gz_stream*)file;
00827 
00828     <span class="keywordflow">if</span> (s == NULL) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00829 
00830     <span class="keywordflow">if</span> (s-&gt;mode == <span class="charliteral">'w'</span>) {
00831 <span class="preprocessor">#ifdef NO_DEFLATE</span>
00832 <span class="preprocessor"></span>    <span class="keywordflow">return</span> Z_STREAM_ERROR;
00833 <span class="preprocessor">#else</span>
00834 <span class="preprocessor"></span>        err = do_flush (file, Z_FINISH);
00835         <span class="keywordflow">if</span> (err != Z_OK) <span class="keywordflow">return</span> destroy((gz_stream*)file);
00836 
00837         putLong (s-&gt;file, s-&gt;crc);
00838         putLong (s-&gt;file, s-&gt;stream.total_in);
00839 <span class="preprocessor">#endif</span>
00840 <span class="preprocessor"></span>    }
00841     <span class="keywordflow">return</span> destroy((gz_stream*)file);
00842 }
00843 
00844 <span class="comment">/* ===========================================================================</span>
00845 <span class="comment">     Returns the error message for the last error which occured on the</span>
00846 <span class="comment">   given compressed file. errnum is set to zlib error number. If an</span>
00847 <span class="comment">   error occured in the file system and not in the compression library,</span>
00848 <span class="comment">   errnum is set to Z_ERRNO and the application may consult errno</span>
00849 <span class="comment">   to get the exact error code.</span>
00850 <span class="comment">*/</span>
00851 <span class="keyword">const</span> <span class="keywordtype">char</span>*  ZEXPORT gzerror (file, errnum)
00852     gzFile file;
00853     <span class="keywordtype">int</span> *errnum;
00854 {
00855     <span class="keywordtype">char</span> *m;
00856     gz_stream *s = (gz_stream*)file;
00857 
00858     <span class="keywordflow">if</span> (s == NULL) {
00859         *errnum = Z_STREAM_ERROR;
00860         <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>*)ERR_MSG(Z_STREAM_ERROR);
00861     }
00862     *errnum = s-&gt;z_err;
00863     <span class="keywordflow">if</span> (*errnum == Z_OK) <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>*)<span class="stringliteral">""</span>;
00864 
00865     m =  (<span class="keywordtype">char</span>*)(*errnum == Z_ERRNO ? zstrerror(errno) : s-&gt;stream.msg);
00866 
00867     <span class="keywordflow">if</span> (m == NULL || *m == <span class="charliteral">'\0'</span>) m = (<span class="keywordtype">char</span>*)ERR_MSG(s-&gt;z_err);
00868 
00869     TRYFREE(s-&gt;msg);
00870     s-&gt;msg = (<span class="keywordtype">char</span>*)ALLOC(strlen(s-&gt;path) + strlen(m) + 3);
00871     strcpy(s-&gt;msg, s-&gt;path);
00872     strcat(s-&gt;msg, <span class="stringliteral">": "</span>);
00873     strcat(s-&gt;msg, m);
00874     <span class="keywordflow">return</span> (<span class="keyword">const</span> <span class="keywordtype">char</span>*)s-&gt;msg;
00875 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:41 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

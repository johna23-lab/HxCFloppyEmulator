<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>adf_file.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>adf_file.c</h1><a href="adf__file_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  ADF Library. (C) 1997-2002 Laurent Clevy</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> */</span>
00010 <span class="preprocessor">#include&lt;stdlib.h&gt;</span>
00011 <span class="preprocessor">#include&lt;string.h&gt;</span>
00012 
00013 <span class="preprocessor">#include"adf_util.h"</span>
00014 <span class="preprocessor">#include"adf_file.h"</span>
00015 <span class="preprocessor">#include"adf_str.h"</span>
00016 <span class="preprocessor">#include"defendian.h"</span>
00017 <span class="preprocessor">#include"adf_raw.h"</span>
00018 <span class="preprocessor">#include"adf_disk.h"</span>
00019 <span class="preprocessor">#include"adf_dir.h"</span>
00020 <span class="preprocessor">#include"adf_bitm.h"</span>
00021 <span class="preprocessor">#include"adf_cache.h"</span>
00022 
00023 <span class="keyword">extern</span> <span class="keyword">struct </span>Env adfEnv;
00024 
00025 <span class="keywordtype">void</span> adfFileTruncate(<span class="keyword">struct</span> Volume *vol, SECTNUM nParent, <span class="keywordtype">char</span> *name)
00026 {
00027 
00028 }
00029 
00030 
00031 <span class="comment">/*</span>
00032 <span class="comment"> * adfFileFlush</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> */</span>
00035 <span class="keywordtype">void</span> adfFlushFile(<span class="keyword">struct</span> File *file)
00036 {
00037     <span class="keyword">struct </span>bEntryBlock parent;
00038     <span class="keyword">struct </span>bOFSDataBlock *data;
00039 
00040     <span class="keywordflow">if</span> (file-&gt;currentExt) {
00041         <span class="keywordflow">if</span> (file-&gt;writeMode)
00042             adfWriteFileExtBlock(file-&gt;volume, file-&gt;currentExt-&gt;headerKey,
00043                 file-&gt;currentExt);
00044     }
00045     <span class="keywordflow">if</span> (file-&gt;currentData) {
00046         <span class="keywordflow">if</span> (file-&gt;writeMode) {
00047             file-&gt;fileHdr-&gt;byteSize = file-&gt;pos;
00048             <span class="keywordflow">if</span> (isOFS(file-&gt;volume-&gt;dosType)) {
00049                 data = (<span class="keyword">struct </span>bOFSDataBlock *)file-&gt;currentData;
00050                 data-&gt;dataSize = file-&gt;posInDataBlk;
00051             }
00052             <span class="keywordflow">if</span> (file-&gt;fileHdr-&gt;byteSize&gt;0)
00053                 adfWriteDataBlock(file-&gt;volume, file-&gt;curDataPtr, 
00054                     file-&gt;currentData);
00055         }
00056     }
00057     <span class="keywordflow">if</span> (file-&gt;writeMode) {
00058         file-&gt;fileHdr-&gt;byteSize = file-&gt;pos;
00059 <span class="comment">/*printf("pos=%ld\n",file-&gt;pos);*/</span>
00060         adfTime2AmigaTime(adfGiveCurrentTime(),
00061             &amp;(file-&gt;fileHdr-&gt;days),&amp;(file-&gt;fileHdr-&gt;mins),&amp;(file-&gt;fileHdr-&gt;ticks) );
00062         adfWriteFileHdrBlock(file-&gt;volume, file-&gt;fileHdr-&gt;headerKey, file-&gt;fileHdr);
00063 
00064         <span class="keywordflow">if</span> (isDIRCACHE(file-&gt;volume-&gt;dosType)) {
00065 <span class="comment">/*printf("parent=%ld\n",file-&gt;fileHdr-&gt;parent);*/</span>
00066             adfReadEntryBlock(file-&gt;volume, file-&gt;fileHdr-&gt;parent, &amp;parent);
00067             adfUpdateCache(file-&gt;volume, &amp;parent, (<span class="keyword">struct</span> bEntryBlock*)file-&gt;fileHdr,FALSE);
00068         }
00069         adfUpdateBitmap(file-&gt;volume);
00070     }
00071 }
00072 
00073 
00074 <span class="comment">/*</span>
00075 <span class="comment"> * adfGetFileBlocks</span>
00076 <span class="comment"> *</span>
00077 <span class="comment"> */</span>
00078 RETCODE adfGetFileBlocks(<span class="keyword">struct</span> Volume* vol, <span class="keyword">struct</span> bFileHeaderBlock* entry,
00079     <span class="keyword">struct</span> FileBlocks* fileBlocks)
00080 {
00081     <span class="keywordtype">long</span> n, m;
00082     SECTNUM nSect;
00083     <span class="keyword">struct </span>bFileExtBlock extBlock;
00084     <span class="keywordtype">long</span> i;
00085 
00086     fileBlocks-&gt;header = entry-&gt;headerKey;
00087     adfFileRealSize( entry-&gt;byteSize, vol-&gt;datablockSize, 
00088         &amp;(fileBlocks-&gt;nbData), &amp;(fileBlocks-&gt;nbExtens) );
00089 
00090     fileBlocks-&gt;data=(SECTNUM*)malloc(fileBlocks-&gt;nbData * <span class="keyword">sizeof</span>(SECTNUM));
00091     <span class="keywordflow">if</span> (!fileBlocks-&gt;data) {
00092         (*adfEnv.eFct)(<span class="stringliteral">"adfGetFileBlocks : malloc"</span>);
00093         <span class="keywordflow">return</span> RC_MALLOC;
00094     }
00095 
00096     fileBlocks-&gt;extens=(SECTNUM*)malloc(fileBlocks-&gt;nbExtens * <span class="keyword">sizeof</span>(SECTNUM));
00097     <span class="keywordflow">if</span> (!fileBlocks-&gt;extens) {
00098         (*adfEnv.eFct)(<span class="stringliteral">"adfGetFileBlocks : malloc"</span>);
00099         <span class="keywordflow">return</span> RC_MALLOC;
00100     }
00101  
00102     n = m = 0;  
00103     <span class="comment">/* in file header block */</span>
00104     <span class="keywordflow">for</span>(i=0; i&lt;entry-&gt;highSeq; i++)
00105         fileBlocks-&gt;data[n++] = entry-&gt;dataBlocks[MAX_DATABLK-1-i];
00106 
00107     <span class="comment">/* in file extension blocks */</span>
00108     nSect = entry-&gt;extension;
00109     <span class="keywordflow">while</span>(nSect!=0) {
00110         fileBlocks-&gt;extens[m++] = nSect;
00111         adfReadFileExtBlock(vol, nSect, &amp;extBlock);
00112         <span class="keywordflow">for</span>(i=0; i&lt;extBlock.highSeq; i++)
00113             fileBlocks-&gt;data[n++] = extBlock.dataBlocks[MAX_DATABLK-1-i];
00114         nSect = extBlock.extension;
00115     }
00116     <span class="keywordflow">if</span> ( (fileBlocks-&gt;nbExtens+fileBlocks-&gt;nbData) != (n+m) )
00117         (*adfEnv.wFct)(<span class="stringliteral">"adfGetFileBlocks : less blocks than expected"</span>);
00118 
00119     <span class="keywordflow">return</span> RC_OK;
00120 }
00121 
00122 <span class="comment">/*</span>
00123 <span class="comment"> * adfFreeFileBlocks</span>
00124 <span class="comment"> *</span>
00125 <span class="comment"> */</span>
00126 RETCODE adfFreeFileBlocks(<span class="keyword">struct</span> Volume* vol, <span class="keyword">struct</span> bFileHeaderBlock *entry)
00127 {
00128     <span class="keywordtype">int</span> i;
00129     <span class="keyword">struct </span>FileBlocks fileBlocks;
00130     RETCODE rc = RC_OK;
00131 
00132     adfGetFileBlocks(vol,entry,&amp;fileBlocks);
00133 
00134     <span class="keywordflow">for</span>(i=0; i&lt;fileBlocks.nbData; i++) {
00135         adfSetBlockFree(vol, fileBlocks.data[i]);
00136     }
00137     <span class="keywordflow">for</span>(i=0; i&lt;fileBlocks.nbExtens; i++) {
00138         adfSetBlockFree(vol, fileBlocks.extens[i]);
00139     }
00140 
00141     free(fileBlocks.data);
00142     free(fileBlocks.extens);
00143         
00144     <span class="keywordflow">return</span> rc;
00145 }
00146 
00147 
00148 <span class="comment">/*</span>
00149 <span class="comment"> * adfFileRealSize</span>
00150 <span class="comment"> *</span>
00151 <span class="comment"> * Compute and return real number of block used by one file</span>
00152 <span class="comment"> * Compute number of datablocks and file extension blocks</span>
00153 <span class="comment"> *</span>
00154 <span class="comment"> */</span>
00155 <span class="keywordtype">long</span> adfFileRealSize(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size, <span class="keywordtype">int</span> blockSize, <span class="keywordtype">long</span> *dataN, <span class="keywordtype">long</span> *extN)
00156 {
00157     <span class="keywordtype">long</span> data, ext;
00158 
00159    <span class="comment">/*--- number of data blocks ---*/</span>
00160     data = size / blockSize;
00161     <span class="keywordflow">if</span> ( size % blockSize )
00162         data++;
00163 
00164     <span class="comment">/*--- number of header extension blocks ---*/</span>
00165     ext = 0;
00166     <span class="keywordflow">if</span> (data&gt;MAX_DATABLK) {
00167         ext = (data-MAX_DATABLK) / MAX_DATABLK;
00168         <span class="keywordflow">if</span> ( (data-MAX_DATABLK) % MAX_DATABLK )
00169             ext++;
00170     }
00171 
00172     <span class="keywordflow">if</span> (dataN)
00173         *dataN = data;
00174     <span class="keywordflow">if</span> (extN)
00175         *extN = ext;
00176         
00177     <span class="keywordflow">return</span>(ext+data+1);
00178 }
00179 
00180 
00181 <span class="comment">/*</span>
00182 <span class="comment"> * adfWriteFileHdrBlock</span>
00183 <span class="comment"> *</span>
00184 <span class="comment"> */</span>
00185 RETCODE adfWriteFileHdrBlock(<span class="keyword">struct</span> Volume *vol, SECTNUM nSect, <span class="keyword">struct</span> bFileHeaderBlock* fhdr)
00186 {
00187     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[512];
00188     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00189     RETCODE rc = RC_OK;
00190 <span class="comment">/*printf("adfWriteFileHdrBlock %ld\n",nSect);*/</span>
00191     fhdr-&gt;type = T_HEADER;
00192     fhdr-&gt;dataSize = 0;
00193     fhdr-&gt;secType = ST_FILE;
00194 
00195     memcpy(buf, fhdr, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bFileHeaderBlock));
00196 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00197 <span class="preprocessor"></span>    swapEndian(buf, SWBL_FILE);
00198 <span class="preprocessor">#endif</span>
00199 <span class="preprocessor"></span>    newSum = adfNormalSum(buf,20,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bFileHeaderBlock));
00200     swLong(buf+20, newSum);
00201 <span class="comment">/*    *(unsigned long*)(buf+20) = swapLong((unsigned char*)&amp;newSum);*/</span>
00202 
00203     adfWriteBlock(vol, nSect, buf);
00204 
00205     <span class="keywordflow">return</span> rc;
00206 }
00207 
00208 
00209 <span class="comment">/*</span>
00210 <span class="comment"> * adfFileSeek</span>
00211 <span class="comment"> *</span>
00212 <span class="comment"> */</span>
00213 <span class="keywordtype">void</span> adfFileSeek(<span class="keyword">struct</span> File *file, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> pos)
00214 {
00215     SECTNUM extBlock, nSect;
00216     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> nPos;
00217     <span class="keywordtype">int</span> i;
00218     
00219     nPos = min(pos, file-&gt;fileHdr-&gt;byteSize);
00220     file-&gt;pos = nPos;
00221     extBlock = adfPos2DataBlock(nPos, file-&gt;volume-&gt;datablockSize,
00222         &amp;(file-&gt;posInExtBlk), &amp;(file-&gt;posInDataBlk), &amp;(file-&gt;curDataPtr) );
00223     <span class="keywordflow">if</span> (extBlock==-1) {
00224         adfReadDataBlock(file-&gt;volume,
00225             file-&gt;fileHdr-&gt;dataBlocks[MAX_DATABLK-1-file-&gt;curDataPtr],
00226             file-&gt;currentData);
00227     }
00228     <span class="keywordflow">else</span> {
00229         nSect = file-&gt;fileHdr-&gt;extension;
00230         i = 0;
00231         <span class="keywordflow">while</span>( i&lt;extBlock &amp;&amp; nSect!=0 ) {
00232             adfReadFileExtBlock(file-&gt;volume, nSect, file-&gt;currentExt );
00233             nSect = file-&gt;currentExt-&gt;extension;
00234         }
00235         <span class="keywordflow">if</span> (i!=extBlock)
00236             (*adfEnv.wFct)(<span class="stringliteral">"error"</span>);
00237         adfReadDataBlock(file-&gt;volume,
00238             file-&gt;currentExt-&gt;dataBlocks[file-&gt;posInExtBlk], file-&gt;currentData);
00239     }
00240 }
00241 
00242 
00243 <span class="comment">/*</span>
00244 <span class="comment"> * adfFileOpen</span>
00245 <span class="comment"> *</span>
00246 <span class="comment"> */</span> 
00247 <span class="keyword">struct </span>File* adfOpenFile(struct Volume *vol, char* name, char *mode)
00248 {
00249     <span class="keyword">struct </span>File *file;
00250     SECTNUM nSect;
00251     <span class="keyword">struct </span>bEntryBlock entry, parent;
00252     BOOL write;
00253     <span class="keywordtype">char</span> filename[200];
00254 
00255     write=( strcmp(<span class="stringliteral">"w"</span>,mode)==0 || strcmp(<span class="stringliteral">"a"</span>,mode)==0 );
00256     
00257     <span class="keywordflow">if</span> (write &amp;&amp; vol-&gt;dev-&gt;readOnly) {
00258         (*adfEnv.wFct)(<span class="stringliteral">"adfFileOpen : device is mounted 'read only'"</span>);
00259         <span class="keywordflow">return</span> NULL;
00260     }
00261 
00262     adfReadEntryBlock(vol, vol-&gt;curDirPtr, &amp;parent);
00263 
00264     nSect = adfNameToEntryBlk(vol, parent.hashTable, name, &amp;entry, NULL);
00265     <span class="keywordflow">if</span> (!write &amp;&amp; nSect==-1) {
00266         sprintf(filename,<span class="stringliteral">"adfFileOpen : file \"%s\" not found."</span>,name);
00267         (*adfEnv.wFct)(filename);
00268 <span class="comment">/*fprintf(stdout,"filename %s %d, parent =%d\n",name,strlen(name),vol-&gt;curDirPtr);*/</span>
00269          <span class="keywordflow">return</span> NULL; 
00270     }
00271     <span class="keywordflow">if</span> (!write &amp;&amp; hasR(entry.access)) {
00272         (*adfEnv.wFct)(<span class="stringliteral">"adfFileOpen : access denied"</span>); <span class="keywordflow">return</span> NULL; }
00273 <span class="comment">/*    if (entry.secType!=ST_FILE) {</span>
00274 <span class="comment">        (*adfEnv.wFct)("adfFileOpen : not a file"); return NULL; }</span>
00275 <span class="comment">    if (write &amp;&amp; (hasE(entry.access)||hasW(entry.access))) {</span>
00276 <span class="comment">        (*adfEnv.wFct)("adfFileOpen : access denied"); return NULL; }  </span>
00277 <span class="comment">*/</span>    <span class="keywordflow">if</span> (write &amp;&amp; nSect!=-1) {
00278         (*adfEnv.wFct)(<span class="stringliteral">"adfFileOpen : file already exists"</span>); <span class="keywordflow">return</span> NULL; }  
00279 
00280     file = (<span class="keyword">struct </span>File*)malloc(sizeof(struct File));
00281     <span class="keywordflow">if</span> (!file) { (*adfEnv.wFct)(<span class="stringliteral">"adfFileOpen : malloc"</span>); <span class="keywordflow">return</span> NULL; }
00282     file-&gt;fileHdr = (<span class="keyword">struct </span>bFileHeaderBlock*)malloc(sizeof(struct bFileHeaderBlock));
00283     <span class="keywordflow">if</span> (!file-&gt;fileHdr) {
00284         (*adfEnv.wFct)(<span class="stringliteral">"adfFileOpen : malloc"</span>); 
00285         free(file); <span class="keywordflow">return</span> NULL; 
00286     }
00287     file-&gt;currentData = malloc(512*<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>));
00288     <span class="keywordflow">if</span> (!file-&gt;currentData) { 
00289         (*adfEnv.wFct)(<span class="stringliteral">"adfFileOpen : malloc"</span>); 
00290         free(file-&gt;fileHdr); free(file); <span class="keywordflow">return</span> NULL; 
00291     }
00292 
00293     file-&gt;volume = vol;
00294     file-&gt;pos = 0;
00295     file-&gt;posInExtBlk = 0;
00296     file-&gt;posInDataBlk = 0;
00297     file-&gt;writeMode = write;
00298     file-&gt;currentExt = NULL;
00299     file-&gt;nDataBlock = 0;
00300 
00301     <span class="keywordflow">if</span> (strcmp(<span class="stringliteral">"w"</span>,mode)==0) {
00302         memset(file-&gt;fileHdr,0,512);
00303         adfCreateFile(vol,vol-&gt;curDirPtr,name,file-&gt;fileHdr);
00304         file-&gt;eof = TRUE;
00305     }
00306     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(<span class="stringliteral">"a"</span>,mode)==0) {
00307         memcpy(file-&gt;fileHdr,&amp;entry,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bFileHeaderBlock));
00308         file-&gt;eof = TRUE;
00309         adfFileSeek(file, file-&gt;fileHdr-&gt;byteSize);
00310     }
00311     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(<span class="stringliteral">"r"</span>,mode)==0) {
00312         memcpy(file-&gt;fileHdr,&amp;entry,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bFileHeaderBlock));
00313         file-&gt;eof = FALSE;
00314     }
00315 
00316 <span class="comment">/*puts("adfOpenFile");*/</span>
00317     <span class="keywordflow">return</span>(file);
00318 }
00319 
00320 
00321 <span class="comment">/*</span>
00322 <span class="comment"> * adfCloseFile</span>
00323 <span class="comment"> *</span>
00324 <span class="comment"> */</span>
00325 <span class="keywordtype">void</span> adfCloseFile(<span class="keyword">struct</span> File *file)
00326 {
00327 
00328     <span class="keywordflow">if</span> (file==0)
00329         <span class="keywordflow">return</span>;
00330 <span class="comment">/*puts("adfCloseFile in");*/</span>
00331 
00332     adfFlushFile(file);
00333 
00334     <span class="keywordflow">if</span> (file-&gt;currentExt)
00335         free(file-&gt;currentExt);
00336     
00337     <span class="keywordflow">if</span> (file-&gt;currentData)
00338         free(file-&gt;currentData);
00339     
00340     free(file-&gt;fileHdr);
00341     free(file);
00342 
00343 <span class="comment">/*puts("adfCloseFile out");*/</span>
00344 }
00345 
00346 
00347 <span class="comment">/*</span>
00348 <span class="comment"> * adfReadFile</span>
00349 <span class="comment"> *</span>
00350 <span class="comment"> */</span>
00351 <span class="keywordtype">long</span> adfReadFile(<span class="keyword">struct</span> File* file, <span class="keywordtype">long</span> n, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer)
00352 {
00353     <span class="keywordtype">long</span> bytesRead;
00354     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *dataPtr, *bufPtr;
00355     <span class="keywordtype">int</span> blockSize, size;
00356 
00357     <span class="keywordflow">if</span> (n==0) <span class="keywordflow">return</span>(n);
00358     blockSize = file-&gt;volume-&gt;datablockSize;
00359 <span class="comment">/*puts("adfReadFile");*/</span>
00360     <span class="keywordflow">if</span> (file-&gt;pos+n &gt; file-&gt;fileHdr-&gt;byteSize)
00361         n = file-&gt;fileHdr-&gt;byteSize - file-&gt;pos;
00362 
00363     <span class="keywordflow">if</span> (isOFS(file-&gt;volume-&gt;dosType))
00364         dataPtr = (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)(file-&gt;currentData)+24;
00365     <span class="keywordflow">else</span>
00366         dataPtr = file-&gt;currentData;
00367 
00368     <span class="keywordflow">if</span> (file-&gt;pos==0 || file-&gt;posInDataBlk==blockSize) {
00369         adfReadNextFileBlock(file);
00370         file-&gt;posInDataBlk = 0;
00371     }
00372 
00373     bytesRead = 0; bufPtr = buffer;
00374     size = 0;
00375     <span class="keywordflow">while</span> ( bytesRead &lt; n ) {
00376         size = min(n-bytesRead, blockSize-file-&gt;posInDataBlk);
00377         memcpy(bufPtr, dataPtr+file-&gt;posInDataBlk, size);
00378         bufPtr += size;
00379         file-&gt;pos += size;
00380         bytesRead += size;
00381         file-&gt;posInDataBlk += size;
00382         <span class="keywordflow">if</span> (file-&gt;posInDataBlk==blockSize &amp;&amp; bytesRead&lt;n) {
00383             adfReadNextFileBlock(file);
00384             file-&gt;posInDataBlk = 0;
00385         }
00386     }
00387     file-&gt;eof = (file-&gt;pos==file-&gt;fileHdr-&gt;byteSize);
00388     <span class="keywordflow">return</span>( bytesRead );
00389 }
00390 
00391 
00392 <span class="comment">/*</span>
00393 <span class="comment"> * adfEndOfFile</span>
00394 <span class="comment"> *</span>
00395 <span class="comment"> */</span>
00396 BOOL adfEndOfFile(<span class="keyword">struct</span> File* file)
00397 {
00398     <span class="keywordflow">return</span>(file-&gt;eof);
00399 }
00400 
00401 
00402 <span class="comment">/*</span>
00403 <span class="comment"> * adfReadNextFileBlock</span>
00404 <span class="comment"> *</span>
00405 <span class="comment"> */</span>
00406 RETCODE adfReadNextFileBlock(<span class="keyword">struct</span> File* file)
00407 {
00408     SECTNUM nSect;
00409     <span class="keyword">struct </span>bOFSDataBlock *data;
00410     RETCODE rc = RC_OK;
00411 
00412     data =(<span class="keyword">struct </span>bOFSDataBlock *) file-&gt;currentData;
00413 
00414     <span class="keywordflow">if</span> (file-&gt;nDataBlock==0) {
00415         nSect = file-&gt;fileHdr-&gt;firstData;
00416     }
00417     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isOFS(file-&gt;volume-&gt;dosType)) {
00418         nSect = data-&gt;nextData;
00419     }
00420     <span class="keywordflow">else</span> {
00421         <span class="keywordflow">if</span> (file-&gt;nDataBlock&lt;MAX_DATABLK)
00422             nSect = file-&gt;fileHdr-&gt;dataBlocks[MAX_DATABLK-1-file-&gt;nDataBlock];
00423         <span class="keywordflow">else</span> {
00424             <span class="keywordflow">if</span> (file-&gt;nDataBlock==MAX_DATABLK) {
00425                 file-&gt;currentExt=(<span class="keyword">struct </span>bFileExtBlock*)malloc(sizeof(struct bFileExtBlock));
00426                 <span class="keywordflow">if</span> (!file-&gt;currentExt) (*adfEnv.eFct)(<span class="stringliteral">"adfReadNextFileBlock : malloc"</span>);
00427                 adfReadFileExtBlock(file-&gt;volume, file-&gt;fileHdr-&gt;extension,
00428                     file-&gt;currentExt);
00429                 file-&gt;posInExtBlk = 0;
00430             }
00431             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (file-&gt;posInExtBlk==MAX_DATABLK) {
00432                 adfReadFileExtBlock(file-&gt;volume, file-&gt;currentExt-&gt;extension,
00433                     file-&gt;currentExt);
00434                 file-&gt;posInExtBlk = 0;
00435             }
00436             nSect = file-&gt;currentExt-&gt;dataBlocks[MAX_DATABLK-1-file-&gt;posInExtBlk];
00437             file-&gt;posInExtBlk++;
00438         }
00439     }
00440     adfReadDataBlock(file-&gt;volume,nSect,file-&gt;currentData);
00441 
00442     <span class="keywordflow">if</span> (isOFS(file-&gt;volume-&gt;dosType) &amp;&amp; data-&gt;seqNum!=file-&gt;nDataBlock+1)
00443         (*adfEnv.wFct)(<span class="stringliteral">"adfReadNextFileBlock : seqnum incorrect"</span>);
00444 
00445     file-&gt;nDataBlock++;
00446 
00447     <span class="keywordflow">return</span> rc;
00448 }
00449 
00450 
00451 <span class="comment">/*</span>
00452 <span class="comment"> * adfWriteFile</span>
00453 <span class="comment"> *</span>
00454 <span class="comment"> */</span>
00455 <span class="keywordtype">long</span> adfWriteFile(<span class="keyword">struct</span> File *file, <span class="keywordtype">long</span> n, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buffer)
00456 {
00457     <span class="keywordtype">long</span> bytesWritten;
00458     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *dataPtr, *bufPtr;
00459     <span class="keywordtype">int</span> size, blockSize;
00460     <span class="keyword">struct </span>bOFSDataBlock *dataB;
00461 
00462     <span class="keywordflow">if</span> (n==0) <span class="keywordflow">return</span> (n);
00463 <span class="comment">/*puts("adfWriteFile");*/</span>
00464     blockSize = file-&gt;volume-&gt;datablockSize;
00465     <span class="keywordflow">if</span> (isOFS(file-&gt;volume-&gt;dosType)) {
00466         dataB =(<span class="keyword">struct </span>bOFSDataBlock *)file-&gt;currentData;
00467         dataPtr = dataB-&gt;data;
00468     }
00469     <span class="keywordflow">else</span>
00470         dataPtr = file-&gt;currentData;
00471 
00472     <span class="keywordflow">if</span> (file-&gt;pos==0 || file-&gt;posInDataBlk==blockSize) {
00473         <span class="keywordflow">if</span> (adfCreateNextFileBlock(file)==-1)
00474             (*adfEnv.wFct)(<span class="stringliteral">"adfWritefile : no more free sector availbale"</span>);                        
00475         file-&gt;posInDataBlk = 0;
00476     }
00477 
00478     bytesWritten = 0; bufPtr = buffer;
00479     <span class="keywordflow">while</span>( bytesWritten&lt;n ) {
00480         size = min(n-bytesWritten, blockSize-file-&gt;posInDataBlk);
00481         memcpy(dataPtr+file-&gt;posInDataBlk, bufPtr, size);
00482         bufPtr += size;
00483         file-&gt;pos += size;
00484         bytesWritten += size;
00485         file-&gt;posInDataBlk += size;
00486         <span class="keywordflow">if</span> (file-&gt;posInDataBlk==blockSize &amp;&amp; bytesWritten&lt;n) {
00487             <span class="keywordflow">if</span> (adfCreateNextFileBlock(file)==-1)
00488                 (*adfEnv.wFct)(<span class="stringliteral">"adfWritefile : no more free sector availbale"</span>);                        
00489             file-&gt;posInDataBlk = 0;
00490         }
00491     }
00492     <span class="keywordflow">return</span>( bytesWritten );
00493 }
00494 
00495 
00496 <span class="comment">/*</span>
00497 <span class="comment"> * adfCreateNextFileBlock</span>
00498 <span class="comment"> *</span>
00499 <span class="comment"> */</span>
00500 SECTNUM adfCreateNextFileBlock(<span class="keyword">struct</span> File* file)
00501 {
00502     SECTNUM nSect, extSect;
00503     <span class="keyword">struct </span>bOFSDataBlock *data;
00504     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> blockSize;
00505     <span class="keywordtype">int</span> i;
00506 <span class="comment">/*puts("adfCreateNextFileBlock");*/</span>
00507     blockSize = file-&gt;volume-&gt;datablockSize;
00508     data = file-&gt;currentData;
00509 
00510     <span class="comment">/* the first data blocks pointers are inside the file header block */</span>
00511     <span class="keywordflow">if</span> (file-&gt;nDataBlock&lt;MAX_DATABLK) {
00512         nSect = adfGet1FreeBlock(file-&gt;volume);
00513         <span class="keywordflow">if</span> (nSect==-1) <span class="keywordflow">return</span> -1;
00514 <span class="comment">/*printf("adfCreateNextFileBlock fhdr %ld\n",nSect);*/</span>
00515         <span class="keywordflow">if</span> (file-&gt;nDataBlock==0)
00516             file-&gt;fileHdr-&gt;firstData = nSect;
00517         file-&gt;fileHdr-&gt;dataBlocks[MAX_DATABLK-1-file-&gt;nDataBlock] = nSect;
00518         file-&gt;fileHdr-&gt;highSeq++;
00519     }
00520     <span class="keywordflow">else</span> {
00521         <span class="comment">/* one more sector is needed for one file extension block */</span>
00522         <span class="keywordflow">if</span> ((file-&gt;nDataBlock%MAX_DATABLK)==0) {
00523             extSect = adfGet1FreeBlock(file-&gt;volume);
00524 <span class="comment">/*printf("extSect=%ld\n",extSect);*/</span>
00525             <span class="keywordflow">if</span> (extSect==-1) <span class="keywordflow">return</span> -1;
00526 
00527             <span class="comment">/* the future block is the first file extension block */</span>
00528             <span class="keywordflow">if</span> (file-&gt;nDataBlock==MAX_DATABLK) {
00529                 file-&gt;currentExt=(<span class="keyword">struct </span>bFileExtBlock*)malloc(sizeof(struct bFileExtBlock));
00530                 <span class="keywordflow">if</span> (!file-&gt;currentExt) {
00531                     adfSetBlockFree(file-&gt;volume, extSect);
00532                     (*adfEnv.eFct)(<span class="stringliteral">"adfCreateNextFileBlock : malloc"</span>);
00533                     <span class="keywordflow">return</span> -1;
00534                 }
00535                 file-&gt;fileHdr-&gt;extension = extSect;
00536             }
00537 
00538             <span class="comment">/* not the first : save the current one, and link it with the future */</span>
00539             <span class="keywordflow">if</span> (file-&gt;nDataBlock&gt;=2*MAX_DATABLK) {
00540                 file-&gt;currentExt-&gt;extension = extSect;
00541 <span class="comment">/*printf ("write ext=%d\n",file-&gt;currentExt-&gt;headerKey);*/</span>
00542                 adfWriteFileExtBlock(file-&gt;volume, file-&gt;currentExt-&gt;headerKey,
00543                     file-&gt;currentExt);
00544             }
00545 
00546             <span class="comment">/* initializes a file extension block */</span>
00547             <span class="keywordflow">for</span>(i=0; i&lt;MAX_DATABLK; i++)
00548                 file-&gt;currentExt-&gt;dataBlocks[i] = 0L;
00549             file-&gt;currentExt-&gt;headerKey = extSect;
00550             file-&gt;currentExt-&gt;parent = file-&gt;fileHdr-&gt;headerKey;
00551             file-&gt;currentExt-&gt;highSeq = 0L;
00552             file-&gt;currentExt-&gt;extension = 0L;
00553             file-&gt;posInExtBlk = 0L;
00554 <span class="comment">/*printf("extSect=%ld\n",extSect);*/</span>
00555         }
00556         nSect = adfGet1FreeBlock(file-&gt;volume);
00557         <span class="keywordflow">if</span> (nSect==-1) 
00558             <span class="keywordflow">return</span> -1;
00559         
00560 <span class="comment">/*printf("adfCreateNextFileBlock ext %ld\n",nSect);*/</span>
00561 
00562         file-&gt;currentExt-&gt;dataBlocks[MAX_DATABLK-1-file-&gt;posInExtBlk] = nSect;
00563         file-&gt;currentExt-&gt;highSeq++;
00564         file-&gt;posInExtBlk++;
00565     }
00566 
00567     <span class="comment">/* builds OFS header */</span>
00568     <span class="keywordflow">if</span> (isOFS(file-&gt;volume-&gt;dosType)) {
00569         <span class="comment">/* writes previous data block and link it  */</span>
00570         <span class="keywordflow">if</span> (file-&gt;pos&gt;=blockSize) {
00571             data-&gt;nextData = nSect;
00572             adfWriteDataBlock(file-&gt;volume, file-&gt;curDataPtr, file-&gt;currentData);
00573 <span class="comment">/*printf ("writedata=%d\n",file-&gt;curDataPtr);*/</span>
00574         }
00575         <span class="comment">/* initialize a new data block */</span>
00576         <span class="keywordflow">for</span>(i=0; i&lt;(int)blockSize; i++)
00577             data-&gt;data[i]=0;
00578         data-&gt;seqNum = file-&gt;nDataBlock+1;
00579         data-&gt;dataSize = blockSize;
00580         data-&gt;nextData = 0L;
00581         data-&gt;headerKey = file-&gt;fileHdr-&gt;headerKey;
00582     }
00583     <span class="keywordflow">else</span>
00584         <span class="keywordflow">if</span> (file-&gt;pos&gt;=blockSize) {
00585             adfWriteDataBlock(file-&gt;volume, file-&gt;curDataPtr, file-&gt;currentData);
00586 <span class="comment">/*printf ("writedata=%d\n",file-&gt;curDataPtr);*/</span>
00587             memset(file-&gt;currentData,0,512);
00588         }
00589             
00590 <span class="comment">/*printf("datablk=%d\n",nSect);*/</span>
00591     file-&gt;curDataPtr = nSect;
00592     file-&gt;nDataBlock++;
00593 
00594     <span class="keywordflow">return</span>(nSect);
00595 }
00596 
00597 
00598 <span class="comment">/*</span>
00599 <span class="comment"> * adfPos2DataBlock</span>
00600 <span class="comment"> *</span>
00601 <span class="comment"> */</span>
00602 <span class="keywordtype">long</span> adfPos2DataBlock(<span class="keywordtype">long</span> pos, <span class="keywordtype">int</span> blockSize, 
00603     <span class="keywordtype">int</span> *posInExtBlk, <span class="keywordtype">int</span> *posInDataBlk, <span class="keywordtype">long</span> *curDataN )
00604 {
00605     <span class="keywordtype">long</span> extBlock;
00606 
00607     *posInDataBlk = pos%blockSize;
00608     *curDataN = pos/blockSize;
00609     <span class="keywordflow">if</span> (*posInDataBlk==0)
00610         (*curDataN)++;
00611     <span class="keywordflow">if</span> (*curDataN&lt;72) {
00612         *posInExtBlk = 0;
00613         <span class="keywordflow">return</span> -1;
00614     }
00615     <span class="keywordflow">else</span> {
00616         *posInExtBlk = (pos-72*blockSize)%blockSize;
00617         extBlock = (pos-72*blockSize)/blockSize;
00618         <span class="keywordflow">if</span> (*posInExtBlk==0)
00619             extBlock++;
00620         <span class="keywordflow">return</span> extBlock;
00621     }
00622 }
00623 
00624 
00625 <span class="comment">/*</span>
00626 <span class="comment"> * adfReadDataBlock</span>
00627 <span class="comment"> *</span>
00628 <span class="comment"> */</span>
00629 RETCODE adfReadDataBlock(<span class="keyword">struct</span> Volume *vol, SECTNUM nSect, <span class="keywordtype">void</span> *data)
00630 {
00631     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[512];
00632     <span class="keyword">struct </span>bOFSDataBlock *dBlock;
00633     RETCODE rc = RC_OK;
00634 
00635     adfReadBlock(vol, nSect,buf);
00636 
00637     memcpy(data,buf,512);
00638 
00639     <span class="keywordflow">if</span> (isOFS(vol-&gt;dosType)) {
00640 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00641 <span class="preprocessor"></span>        swapEndian(data, SWBL_DATA);
00642 <span class="preprocessor">#endif</span>
00643 <span class="preprocessor"></span>        dBlock = (<span class="keyword">struct </span>bOFSDataBlock*)data;
00644 <span class="comment">/*printf("adfReadDataBlock %ld\n",nSect);*/</span>
00645 
00646         <span class="keywordflow">if</span> (dBlock-&gt;checkSum!=adfNormalSum(buf,20,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bOFSDataBlock)))
00647             (*adfEnv.wFct)(<span class="stringliteral">"adfReadDataBlock : invalid checksum"</span>);
00648         <span class="keywordflow">if</span> (dBlock-&gt;type!=T_DATA)
00649             (*adfEnv.wFct)(<span class="stringliteral">"adfReadDataBlock : id T_DATA not found"</span>);
00650         <span class="keywordflow">if</span> (dBlock-&gt;dataSize&lt;0 || dBlock-&gt;dataSize&gt;488)
00651             (*adfEnv.wFct)(<span class="stringliteral">"adfReadDataBlock : dataSize incorrect"</span>);
00652         <span class="keywordflow">if</span> ( !isSectNumValid(vol,dBlock-&gt;headerKey) )
00653             (*adfEnv.wFct)(<span class="stringliteral">"adfReadDataBlock : headerKey out of range"</span>);
00654         <span class="keywordflow">if</span> ( !isSectNumValid(vol,dBlock-&gt;nextData) )
00655             (*adfEnv.wFct)(<span class="stringliteral">"adfReadDataBlock : nextData out of range"</span>);
00656     }
00657 
00658     <span class="keywordflow">return</span> rc;
00659 }
00660 
00661 
00662 <span class="comment">/*</span>
00663 <span class="comment"> * adfWriteDataBlock</span>
00664 <span class="comment"> *</span>
00665 <span class="comment"> */</span>
00666 RETCODE adfWriteDataBlock(<span class="keyword">struct</span> Volume *vol, SECTNUM nSect, <span class="keywordtype">void</span> *data)
00667 {
00668     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[512];
00669     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00670     <span class="keyword">struct </span>bOFSDataBlock *dataB;
00671     RETCODE rc = RC_OK;
00672 
00673     newSum = 0L;
00674     <span class="keywordflow">if</span> (isOFS(vol-&gt;dosType)) {
00675         dataB = (<span class="keyword">struct </span>bOFSDataBlock *)data;
00676         dataB-&gt;type = T_DATA;
00677         memcpy(buf,dataB,512);
00678 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00679 <span class="preprocessor"></span>        swapEndian(buf, SWBL_DATA);
00680 <span class="preprocessor">#endif</span>
00681 <span class="preprocessor"></span>        newSum = adfNormalSum(buf,20,512);
00682         swLong(buf+20,newSum);
00683 <span class="comment">/*        *(long*)(buf+20) = swapLong((unsigned char*)&amp;newSum);*/</span>
00684         adfWriteBlock(vol,nSect,buf);
00685     }
00686     <span class="keywordflow">else</span> {
00687         adfWriteBlock(vol,nSect,data);
00688     }
00689 <span class="comment">/*printf("adfWriteDataBlock %ld\n",nSect);*/</span>
00690 
00691     <span class="keywordflow">return</span> rc;
00692 }
00693 
00694 
00695 <span class="comment">/*</span>
00696 <span class="comment"> * adfReadFileExtBlock</span>
00697 <span class="comment"> *</span>
00698 <span class="comment"> */</span>
00699 RETCODE adfReadFileExtBlock(<span class="keyword">struct</span> Volume *vol, SECTNUM nSect, <span class="keyword">struct</span> bFileExtBlock* fext)
00700 {
00701     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[<span class="keyword">sizeof</span>(<span class="keyword">struct </span>bFileExtBlock)];
00702     RETCODE rc = RC_OK;
00703 
00704     adfReadBlock(vol, nSect,buf);
00705 <span class="comment">/*printf("read fext=%d\n",nSect);*/</span>
00706     memcpy(fext,buf,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bFileExtBlock));
00707 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00708 <span class="preprocessor"></span>    swapEndian((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)fext, SWBL_FEXT);
00709 <span class="preprocessor">#endif</span>
00710 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (fext-&gt;checkSum!=adfNormalSum(buf,20,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bFileExtBlock)))
00711         (*adfEnv.wFct)(<span class="stringliteral">"adfReadFileExtBlock : invalid checksum"</span>);
00712     <span class="keywordflow">if</span> (fext-&gt;type!=T_LIST)
00713         (*adfEnv.wFct)(<span class="stringliteral">"adfReadFileExtBlock : type T_LIST not found"</span>);
00714     <span class="keywordflow">if</span> (fext-&gt;secType!=ST_FILE)
00715         (*adfEnv.wFct)(<span class="stringliteral">"adfReadFileExtBlock : stype  ST_FILE not found"</span>);
00716     <span class="keywordflow">if</span> (fext-&gt;headerKey!=nSect)
00717         (*adfEnv.wFct)(<span class="stringliteral">"adfReadFileExtBlock : headerKey!=nSect"</span>);
00718     <span class="keywordflow">if</span> (fext-&gt;highSeq&lt;0 || fext-&gt;highSeq&gt;MAX_DATABLK)
00719         (*adfEnv.wFct)(<span class="stringliteral">"adfReadFileExtBlock : highSeq out of range"</span>);
00720     <span class="keywordflow">if</span> ( !isSectNumValid(vol, fext-&gt;parent) ) 
00721         (*adfEnv.wFct)(<span class="stringliteral">"adfReadFileExtBlock : parent out of range"</span>);
00722     <span class="keywordflow">if</span> ( fext-&gt;extension!=0 &amp;&amp; !isSectNumValid(vol, fext-&gt;extension) )
00723         (*adfEnv.wFct)(<span class="stringliteral">"adfReadFileExtBlock : extension out of range"</span>);
00724 
00725     <span class="keywordflow">return</span> rc;
00726 }
00727 
00728 
00729 <span class="comment">/*</span>
00730 <span class="comment"> * adfWriteFileExtBlock</span>
00731 <span class="comment"> *</span>
00732 <span class="comment"> */</span>
00733 RETCODE adfWriteFileExtBlock(<span class="keyword">struct</span> Volume *vol, SECTNUM nSect, <span class="keyword">struct</span> bFileExtBlock* fext)
00734 {
00735     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[512];
00736     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00737     RETCODE rc = RC_OK;
00738 
00739     fext-&gt;type = T_LIST;
00740     fext-&gt;secType = ST_FILE;
00741     fext-&gt;dataSize = 0L;
00742     fext-&gt;firstData = 0L;
00743 
00744     memcpy(buf,fext,512);
00745 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00746 <span class="preprocessor"></span>    swapEndian(buf, SWBL_FEXT);
00747 <span class="preprocessor">#endif</span>
00748 <span class="preprocessor"></span>    newSum = adfNormalSum(buf,20,512);
00749     swLong(buf+20,newSum);
00750 <span class="comment">/*    *(long*)(buf+20) = swapLong((unsigned char*)&amp;newSum);*/</span>
00751 
00752     adfWriteBlock(vol,nSect,buf);
00753 
00754     <span class="keywordflow">return</span> rc;
00755 }
00756 <span class="comment">/*###########################################################################*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:38 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

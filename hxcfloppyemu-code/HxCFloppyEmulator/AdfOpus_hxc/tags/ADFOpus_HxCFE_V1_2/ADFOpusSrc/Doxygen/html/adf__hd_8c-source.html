<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>adf_hd.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>adf_hd.c</h1><a href="adf__hd_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  ADF Library. (C) 1997-2002 Laurent Clevy</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> */</span>
00013 <span class="preprocessor">#include&lt;stdio.h&gt;</span>
00014 <span class="preprocessor">#include&lt;stdlib.h&gt;</span>
00015 <span class="preprocessor">#include&lt;string.h&gt;</span>
00016 
00017 <span class="preprocessor">#include"adf_str.h"</span>
00018 <span class="preprocessor">#include"hd_blk.h"</span>
00019 <span class="preprocessor">#include"adf_raw.h"</span>
00020 <span class="preprocessor">#include"adf_hd.h"</span>
00021 <span class="preprocessor">#include"adf_util.h"</span>
00022 <span class="preprocessor">#include"adf_disk.h"</span>
00023 <span class="preprocessor">#include"adf_nativ.h"</span>
00024 <span class="preprocessor">#include"adf_dump.h"</span>
00025 <span class="preprocessor">#include"adf_err.h"</span>
00026 
00027 <span class="preprocessor">#include"defendian.h"</span>
00028 
00029 <span class="keyword">extern</span> <span class="keyword">struct </span>Env adfEnv;
00030 
00031 <span class="comment">/*</span>
00032 <span class="comment"> * adfDevType</span>
00033 <span class="comment"> *</span>
00034 <span class="comment"> * returns the type of a device</span>
00035 <span class="comment"> * only based of the field 'dev-&gt;size'</span>
00036 <span class="comment"> */</span>
00037 <span class="keywordtype">int</span> adfDevType(<span class="keyword">struct</span> Device* dev)
00038 {
00039     <span class="keywordflow">if</span>( (dev-&gt;size==512*11*2*80) ||     <span class="comment">/* BV */</span>
00040         (dev-&gt;size==512*11*2*81) ||     <span class="comment">/* BV */</span>
00041         (dev-&gt;size==512*11*2*82) ||     <span class="comment">/* BV */</span>
00042         (dev-&gt;size==512*11*2*83) )      <span class="comment">/* BV */</span>
00043         <span class="keywordflow">return</span>(DEVTYPE_FLOPDD);
00044     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dev-&gt;size==512*22*2*80)
00045         <span class="keywordflow">return</span>(DEVTYPE_FLOPHD);
00046     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dev-&gt;size&gt;512*22*2*80)
00047         <span class="keywordflow">return</span>(DEVTYPE_HARDDISK);
00048     <span class="keywordflow">else</span> {
00049         (*adfEnv.eFct)(<span class="stringliteral">"adfDevType : unknown device type"</span>);
00050         <span class="keywordflow">return</span>(-1);
00051     }
00052 }
00053 
00054 
00055 <span class="comment">/*</span>
00056 <span class="comment"> * adfDeviceInfo</span>
00057 <span class="comment"> *</span>
00058 <span class="comment"> * display information about the device and its volumes</span>
00059 <span class="comment"> * for demonstration purpose only since the output is stdout !</span>
00060 <span class="comment"> *</span>
00061 <span class="comment"> * can be used before adfCreateVol() or adfMount()</span>
00062 <span class="comment"> */</span>
00063 <span class="keywordtype">void</span> adfDeviceInfo(<span class="keyword">struct</span> Device *dev)
00064 {
00065     <span class="keywordtype">int</span> i;
00066     
00067     printf(<span class="stringliteral">"Cylinders   = %ld\n"</span>,dev-&gt;cylinders);
00068     printf(<span class="stringliteral">"Heads       = %ld\n"</span>,dev-&gt;heads);
00069     printf(<span class="stringliteral">"Sectors/Cyl = %ld\n\n"</span>,dev-&gt;sectors);
00070     <span class="keywordflow">if</span> (!dev-&gt;isNativeDev)
00071         printf(<span class="stringliteral">"Dump device\n\n"</span>);
00072     <span class="keywordflow">else</span>
00073         printf(<span class="stringliteral">"Real device\n\n"</span>);
00074     printf(<span class="stringliteral">"Volumes     = %d\n\n"</span>,dev-&gt;nVol);
00075 <span class="comment">/*</span>
00076 <span class="comment">    switch(dev-&gt;devType){</span>
00077 <span class="comment">    case DEVTYPE_FLOPDD:</span>
00078 <span class="comment">        printf("floppy dd\n"); break;</span>
00079 <span class="comment">    case DEVTYPE_FLOPHD:</span>
00080 <span class="comment">        printf("floppy hd\n"); break;</span>
00081 <span class="comment">    case DEVTYPE_HARDDISK:</span>
00082 <span class="comment">        printf("harddisk\n"); break;</span>
00083 <span class="comment">    case DEVTYPE_HARDFILE:</span>
00084 <span class="comment">        printf("hardfile\n"); break;</span>
00085 <span class="comment">    default:</span>
00086 <span class="comment">        printf("unknown devType!\n"); break;</span>
00087 <span class="comment">    }</span>
00088 <span class="comment">*/</span>
00089 
00090     <span class="keywordflow">for</span>(i=0; i&lt;dev-&gt;nVol; i++) {
00091         <span class="keywordflow">if</span> (dev-&gt;volList[i]-&gt;volName)
00092             printf(<span class="stringliteral">"%2d :  %7ld -&gt;%7ld, \"%s\""</span>, i,
00093             dev-&gt;volList[i]-&gt;firstBlock,
00094             dev-&gt;volList[i]-&gt;lastBlock,
00095             dev-&gt;volList[i]-&gt;volName);
00096         <span class="keywordflow">else</span>
00097             printf(<span class="stringliteral">"%2d :  %7ld -&gt;%7ld\n"</span>, i,
00098             dev-&gt;volList[i]-&gt;firstBlock,
00099             dev-&gt;volList[i]-&gt;lastBlock);
00100         <span class="keywordflow">if</span> (dev-&gt;volList[i]-&gt;mounted)
00101             printf(<span class="stringliteral">", mounted"</span>);
00102         putchar(<span class="charliteral">'\n'</span>);
00103     }
00104 }
00105 
00106 
00107 <span class="comment">/*</span>
00108 <span class="comment"> * adfFreeTmpVolList</span>
00109 <span class="comment"> *</span>
00110 <span class="comment"> */</span>
00111 <span class="keywordtype">void</span> adfFreeTmpVolList(<span class="keyword">struct</span> List *root)
00112 {
00113     <span class="keyword">struct </span>List *cell;
00114     <span class="keyword">struct </span>Volume *vol;
00115 
00116     cell = root;
00117     <span class="keywordflow">while</span>(cell!=NULL) {
00118         vol = (<span class="keyword">struct </span>Volume *)cell-&gt;content;
00119         <span class="keywordflow">if</span> (vol-&gt;volName!=NULL)
00120             free(vol-&gt;volName);  
00121         cell = cell-&gt;next;
00122     }
00123     freeList(root);
00124 
00125 }
00126 
00127 
00128 <span class="comment">/*</span>
00129 <span class="comment"> * adfMountHdFile</span>
00130 <span class="comment"> *</span>
00131 <span class="comment"> */</span>
00132 RETCODE adfMountHdFile(<span class="keyword">struct</span> Device *dev)
00133 {
00134     <span class="keyword">struct </span>Volume* vol;
00135     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[512];
00136     <span class="keywordtype">long</span> size;
00137     BOOL found;
00138 
00139     dev-&gt;devType = DEVTYPE_HARDFILE;
00140     dev-&gt;nVol = 0;
00141     dev-&gt;volList = (<span class="keyword">struct </span>Volume**)malloc(sizeof(struct Volume*));
00142     <span class="keywordflow">if</span> (!dev-&gt;volList) { 
00143         (*adfEnv.eFct)(<span class="stringliteral">"adfMountHdFile : malloc"</span>);
00144         <span class="keywordflow">return</span> RC_ERROR;
00145     }
00146 
00147     vol=(<span class="keyword">struct </span>Volume*)malloc(sizeof(struct Volume));
00148     <span class="keywordflow">if</span> (!vol) {
00149         (*adfEnv.eFct)(<span class="stringliteral">"adfMountHdFile : malloc"</span>);
00150         <span class="keywordflow">return</span> RC_ERROR;
00151     }
00152     dev-&gt;volList[0] = vol;
00153     dev-&gt;nVol++;      <span class="comment">/* fixed by Dan, ... and by Gary */</span>
00154 
00155     vol-&gt;volName=NULL;
00156     
00157     dev-&gt;cylinders = dev-&gt;size/512;
00158     dev-&gt;heads = 1;
00159     dev-&gt;sectors = 1;
00160 
00161     vol-&gt;firstBlock = 0;
00162 
00163     size = dev-&gt;size + 512-(dev-&gt;size%512);
00164 <span class="comment">/*printf("size=%ld\n",size);*/</span>
00165     vol-&gt;rootBlock = (size/512)/2;
00166 <span class="comment">/*printf("root=%ld\n",vol-&gt;rootBlock);*/</span>
00167     <span class="keywordflow">do</span> {
00168         adfReadDumpSector(dev, vol-&gt;rootBlock, 512, buf);
00169         found = swapLong(buf)==T_HEADER &amp;&amp; swapLong(buf+508)==ST_ROOT;
00170         <span class="keywordflow">if</span> (!found)
00171             (vol-&gt;rootBlock)--;
00172     }<span class="keywordflow">while</span> (vol-&gt;rootBlock&gt;1 &amp;&amp; !found);
00173 
00174     <span class="keywordflow">if</span> (vol-&gt;rootBlock==1) {
00175         (*adfEnv.eFct)(<span class="stringliteral">"adfMountHdFile : rootblock not found"</span>);
00176         <span class="keywordflow">return</span> RC_ERROR;
00177     }
00178     vol-&gt;lastBlock = vol-&gt;rootBlock*2 - 1 ;
00179 
00180     <span class="keywordflow">return</span> RC_OK;
00181 }
00182 
00183 
00184 <span class="comment">/*</span>
00185 <span class="comment"> * adfMountHd</span>
00186 <span class="comment"> *</span>
00187 <span class="comment"> * normal not used directly : called by adfMount()</span>
00188 <span class="comment"> *</span>
00189 <span class="comment"> * fills geometry fields and volumes list (dev-&gt;nVol and dev-&gt;volList[])</span>
00190 <span class="comment"> */</span>
00191 RETCODE adfMountHd(<span class="keyword">struct</span> Device *dev)
00192 {
00193     <span class="keyword">struct </span>bRDSKblock rdsk;
00194     <span class="keyword">struct </span>bPARTblock part;
00195     <span class="keyword">struct </span>bFSHDblock fshd;
00196     <span class="keyword">struct </span>bLSEGblock lseg;
00197     <span class="keywordtype">long</span> next;
00198     <span class="keyword">struct </span>List *vList, *listRoot;
00199     <span class="keywordtype">int</span> i;
00200     <span class="keyword">struct </span>Volume* vol;
00201     <span class="keywordtype">int</span> len;
00202 
00203     <span class="keywordflow">if</span> (adfReadRDSKblock( dev, &amp;rdsk )!=RC_OK)
00204         <span class="keywordflow">return</span> RC_ERROR;
00205 
00206     dev-&gt;cylinders = rdsk.cylinders;
00207     dev-&gt;heads = rdsk.heads;
00208     dev-&gt;sectors = rdsk.sectors;
00209 
00210     <span class="comment">/* PART blocks */</span>
00211     listRoot = NULL;
00212     next = rdsk.partitionList;
00213     dev-&gt;nVol=0;
00214     vList = NULL;
00215     <span class="keywordflow">while</span>( next!=-1 ) {
00216         <span class="keywordflow">if</span> (adfReadPARTblock( dev, next, &amp;part )!=RC_OK) {
00217             adfFreeTmpVolList(listRoot);
00218             (*adfEnv.eFct)(<span class="stringliteral">"adfMountHd : malloc"</span>);
00219             <span class="keywordflow">return</span> RC_ERROR;
00220         }
00221 
00222         vol=(<span class="keyword">struct </span>Volume*)malloc(sizeof(struct Volume));
00223         <span class="keywordflow">if</span> (!vol) {
00224             adfFreeTmpVolList(listRoot);
00225             (*adfEnv.eFct)(<span class="stringliteral">"adfMountHd : malloc"</span>);
00226             <span class="keywordflow">return</span> RC_ERROR;
00227         }
00228         vol-&gt;volName=NULL;
00229         dev-&gt;nVol++;
00230 
00231         vol-&gt;firstBlock = rdsk.cylBlocks * part.lowCyl;
00232         vol-&gt;lastBlock = (part.highCyl+1)*rdsk.cylBlocks -1 ;
00233         vol-&gt;rootBlock = (vol-&gt;lastBlock - vol-&gt;firstBlock+1)/2;
00234         vol-&gt;blockSize = part.blockSize*4;
00235 
00236         len = min(31, part.nameLen);
00237         vol-&gt;volName = (<span class="keywordtype">char</span>*)malloc(len+1);
00238         <span class="keywordflow">if</span> (!vol-&gt;volName) { 
00239             adfFreeTmpVolList(listRoot);
00240             (*adfEnv.eFct)(<span class="stringliteral">"adfMount : malloc"</span>);
00241             <span class="keywordflow">return</span> RC_ERROR;
00242         }
00243         memcpy(vol-&gt;volName,part.name,len);
00244         vol-&gt;volName[len] = <span class="charliteral">'\0'</span>;
00245 
00246         vol-&gt;mounted = FALSE;
00247 
00248         <span class="comment">/* stores temporaly the volumes in a linked list */</span>
00249         <span class="keywordflow">if</span> (listRoot==NULL)
00250             vList = listRoot = newCell(NULL, (<span class="keywordtype">void</span>*)vol);
00251         <span class="keywordflow">else</span>
00252             vList = newCell(vList, (<span class="keywordtype">void</span>*)vol);
00253 
00254         <span class="keywordflow">if</span> (vList==NULL) {
00255             adfFreeTmpVolList(listRoot);
00256             (*adfEnv.eFct)(<span class="stringliteral">"adfMount : newCell() malloc"</span>);
00257             <span class="keywordflow">return</span> RC_ERROR;
00258         }
00259 
00260         next = part.next;
00261     }
00262 
00263     <span class="comment">/* stores the list in an array */</span>
00264     dev-&gt;volList = (<span class="keyword">struct </span>Volume**)malloc(sizeof(struct Volume*) * dev-&gt;nVol);
00265     <span class="keywordflow">if</span> (!dev-&gt;volList) { 
00266         adfFreeTmpVolList(listRoot);
00267         (*adfEnv.eFct)(<span class="stringliteral">"adfMount : unknown device type"</span>);
00268         <span class="keywordflow">return</span> RC_ERROR;
00269     }
00270     vList = listRoot;
00271     <span class="keywordflow">for</span>(i=0; i&lt;dev-&gt;nVol; i++) {
00272         dev-&gt;volList[i]=(<span class="keyword">struct </span>Volume*)vList-&gt;content;
00273         vList = vList-&gt;next;
00274     }
00275     freeList(listRoot);
00276 
00277     next = rdsk.fileSysHdrList;
00278     <span class="keywordflow">while</span>( next!=-1 ) {
00279         <span class="keywordflow">if</span> (adfReadFSHDblock( dev, next, &amp;fshd )!=RC_OK) {
00280             <span class="keywordflow">for</span>(i=0;i&lt;dev-&gt;nVol;i++) free(dev-&gt;volList[i]);
00281             free(dev-&gt;volList);
00282             (*adfEnv.eFct)(<span class="stringliteral">"adfMount : adfReadFSHDblock"</span>);
00283             <span class="keywordflow">return</span> RC_ERROR;
00284         }
00285         next = fshd.next;
00286     }
00287 
00288     next = fshd.segListBlock;
00289     <span class="keywordflow">while</span>( next!=-1 ) {
00290         <span class="keywordflow">if</span> (adfReadLSEGblock( dev, next, &amp;lseg )!=RC_OK) {
00291             (*adfEnv.wFct)(<span class="stringliteral">"adfMount : adfReadLSEGblock"</span>);
00292         }
00293         next = lseg.next;
00294     }
00295 
00296     <span class="keywordflow">return</span> RC_OK;
00297 }
00298 
00299 
00300 <span class="comment">/*</span>
00301 <span class="comment"> * adfMountFlop</span>
00302 <span class="comment"> *</span>
00303 <span class="comment"> * normaly not used directly, called directly by adfMount()</span>
00304 <span class="comment"> *</span>
00305 <span class="comment"> * use dev-&gt;devType to choose between DD and HD</span>
00306 <span class="comment"> * fills geometry and the volume list with one volume</span>
00307 <span class="comment"> */</span>
00308 RETCODE adfMountFlop(<span class="keyword">struct</span> Device* dev)
00309 {
00310     <span class="keyword">struct </span>Volume *vol;
00311     <span class="keyword">struct </span>bRootBlock root;
00312     <span class="keywordtype">char</span> diskName[35];
00313     
00314     dev-&gt;cylinders = 80;
00315     dev-&gt;heads = 2;
00316     <span class="keywordflow">if</span> (dev-&gt;devType==DEVTYPE_FLOPDD)
00317         dev-&gt;sectors = 11;
00318     <span class="keywordflow">else</span> 
00319         dev-&gt;sectors = 22;
00320 
00321     vol=(<span class="keyword">struct </span>Volume*)malloc(sizeof(struct Volume));
00322     <span class="keywordflow">if</span> (!vol) { 
00323         (*adfEnv.eFct)(<span class="stringliteral">"adfMount : malloc"</span>);
00324         <span class="keywordflow">return</span> RC_ERROR;
00325     }
00326 
00327     vol-&gt;mounted = TRUE;
00328     vol-&gt;firstBlock = 0;
00329     vol-&gt;lastBlock =(dev-&gt;cylinders * dev-&gt;heads * dev-&gt;sectors)-1;
00330     vol-&gt;rootBlock = (vol-&gt;lastBlock+1 - vol-&gt;firstBlock)/2;
00331     vol-&gt;blockSize = 512;
00332     vol-&gt;dev = dev;
00333  
00334     <span class="keywordflow">if</span> (adfReadRootBlock(vol, vol-&gt;rootBlock, &amp;root)!=RC_OK)
00335         <span class="keywordflow">return</span> RC_ERROR;
00336     memset(diskName, 0, 35);
00337     memcpy(diskName, root.diskName, root.nameLen);
00338 
00339     vol-&gt;volName = strdup(diskName);
00340     
00341     dev-&gt;volList =(<span class="keyword">struct </span>Volume**) malloc(sizeof(struct Volume*));
00342     <span class="keywordflow">if</span> (!dev-&gt;volList) {
00343         free(vol);
00344         (*adfEnv.eFct)(<span class="stringliteral">"adfMount : malloc"</span>);
00345         <span class="keywordflow">return</span> RC_ERROR;
00346     }
00347     dev-&gt;volList[0] = vol;
00348     dev-&gt;nVol = 1;
00349 
00350 <span class="comment">/*printf("root=%d\n",vol-&gt;rootBlock);       */</span>
00351     <span class="keywordflow">return</span> RC_OK;
00352 }
00353 
00354 
00355 <span class="comment">/*</span>
00356 <span class="comment"> * adfMountDev</span>
00357 <span class="comment"> *</span>
00358 <span class="comment"> * mount a dump file (.adf) or a real device (uses adf_nativ.c and .h)</span>
00359 <span class="comment"> *</span>
00360 <span class="comment"> * adfInitDevice() must fill dev-&gt;size !</span>
00361 <span class="comment"> */</span>
00362 <span class="keyword">struct </span>Device* adfMountDev( char* filename, BOOL ro)
00363 {
00364     <span class="keyword">struct </span>Device* dev;
00365     <span class="keyword">struct </span>nativeFunctions *nFct;
00366     RETCODE rc;
00367     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[512];
00368 
00369     dev = (<span class="keyword">struct </span>Device*)malloc(sizeof(struct Device));
00370     <span class="keywordflow">if</span> (!dev) {
00371         (*adfEnv.eFct)(<span class="stringliteral">"adfMountDev : malloc error"</span>);
00372         <span class="keywordflow">return</span> NULL;
00373     }
00374 
00375     dev-&gt;readOnly = ro;
00376 
00377     <span class="comment">/* switch between dump files and real devices */</span>
00378     nFct = adfEnv.nativeFct;
00379     dev-&gt;isNativeDev = (*nFct-&gt;adfIsDevNative)(filename);
00380     <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00381         rc = (*nFct-&gt;adfInitDevice)(dev, filename,ro);
00382     <span class="keywordflow">else</span>
00383         rc = adfInitDumpDevice(dev,filename,ro);
00384     <span class="keywordflow">if</span> (rc!=RC_OK) {
00385         free(dev); <span class="keywordflow">return</span>(NULL);
00386     }
00387 
00388     dev-&gt;devType = adfDevType(dev);
00389 
00390     <span class="keywordflow">switch</span>( dev-&gt;devType ) {
00391 
00392     <span class="keywordflow">case</span> DEVTYPE_FLOPDD:
00393     <span class="keywordflow">case</span> DEVTYPE_FLOPHD:
00394         <span class="keywordflow">if</span> (adfMountFlop(dev)!=RC_OK) {
00395              <span class="keywordflow">if</span> (dev-&gt;isNativeDev)                  <span class="comment">/* BV */</span>
00396                  (*nFct-&gt;adfReleaseDevice)(dev);    <span class="comment">/* BV */</span>
00397              <span class="keywordflow">else</span>                                   <span class="comment">/* BV */</span>
00398                  adfReleaseDumpDevice(dev);         <span class="comment">/* BV */</span>       
00399             free(dev); <span class="keywordflow">return</span> NULL;
00400         }
00401         <span class="keywordflow">break</span>;
00402 
00403     <span class="keywordflow">case</span> DEVTYPE_HARDDISK:
00404         <span class="comment">/* to choose between hardfile or harddisk (real or dump) */</span>
00405         <span class="keywordflow">if</span> (dev-&gt;isNativeDev)                                   <span class="comment">/* BV ...from here*/</span>
00406             rc = (*nFct-&gt;adfNativeReadSector)(dev, 0, 512, buf);
00407         <span class="keywordflow">else</span>
00408             rc = adfReadDumpSector(dev, 0, 512, buf);
00409         <span class="keywordflow">if</span>( rc!=RC_OK ) {
00410              nFct = adfEnv.nativeFct;
00411              <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00412                  (*nFct-&gt;adfReleaseDevice)(dev);
00413              <span class="keywordflow">else</span>
00414                  adfReleaseDumpDevice(dev);            
00415             (*adfEnv.eFct)(<span class="stringliteral">"adfMountDev : adfReadDumpSector failed"</span>);
00416             free(dev); <span class="keywordflow">return</span> NULL;
00417         }
00418 
00419         <span class="comment">/* a file with the first three bytes equal to 'DOS' */</span>
00420         <span class="keywordflow">if</span> (!dev-&gt;isNativeDev &amp;&amp; strncmp(<span class="stringliteral">"DOS"</span>,buf,3)==0) {
00421             <span class="keywordflow">if</span> (adfMountHdFile(dev)!=RC_OK) {
00422                 <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00423                     (*nFct-&gt;adfReleaseDevice)(dev);
00424                 <span class="keywordflow">else</span>
00425                     adfReleaseDumpDevice(dev);            
00426                 free(dev); <span class="keywordflow">return</span> NULL;
00427             }
00428         }
00429         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (adfMountHd(dev)!=RC_OK) {
00430              <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00431                  (*nFct-&gt;adfReleaseDevice)(dev);
00432              <span class="keywordflow">else</span>
00433                  adfReleaseDumpDevice(dev);            
00434             free(dev); <span class="keywordflow">return</span> NULL;                             <span class="comment">/* BV ...to here.*/</span>
00435         }
00436         <span class="keywordflow">break</span>;
00437 
00438     <span class="keywordflow">default</span>:
00439         (*adfEnv.eFct)(<span class="stringliteral">"adfMountDev : unknown device type"</span>);
00440           <span class="keywordflow">if</span> (dev-&gt;isNativeDev)                                 <span class="comment">/* BV */</span>
00441               (*nFct-&gt;adfReleaseDevice)(dev);                   <span class="comment">/* BV */</span>
00442           <span class="keywordflow">else</span>                                                  <span class="comment">/* BV */</span>
00443               adfReleaseDumpDevice(dev);                        <span class="comment">/* BV */</span>
00444          free(dev); <span class="keywordflow">return</span> NULL;                                <span class="comment">/* BV */</span>
00445     }
00446 
00447     <span class="keywordflow">return</span> dev;
00448 }
00449 
00450 
00451 <span class="comment">/*</span>
00452 <span class="comment"> * adfCreateHdHeader</span>
00453 <span class="comment"> *</span>
00454 <span class="comment"> * create PARTIALLY the sectors of the header of one harddisk : can not be mounted</span>
00455 <span class="comment"> * back on a real Amiga ! It's because some device dependant values can't be guessed...</span>
00456 <span class="comment"> *</span>
00457 <span class="comment"> * do not use dev-&gt;volList[], but partList for partitions information : start and len are cylinders,</span>
00458 <span class="comment"> *  not blocks</span>
00459 <span class="comment"> * do not fill dev-&gt;volList[]</span>
00460 <span class="comment"> * called by adfCreateHd()</span>
00461 <span class="comment"> */</span>
00462 RETCODE adfCreateHdHeader(<span class="keyword">struct</span> Device* dev, <span class="keywordtype">int</span> n, <span class="keyword">struct</span> Partition** partList )
00463 {
00464     <span class="keywordtype">int</span> i;
00465     <span class="keyword">struct </span>bRDSKblock rdsk;
00466     <span class="keyword">struct </span>bPARTblock part;
00467     <span class="keyword">struct </span>bFSHDblock fshd;
00468     <span class="keyword">struct </span>bLSEGblock lseg;
00469     SECTNUM j;
00470     <span class="keywordtype">int</span> len;
00471 
00472 
00473     <span class="comment">/* RDSK */</span> 
00474  
00475     memset((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)&amp;rdsk,0,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bRDSKblock));
00476 
00477     rdsk.rdbBlockLo = 0;
00478     rdsk.rdbBlockHi = (dev-&gt;sectors*dev-&gt;heads*2)-1;
00479     rdsk.loCylinder = 2;
00480     rdsk.hiCylinder = dev-&gt;cylinders-1;
00481     rdsk.cylBlocks = dev-&gt;sectors*dev-&gt;heads;
00482 
00483     rdsk.cylinders = dev-&gt;cylinders;
00484     rdsk.sectors = dev-&gt;sectors;
00485     rdsk.heads = dev-&gt;heads;
00486     
00487     rdsk.badBlockList = -1;
00488     rdsk.partitionList = 1;
00489     rdsk.fileSysHdrList = 1 + dev-&gt;nVol;
00490     
00491     <span class="keywordflow">if</span> (adfWriteRDSKblock(dev, &amp;rdsk)!=RC_OK)
00492         <span class="keywordflow">return</span> RC_ERROR;
00493 
00494     <span class="comment">/* PART */</span>
00495 
00496     j=1;
00497     <span class="keywordflow">for</span>(i=0; i&lt;dev-&gt;nVol; i++) {
00498         memset(&amp;part, 0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bPARTblock));
00499 
00500         <span class="keywordflow">if</span> (i&lt;dev-&gt;nVol-1)
00501             part.next = j+1;
00502         <span class="keywordflow">else</span>
00503             part.next = -1;
00504 
00505         len = min(MAXNAMELEN,strlen(partList[i]-&gt;volName));
00506         part.nameLen = len;
00507         strncpy(part.name, partList[i]-&gt;volName, len);
00508 
00509         part.surfaces = dev-&gt;heads;
00510         part.blocksPerTrack = dev-&gt;sectors;
00511         part.lowCyl = partList[i]-&gt;startCyl;
00512         part.highCyl = partList[i]-&gt;startCyl + partList[i]-&gt;lenCyl -1;
00513         strncpy(part.dosType, <span class="stringliteral">"DOS"</span>, 3);
00514 
00515         part.dosType[3] = partList[i]-&gt;volType &amp; 0x01;
00516             
00517         <span class="keywordflow">if</span> (adfWritePARTblock(dev, j, &amp;part))
00518             <span class="keywordflow">return</span> RC_ERROR;
00519         j++;
00520     }
00521 
00522     <span class="comment">/* FSHD */</span>
00523 
00524     strncpy(fshd.dosType,<span class="stringliteral">"DOS"</span>,3);
00525     fshd.dosType[3] = partList[0]-&gt;volType;
00526     fshd.next = -1;
00527     fshd.segListBlock = j+1;
00528     <span class="keywordflow">if</span> (adfWriteFSHDblock(dev, j, &amp;fshd)!=RC_OK)
00529         <span class="keywordflow">return</span> RC_ERROR;
00530     j++;
00531     
00532     <span class="comment">/* LSEG */</span>
00533     lseg.next = -1;
00534     <span class="keywordflow">if</span> (adfWriteLSEGblock(dev, j, &amp;lseg)!=RC_OK)
00535         <span class="keywordflow">return</span> RC_ERROR;
00536 
00537     <span class="keywordflow">return</span> RC_OK;
00538 }
00539 
00540 
00541 <span class="comment">/*</span>
00542 <span class="comment"> * adfCreateFlop</span>
00543 <span class="comment"> *</span>
00544 <span class="comment"> * create a filesystem on a floppy device</span>
00545 <span class="comment"> * fills dev-&gt;volList[]</span>
00546 <span class="comment"> */</span>
00547 RETCODE adfCreateFlop(<span class="keyword">struct</span> Device* dev, <span class="keywordtype">char</span>* volName, <span class="keywordtype">int</span> volType )
00548 {
00549     <span class="keywordflow">if</span> (dev==NULL) {
00550         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateFlop : dev==NULL"</span>);
00551         <span class="keywordflow">return</span> RC_ERROR;
00552     }
00553     dev-&gt;volList =(<span class="keyword">struct </span>Volume**) malloc(sizeof(struct Volume*));
00554     <span class="keywordflow">if</span> (!dev-&gt;volList) { 
00555         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateFlop : unknown device type"</span>);
00556         <span class="keywordflow">return</span> RC_ERROR;
00557     }
00558     dev-&gt;volList[0] = adfCreateVol( dev, 0L, 80L, volName, volType );
00559     <span class="keywordflow">if</span> (dev-&gt;volList[0]==NULL) {
00560         free(dev-&gt;volList);
00561         <span class="keywordflow">return</span> RC_ERROR;
00562     }
00563     dev-&gt;nVol = 1;
00564     dev-&gt;volList[0]-&gt;blockSize = 512;
00565     <span class="keywordflow">if</span> (dev-&gt;sectors==11)
00566         dev-&gt;devType=DEVTYPE_FLOPDD;
00567     <span class="keywordflow">else</span>
00568         dev-&gt;devType=DEVTYPE_FLOPHD;
00569 
00570     <span class="keywordflow">return</span> RC_OK;
00571 }
00572 
00573 
00574 <span class="comment">/*</span>
00575 <span class="comment"> * adfCreateHd</span>
00576 <span class="comment"> *</span>
00577 <span class="comment"> * create a filesystem one an harddisk device (partitions==volumes, and the header)</span>
00578 <span class="comment"> *</span>
00579 <span class="comment"> * fills dev-&gt;volList[]</span>
00580 <span class="comment"> *</span>
00581 <span class="comment"> */</span>
00582 RETCODE adfCreateHd(<span class="keyword">struct</span> Device* dev, <span class="keywordtype">int</span> n, <span class="keyword">struct</span> Partition** partList )
00583 {
00584     <span class="keywordtype">int</span> i, j;
00585 
00586 <span class="comment">/*struct Volume *vol;*/</span>
00587 
00588     <span class="keywordflow">if</span> (dev==NULL || partList==NULL || n&lt;=0) {
00589         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateHd : illegal parameter(s)"</span>);
00590         <span class="keywordflow">return</span> RC_ERROR;
00591     }
00592 
00593     dev-&gt;volList =(<span class="keyword">struct </span>Volume**) malloc(sizeof(struct Volume*)*n);
00594     <span class="keywordflow">if</span> (!dev-&gt;volList) {
00595         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateFlop : malloc"</span>);
00596         <span class="keywordflow">return</span> RC_ERROR;
00597     }
00598     <span class="keywordflow">for</span>(i=0; i&lt;n; i++) {
00599         dev-&gt;volList[i] = adfCreateVol( dev, 
00600                     partList[i]-&gt;startCyl, 
00601                     partList[i]-&gt;lenCyl, 
00602                     partList[i]-&gt;volName, 
00603                     partList[i]-&gt;volType );
00604         <span class="keywordflow">if</span> (dev-&gt;volList[i]==NULL) {
00605            <span class="keywordflow">for</span>(j=0; j&lt;i; j++) {
00606                free( dev-&gt;volList[i] );
00607 <span class="comment">/* pas fini */</span>
00608            }
00609            free(dev-&gt;volList);
00610            (*adfEnv.eFct)(<span class="stringliteral">"adfCreateHd : adfCreateVol() fails"</span>);
00611         }
00612         dev-&gt;volList[i]-&gt;blockSize = 512;
00613     }
00614     dev-&gt;nVol = n;
00615 <span class="comment">/*</span>
00616 <span class="comment">vol=dev-&gt;volList[0];</span>
00617 <span class="comment">printf("0first=%ld last=%ld root=%ld\n",vol-&gt;firstBlock,</span>
00618 <span class="comment"> vol-&gt;lastBlock, vol-&gt;rootBlock);</span>
00619 <span class="comment">*/</span>
00620 
00621     <span class="keywordflow">if</span> (adfCreateHdHeader(dev, n, partList )!=RC_OK)
00622         <span class="keywordflow">return</span> RC_ERROR;
00623     <span class="keywordflow">return</span> RC_OK;
00624 }
00625 
00626 
00627 <span class="comment">/*</span>
00628 <span class="comment"> * adfUnMountDev</span>
00629 <span class="comment"> *</span>
00630 <span class="comment"> */</span>
00631 <span class="keywordtype">void</span> adfUnMountDev( <span class="keyword">struct</span> Device* dev)
00632 {
00633     <span class="keywordtype">int</span> i;
00634     <span class="keyword">struct </span>nativeFunctions *nFct;
00635 
00636     <span class="keywordflow">if</span> (dev==0)
00637        <span class="keywordflow">return</span>;
00638 
00639     <span class="keywordflow">for</span>(i=0; i&lt;dev-&gt;nVol; i++) {
00640         free(dev-&gt;volList[i]-&gt;volName);
00641         free(dev-&gt;volList[i]);
00642     }
00643     <span class="keywordflow">if</span> (dev-&gt;nVol&gt;0)
00644         free(dev-&gt;volList);
00645     dev-&gt;nVol = 0;
00646 
00647     nFct = adfEnv.nativeFct;
00648     <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00649         (*nFct-&gt;adfReleaseDevice)(dev);
00650     <span class="keywordflow">else</span>
00651         adfReleaseDumpDevice(dev);
00652 
00653     free(dev);
00654 }
00655 
00656 
00657 
00658 <span class="comment">/*</span>
00659 <span class="comment"> * ReadRDSKblock</span>
00660 <span class="comment"> *</span>
00661 <span class="comment"> */</span>
00662     RETCODE
00663 adfReadRDSKblock( <span class="keyword">struct</span> Device* dev, <span class="keyword">struct</span> bRDSKblock* blk )
00664 {
00665 
00666     UCHAR buf[256];
00667     <span class="keyword">struct </span>nativeFunctions *nFct;
00668     RETCODE rc2;
00669     RETCODE rc = RC_OK;
00670     
00671     nFct = adfEnv.nativeFct;
00672     <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00673         rc2 =(*nFct-&gt;adfNativeReadSector)(dev, 0, 256, buf);
00674     <span class="keywordflow">else</span>
00675         rc2 = adfReadDumpSector(dev, 0, 256, buf);
00676 
00677     <span class="keywordflow">if</span> (rc2!=RC_OK)
00678        <span class="keywordflow">return</span>(RC_ERROR);
00679 
00680     memcpy(blk, buf, 256);
00681 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00682 <span class="preprocessor"></span>    <span class="comment">/* big to little = 68000 to x86 */</span>
00683     swapEndian((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)blk, SWBL_RDSK);
00684 <span class="preprocessor">#endif</span>
00685 <span class="preprocessor"></span>
00686     <span class="keywordflow">if</span> ( strncmp(blk-&gt;id,<span class="stringliteral">"RDSK"</span>,4)!=0 ) {
00687         (*adfEnv.eFct)(<span class="stringliteral">"ReadRDSKblock : RDSK id not found"</span>);
00688         <span class="keywordflow">return</span> RC_ERROR;
00689     }
00690 
00691     <span class="keywordflow">if</span> ( blk-&gt;size != 64 )
00692         (*adfEnv.wFct)(<span class="stringliteral">"ReadRDSKBlock : size != 64"</span>);               <span class="comment">/* BV */</span>
00693 
00694     <span class="keywordflow">if</span> ( blk-&gt;checksum != adfNormalSum(buf,8,256) ) {
00695          (*adfEnv.wFct)(<span class="stringliteral">"ReadRDSKBlock : incorrect checksum"</span>);
00696          <span class="comment">/* BV FIX: Due to malicious Win98 write to sector</span>
00697 <span class="comment">         rc|=RC_BLOCKSUM;*/</span>
00698     }
00699     
00700     <span class="keywordflow">if</span> ( blk-&gt;blockSize != 512 )
00701          (*adfEnv.wFct)(<span class="stringliteral">"ReadRDSKBlock : blockSize != 512"</span>);        <span class="comment">/* BV */</span>
00702 
00703     <span class="keywordflow">if</span> ( blk-&gt;cylBlocks !=  blk-&gt;sectors*blk-&gt;heads )
00704         (*adfEnv.wFct)( <span class="stringliteral">"ReadRDSKBlock : cylBlocks != sectors*heads"</span>);
00705 
00706     <span class="keywordflow">return</span> rc;
00707 }
00708 
00709 
00710 <span class="comment">/*</span>
00711 <span class="comment"> * adfWriteRDSKblock</span>
00712 <span class="comment"> *</span>
00713 <span class="comment"> */</span>
00714     RETCODE
00715 adfWriteRDSKblock(<span class="keyword">struct</span> Device *dev, <span class="keyword">struct</span> bRDSKblock* rdsk)
00716 {
00717     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[LOGICAL_BLOCK_SIZE];
00718     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00719     <span class="keyword">struct </span>nativeFunctions *nFct;
00720     RETCODE rc2, rc = RC_OK;
00721 
00722     <span class="keywordflow">if</span> (dev-&gt;readOnly) {
00723         (*adfEnv.wFct)(<span class="stringliteral">"adfWriteRDSKblock : can't write block, read only device"</span>);
00724         <span class="keywordflow">return</span> RC_ERROR;
00725     }
00726 
00727     memset(buf,0,LOGICAL_BLOCK_SIZE);
00728 
00729     strncpy(rdsk-&gt;id,<span class="stringliteral">"RDSK"</span>,4);
00730     rdsk-&gt;size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>bRDSKblock)/sizeof(long);
00731     rdsk-&gt;blockSize = LOGICAL_BLOCK_SIZE;
00732     rdsk-&gt;badBlockList = -1;
00733 
00734     strncpy(rdsk-&gt;diskVendor,<span class="stringliteral">"ADFlib  "</span>,8);
00735     strncpy(rdsk-&gt;diskProduct,<span class="stringliteral">"harddisk.adf    "</span>,16);
00736     strncpy(rdsk-&gt;diskRevision,<span class="stringliteral">"v1.0"</span>,4);
00737 
00738     memcpy(buf, rdsk, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bRDSKblock));
00739 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00740 <span class="preprocessor"></span>    swapEndian(buf, SWBL_RDSK);
00741 <span class="preprocessor">#endif</span>
00742 <span class="preprocessor"></span>
00743     newSum = adfNormalSum(buf, 8, LOGICAL_BLOCK_SIZE);
00744     swLong(buf+8, newSum);
00745 
00746     nFct = adfEnv.nativeFct;
00747     <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00748         rc2=(*nFct-&gt;adfNativeWriteSector)(dev, 0, LOGICAL_BLOCK_SIZE, buf);
00749     <span class="keywordflow">else</span>
00750         rc2=adfWriteDumpSector(dev, 0, LOGICAL_BLOCK_SIZE, buf);
00751 
00752     <span class="keywordflow">if</span> (rc2!=RC_OK)
00753        <span class="keywordflow">return</span> RC_ERROR;
00754 
00755     <span class="keywordflow">return</span> rc;
00756 }
00757 
00758 
00759 <span class="comment">/*</span>
00760 <span class="comment"> * ReadPARTblock</span>
00761 <span class="comment"> *</span>
00762 <span class="comment"> */</span>
00763     RETCODE
00764 adfReadPARTblock( <span class="keyword">struct</span> Device* dev, <span class="keywordtype">long</span> nSect, <span class="keyword">struct</span> bPARTblock* blk )
00765 {
00766     UCHAR buf[ <span class="keyword">sizeof</span>(<span class="keyword">struct </span>bPARTblock) ];
00767     <span class="keyword">struct </span>nativeFunctions *nFct;
00768     RETCODE rc2, rc = RC_OK;
00769     
00770     nFct = adfEnv.nativeFct;
00771     <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00772         rc2=(*nFct-&gt;adfNativeReadSector)(dev, nSect, <span class="keyword">sizeof</span>(<span class="keyword">struct </span>bPARTblock), buf);
00773     <span class="keywordflow">else</span>
00774         rc2=adfReadDumpSector(dev, nSect, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bPARTblock), buf);
00775 
00776     <span class="keywordflow">if</span> (rc2!=RC_OK)
00777        <span class="keywordflow">return</span> RC_ERROR;
00778 
00779     memcpy(blk, buf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bPARTblock));
00780 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00781 <span class="preprocessor"></span>    <span class="comment">/* big to little = 68000 to x86 */</span>
00782     swapEndian((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)blk, SWBL_PART);
00783 <span class="preprocessor">#endif</span>
00784 <span class="preprocessor"></span>
00785     <span class="keywordflow">if</span> ( strncmp(blk-&gt;id,<span class="stringliteral">"PART"</span>,4)!=0 ) {
00786         (*adfEnv.eFct)(<span class="stringliteral">"ReadPARTblock : PART id not found"</span>);
00787         <span class="keywordflow">return</span> RC_ERROR;
00788     }
00789 
00790     <span class="keywordflow">if</span> ( blk-&gt;size != 64 )
00791         (*adfEnv.wFct)(<span class="stringliteral">"ReadPARTBlock : size != 64"</span>);
00792 
00793     <span class="keywordflow">if</span> ( blk-&gt;blockSize!=128 ) {
00794         (*adfEnv.eFct)(<span class="stringliteral">"ReadPARTblock : blockSize!=512, not supported (yet)"</span>);
00795         <span class="keywordflow">return</span> RC_ERROR;
00796     }
00797 
00798     <span class="keywordflow">if</span> ( blk-&gt;checksum != adfNormalSum(buf,8,256) )
00799         (*adfEnv.wFct)( <span class="stringliteral">"ReadPARTBlock : incorrect checksum"</span>);
00800 
00801     <span class="keywordflow">return</span> rc;
00802 }
00803 
00804 
00805 <span class="comment">/*</span>
00806 <span class="comment"> * adfWritePARTblock</span>
00807 <span class="comment"> *</span>
00808 <span class="comment"> */</span>
00809     RETCODE
00810 adfWritePARTblock(<span class="keyword">struct</span> Device *dev, <span class="keywordtype">long</span> nSect, <span class="keyword">struct</span> bPARTblock* part)
00811 {
00812     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[LOGICAL_BLOCK_SIZE];
00813     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00814     <span class="keyword">struct </span>nativeFunctions *nFct;
00815     RETCODE rc2, rc = RC_OK;
00816     
00817     <span class="keywordflow">if</span> (dev-&gt;readOnly) {
00818         (*adfEnv.wFct)(<span class="stringliteral">"adfWritePARTblock : can't write block, read only device"</span>);
00819         <span class="keywordflow">return</span> RC_ERROR;
00820     }
00821 
00822     memset(buf,0,LOGICAL_BLOCK_SIZE);
00823 
00824     strncpy(part-&gt;id,<span class="stringliteral">"PART"</span>,4);
00825     part-&gt;size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>bPARTblock)/sizeof(long);
00826     part-&gt;blockSize = LOGICAL_BLOCK_SIZE;
00827     part-&gt;vectorSize = 16;
00828     part-&gt;blockSize = 128;
00829     part-&gt;sectorsPerBlock = 1;
00830     part-&gt;dosReserved = 2;
00831 
00832     memcpy(buf, part, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bPARTblock));
00833 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00834 <span class="preprocessor"></span>    swapEndian(buf, SWBL_PART);
00835 <span class="preprocessor">#endif</span>
00836 <span class="preprocessor"></span>
00837     newSum = adfNormalSum(buf, 8, LOGICAL_BLOCK_SIZE);
00838     swLong(buf+8, newSum);
00839 <span class="comment">/*    *(long*)(buf+8) = swapLong((unsigned char*)&amp;newSum);*/</span>
00840 
00841     nFct = adfEnv.nativeFct;
00842     <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00843         rc2=(*nFct-&gt;adfNativeWriteSector)(dev, nSect, LOGICAL_BLOCK_SIZE, buf);
00844     <span class="keywordflow">else</span>
00845         rc2=adfWriteDumpSector(dev, nSect, LOGICAL_BLOCK_SIZE, buf);
00846     <span class="keywordflow">if</span> (rc2!=RC_OK)
00847         <span class="keywordflow">return</span> RC_ERROR;
00848 
00849     <span class="keywordflow">return</span> rc;
00850 }
00851 
00852 <span class="comment">/*</span>
00853 <span class="comment"> * ReadFSHDblock</span>
00854 <span class="comment"> *</span>
00855 <span class="comment"> */</span>
00856     RETCODE
00857 adfReadFSHDblock( <span class="keyword">struct</span> Device* dev, <span class="keywordtype">long</span> nSect, <span class="keyword">struct</span> bFSHDblock* blk)
00858 {
00859     UCHAR buf[<span class="keyword">sizeof</span>(<span class="keyword">struct </span>bFSHDblock)];
00860     <span class="keyword">struct </span>nativeFunctions *nFct;
00861     RETCODE rc;
00862     
00863     nFct = adfEnv.nativeFct;
00864     <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00865         rc = (*nFct-&gt;adfNativeReadSector)(dev, nSect, <span class="keyword">sizeof</span>(<span class="keyword">struct </span>bFSHDblock), buf);
00866     <span class="keywordflow">else</span>
00867         rc = adfReadDumpSector(dev, nSect, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bFSHDblock), buf);
00868     <span class="keywordflow">if</span> (rc!=RC_OK)
00869         <span class="keywordflow">return</span> RC_ERROR;
00870         
00871     memcpy(blk, buf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bFSHDblock));
00872 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00873 <span class="preprocessor"></span>    <span class="comment">/* big to little = 68000 to x86 */</span>
00874     swapEndian((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)blk, SWBL_FSHD);
00875 <span class="preprocessor">#endif</span>
00876 <span class="preprocessor"></span>
00877     <span class="keywordflow">if</span> ( strncmp(blk-&gt;id,<span class="stringliteral">"FSHD"</span>,4)!=0 ) {
00878         (*adfEnv.eFct)(<span class="stringliteral">"ReadFSHDblock : FSHD id not found"</span>);
00879         <span class="keywordflow">return</span> RC_ERROR;
00880     }
00881 
00882     <span class="keywordflow">if</span> ( blk-&gt;size != 64 )
00883          (*adfEnv.wFct)(<span class="stringliteral">"ReadFSHDblock : size != 64"</span>);
00884 
00885     <span class="keywordflow">if</span> ( blk-&gt;checksum != adfNormalSum(buf,8,256) )
00886         (*adfEnv.wFct)( <span class="stringliteral">"ReadFSHDblock : incorrect checksum"</span>);
00887 
00888     <span class="keywordflow">return</span> RC_OK;
00889 }
00890 
00891 
00892 <span class="comment">/*</span>
00893 <span class="comment"> *  adfWriteFSHDblock</span>
00894 <span class="comment"> *</span>
00895 <span class="comment"> */</span>
00896     RETCODE
00897 adfWriteFSHDblock(<span class="keyword">struct</span> Device *dev, <span class="keywordtype">long</span> nSect, <span class="keyword">struct</span> bFSHDblock* fshd)
00898 {
00899     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[LOGICAL_BLOCK_SIZE];
00900     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00901     <span class="keyword">struct </span>nativeFunctions *nFct;
00902     RETCODE rc = RC_OK;
00903 
00904     <span class="keywordflow">if</span> (dev-&gt;readOnly) {
00905         (*adfEnv.wFct)(<span class="stringliteral">"adfWriteFSHDblock : can't write block, read only device"</span>);
00906         <span class="keywordflow">return</span> RC_ERROR;
00907     }
00908 
00909     memset(buf,0,LOGICAL_BLOCK_SIZE);
00910 
00911     strncpy(fshd-&gt;id,<span class="stringliteral">"FSHD"</span>,4);
00912     fshd-&gt;size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>bFSHDblock)/sizeof(long);
00913 
00914     memcpy(buf, fshd, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bFSHDblock));
00915 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00916 <span class="preprocessor"></span>    swapEndian(buf, SWBL_FSHD);
00917 <span class="preprocessor">#endif</span>
00918 <span class="preprocessor"></span>
00919     newSum = adfNormalSum(buf, 8, LOGICAL_BLOCK_SIZE);
00920     swLong(buf+8, newSum);
00921 <span class="comment">/*    *(long*)(buf+8) = swapLong((unsigned char*)&amp;newSum);*/</span>
00922 
00923     nFct = adfEnv.nativeFct;
00924     <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00925         rc=(*nFct-&gt;adfNativeWriteSector)(dev, nSect, LOGICAL_BLOCK_SIZE, buf);
00926     <span class="keywordflow">else</span>
00927         rc=adfWriteDumpSector(dev, nSect, LOGICAL_BLOCK_SIZE, buf);
00928     <span class="keywordflow">if</span> (rc!=RC_OK)
00929         <span class="keywordflow">return</span> RC_ERROR;
00930 
00931     <span class="keywordflow">return</span> RC_OK;
00932 }
00933 
00934 
00935 <span class="comment">/*</span>
00936 <span class="comment"> * ReadLSEGblock</span>
00937 <span class="comment"> *</span>
00938 <span class="comment"> */</span>
00939    RETCODE
00940 adfReadLSEGblock(<span class="keyword">struct</span> Device* dev, <span class="keywordtype">long</span> nSect, <span class="keyword">struct</span> bLSEGblock* blk)
00941 {
00942     UCHAR buf[<span class="keyword">sizeof</span>(<span class="keyword">struct </span>bLSEGblock)];
00943     <span class="keyword">struct </span>nativeFunctions *nFct;
00944     RETCODE rc;
00945     
00946     nFct = adfEnv.nativeFct;
00947     <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
00948         rc=(*nFct-&gt;adfNativeReadSector)(dev, nSect, <span class="keyword">sizeof</span>(<span class="keyword">struct </span>bLSEGblock), buf);
00949     <span class="keywordflow">else</span>
00950         rc=adfReadDumpSector(dev, nSect, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bLSEGblock), buf);
00951     <span class="keywordflow">if</span> (rc!=RC_OK)
00952         <span class="keywordflow">return</span> RC_ERROR;
00953         
00954     memcpy(blk, buf, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bLSEGblock));
00955 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00956 <span class="preprocessor"></span>    <span class="comment">/* big to little = 68000 to x86 */</span>
00957     swapEndian((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)blk, SWBL_LSEG);
00958 <span class="preprocessor">#endif</span>
00959 <span class="preprocessor"></span>
00960     <span class="keywordflow">if</span> ( strncmp(blk-&gt;id,<span class="stringliteral">"LSEG"</span>,4)!=0 ) {
00961         (*adfEnv.eFct)(<span class="stringliteral">"ReadLSEGblock : LSEG id not found"</span>);
00962         <span class="keywordflow">return</span> RC_ERROR;
00963     }
00964 
00965     <span class="keywordflow">if</span> ( blk-&gt;checksum != adfNormalSum(buf,8,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> bLSEGblock)) )
00966         (*adfEnv.wFct)(<span class="stringliteral">"ReadLSEGBlock : incorrect checksum"</span>);
00967 
00968     <span class="keywordflow">if</span> ( blk-&gt;next!=-1 &amp;&amp; blk-&gt;size != 128 )
00969         (*adfEnv.wFct)(<span class="stringliteral">"ReadLSEGBlock : size != 128"</span>);
00970 
00971     <span class="keywordflow">return</span> RC_OK;
00972 }
00973 
00974 
00975 <span class="comment">/*</span>
00976 <span class="comment"> * adfWriteLSEGblock</span>
00977 <span class="comment"> *</span>
00978 <span class="comment"> */</span>
00979     RETCODE
00980 adfWriteLSEGblock(<span class="keyword">struct</span> Device *dev, <span class="keywordtype">long</span> nSect, <span class="keyword">struct</span> bLSEGblock* lseg)
00981 {
00982     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[LOGICAL_BLOCK_SIZE];
00983     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00984     <span class="keyword">struct </span>nativeFunctions *nFct;
00985     RETCODE rc;
00986 
00987     <span class="keywordflow">if</span> (dev-&gt;readOnly) {
00988         (*adfEnv.wFct)(<span class="stringliteral">"adfWriteLSEGblock : can't write block, read only device"</span>);
00989         <span class="keywordflow">return</span> RC_ERROR;
00990     }
00991 
00992     memset(buf,0,LOGICAL_BLOCK_SIZE);
00993 
00994     strncpy(lseg-&gt;id,<span class="stringliteral">"LSEG"</span>,4);
00995     lseg-&gt;size = <span class="keyword">sizeof</span>(<span class="keyword">struct </span>bLSEGblock)/sizeof(long);
00996 
00997     memcpy(buf, lseg, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bLSEGblock));
00998 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00999 <span class="preprocessor"></span>    swapEndian(buf, SWBL_LSEG);
01000 <span class="preprocessor">#endif</span>
01001 <span class="preprocessor"></span>
01002     newSum = adfNormalSum(buf, 8, LOGICAL_BLOCK_SIZE);
01003     swLong(buf+8,newSum);
01004 <span class="comment">/*    *(long*)(buf+8) = swapLong((unsigned char*)&amp;newSum);*/</span>
01005 
01006     nFct = adfEnv.nativeFct;
01007     <span class="keywordflow">if</span> (dev-&gt;isNativeDev)
01008         rc=(*nFct-&gt;adfNativeWriteSector)(dev, nSect, LOGICAL_BLOCK_SIZE, buf);
01009     <span class="keywordflow">else</span>
01010         rc=adfWriteDumpSector(dev, nSect, LOGICAL_BLOCK_SIZE, buf);
01011 
01012     <span class="keywordflow">if</span> (rc!=RC_OK)
01013         <span class="keywordflow">return</span> RC_ERROR;
01014 
01015     <span class="keywordflow">return</span> RC_OK;
01016 }
01017 
01018 <span class="comment">/*##########################################################################*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:38 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

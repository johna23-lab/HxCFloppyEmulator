<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>adf_dump.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>adf_dump.c</h1><a href="adf__dump_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  ADF Library. (C) 1997-2002 Laurent Clevy</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> */</span>
00010 <span class="preprocessor">#include&lt;stdio.h&gt;</span>
00011 <span class="preprocessor">#include&lt;stdlib.h&gt;</span>
00012 <span class="preprocessor">#include&lt;errno.h&gt;</span>
00013 
00014 <span class="preprocessor">#include"adf_defs.h"</span>
00015 <span class="preprocessor">#include"adf_str.h"</span>
00016 <span class="preprocessor">#include"adf_disk.h"</span>
00017 <span class="preprocessor">#include"adf_nativ.h"</span>
00018 <span class="preprocessor">#include"adf_err.h"</span>
00019 
00020 <span class="keyword">extern</span> <span class="keyword">struct </span>Env adfEnv;
00021 
00022 <span class="comment">/*</span>
00023 <span class="comment"> * adfInitDumpDevice</span>
00024 <span class="comment"> *</span>
00025 <span class="comment"> */</span>
00026 RETCODE adfInitDumpDevice(<span class="keyword">struct</span> Device* dev, <span class="keywordtype">char</span>* name, BOOL ro)
00027 {
00028     <span class="keyword">struct </span>nativeDevice* nDev;
00029     <span class="keywordtype">long</span> size;
00030 
00031     nDev = (<span class="keyword">struct </span>nativeDevice*)dev-&gt;nativeDev;
00032 
00033     nDev = (<span class="keyword">struct </span>nativeDevice*)malloc(sizeof(struct nativeDevice));
00034     <span class="keywordflow">if</span> (!nDev) {
00035         (*adfEnv.eFct)(<span class="stringliteral">"adfInitDumpDevice : malloc"</span>);
00036         <span class="keywordflow">return</span> RC_MALLOC;
00037     }
00038     dev-&gt;nativeDev = nDev;
00039 
00040     dev-&gt;readOnly = ro;
00041     errno = 0;
00042     <span class="keywordflow">if</span> (!ro) {
00043         nDev-&gt;fd = fopen(name,<span class="stringliteral">"rb+"</span>);
00044         <span class="comment">/* force read only */</span>
00045         <span class="keywordflow">if</span> (!nDev-&gt;fd &amp;&amp; (errno==EACCES || errno==EROFS) ) {
00046             nDev-&gt;fd = fopen(name,<span class="stringliteral">"rb"</span>);
00047             dev-&gt;readOnly = TRUE;
00048             <span class="keywordflow">if</span> (nDev-&gt;fd)
00049                 (*adfEnv.wFct)(<span class="stringliteral">"myInitDevice : fopen, read-only mode forced"</span>);
00050         }
00051     }
00052     <span class="keywordflow">else</span>
00053         <span class="comment">/* read only requested */</span>
00054         nDev-&gt;fd = fopen(name,<span class="stringliteral">"rb"</span>);
00055 
00056     <span class="keywordflow">if</span> (!nDev-&gt;fd) {
00057         free(nDev);
00058         (*adfEnv.eFct)(<span class="stringliteral">"myInitDevice : fopen"</span>);
00059         <span class="keywordflow">return</span> RC_ERROR;
00060     }
00061 
00062     <span class="comment">/* determines size */</span>
00063     fseek(nDev-&gt;fd, 0, SEEK_END);
00064     size = ftell(nDev-&gt;fd);
00065     fseek(nDev-&gt;fd, 0, SEEK_SET);
00066 
00067     dev-&gt;size = size;
00068     
00069     <span class="keywordflow">return</span> RC_OK;
00070 }
00071 
00072 
00073 <span class="comment">/*</span>
00074 <span class="comment"> * adfReadDumpSector</span>
00075 <span class="comment"> *</span>
00076 <span class="comment"> */</span>
00077 RETCODE adfReadDumpSector(<span class="keyword">struct</span> Device *dev, <span class="keywordtype">long</span> n, <span class="keywordtype">int</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf)
00078 {
00079     <span class="keyword">struct </span>nativeDevice* nDev;
00080     <span class="keywordtype">int</span> r;
00081 <span class="comment">/*puts("adfReadDumpSector");*/</span>
00082     nDev = (<span class="keyword">struct </span>nativeDevice*)dev-&gt;nativeDev;
00083     r = fseek(nDev-&gt;fd, 512*n, SEEK_SET);
00084 <span class="comment">/*printf("nnn=%ld size=%d\n",n,size);*/</span>
00085     <span class="keywordflow">if</span> (r==-1)
00086         <span class="keywordflow">return</span> RC_ERROR;
00087 <span class="comment">/*puts("123");*/</span>
00088     <span class="keywordflow">if</span> ((r=fread(buf, 1, size, nDev-&gt;fd))!=size) {
00089 <span class="comment">/*printf("rr=%d\n",r);*/</span>
00090         <span class="keywordflow">return</span> RC_ERROR;
00091 }
00092 <span class="comment">/*puts("1234");*/</span>
00093 
00094     <span class="keywordflow">return</span> RC_OK;
00095 }
00096 
00097 
00098 <span class="comment">/*</span>
00099 <span class="comment"> * adfWriteDumpSector</span>
00100 <span class="comment"> *</span>
00101 <span class="comment"> */</span>
00102 RETCODE adfWriteDumpSector(<span class="keyword">struct</span> Device *dev, <span class="keywordtype">long</span> n, <span class="keywordtype">int</span> size, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf)
00103 {
00104     <span class="keyword">struct </span>nativeDevice* nDev;
00105     <span class="keywordtype">int</span> r;
00106 
00107     nDev = (<span class="keyword">struct </span>nativeDevice*)dev-&gt;nativeDev;
00108 
00109     r=fseek(nDev-&gt;fd, 512*n, SEEK_SET);
00110     <span class="keywordflow">if</span> (r==-1)
00111         <span class="keywordflow">return</span> RC_ERROR;
00112 
00113     <span class="keywordflow">if</span> ( fwrite(buf, 1, size, nDev-&gt;fd)!=(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(size) )
00114         <span class="keywordflow">return</span> RC_ERROR;
00115 <span class="comment">/*puts("adfWriteDumpSector");*/</span>
00116     <span class="keywordflow">return</span> RC_OK;
00117 }
00118 
00119 
00120 <span class="comment">/*</span>
00121 <span class="comment"> * adfReleaseDumpDevice</span>
00122 <span class="comment"> *</span>
00123 <span class="comment"> */</span>
00124 RETCODE adfReleaseDumpDevice(<span class="keyword">struct</span> Device *dev)
00125 {
00126     <span class="keyword">struct </span>nativeDevice* nDev;
00127 
00128     <span class="keywordflow">if</span> (!dev-&gt;nativeDev)
00129         <span class="keywordflow">return</span> RC_ERROR;
00130 
00131     nDev = (<span class="keyword">struct </span>nativeDevice*)dev-&gt;nativeDev;
00132     fclose(nDev-&gt;fd);
00133 
00134     free(nDev);
00135 
00136     <span class="keywordflow">return</span> RC_OK;
00137 }
00138 
00139 
00140 <span class="comment">/*</span>
00141 <span class="comment"> * adfCreateHdFile</span>
00142 <span class="comment"> *</span>
00143 <span class="comment"> */</span>
00144 RETCODE adfCreateHdFile(<span class="keyword">struct</span> Device* dev, <span class="keywordtype">char</span>* volName, <span class="keywordtype">int</span> volType)
00145 {
00146     
00147     <span class="keywordflow">if</span> (dev==NULL) {
00148         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateHdFile : dev==NULL"</span>);
00149         <span class="keywordflow">return</span> RC_ERROR;
00150     }
00151     dev-&gt;volList =(<span class="keyword">struct </span>Volume**) malloc(sizeof(struct Volume*));
00152     <span class="keywordflow">if</span> (!dev-&gt;volList) { 
00153                 (*adfEnv.eFct)(<span class="stringliteral">"adfCreateHdFile : unknown device type"</span>);
00154         <span class="keywordflow">return</span> RC_ERROR;
00155     }
00156 
00157     dev-&gt;volList[0] = adfCreateVol( dev, 0L, (<span class="keywordtype">long</span>)dev-&gt;cylinders, volName, volType );
00158     <span class="keywordflow">if</span> (dev-&gt;volList[0]==NULL) {
00159         free(dev-&gt;volList);
00160         <span class="keywordflow">return</span> RC_ERROR;
00161     }
00162 
00163     dev-&gt;nVol = 1;
00164     dev-&gt;devType = DEVTYPE_HARDFILE;
00165 
00166     <span class="keywordflow">return</span> RC_OK;
00167 }
00168 
00169 
00170 <span class="comment">/*</span>
00171 <span class="comment"> * adfCreateDumpDevice</span>
00172 <span class="comment"> *</span>
00173 <span class="comment"> * returns NULL if failed</span>
00174 <span class="comment"> */</span> 
00175     <span class="keyword">struct </span>Device*
00176 adfCreateDumpDevice(char* filename, long cylinders, long heads, long sectors)
00177 {
00178     <span class="keyword">struct </span>Device* dev;
00179     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[LOGICAL_BLOCK_SIZE];
00180     <span class="keyword">struct </span>nativeDevice* nDev;
00181 <span class="comment">/*    long i;*/</span>
00182     <span class="keywordtype">int</span> r;
00183     
00184     dev=(<span class="keyword">struct </span>Device*)malloc(sizeof(struct Device));
00185     <span class="keywordflow">if</span> (!dev) { 
00186         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateDumpDevice : malloc dev"</span>);
00187         <span class="keywordflow">return</span> NULL;
00188     }
00189     nDev = (<span class="keyword">struct </span>nativeDevice*)malloc(sizeof(struct nativeDevice));
00190     <span class="keywordflow">if</span> (!nDev) {
00191         free(dev); 
00192         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateDumpDevice : malloc nDev"</span>);
00193         <span class="keywordflow">return</span> NULL;
00194     }
00195     dev-&gt;nativeDev = nDev;
00196 
00197     nDev-&gt;fd = (FILE*)fopen(filename,<span class="stringliteral">"wb"</span>);
00198     <span class="keywordflow">if</span> (!nDev-&gt;fd) {
00199         free(nDev); free(dev);
00200         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateDumpDevice : fopen"</span>);
00201         <span class="keywordflow">return</span> NULL;
00202     }
00203 
00204 <span class="comment">/*    for(i=0; i&lt;cylinders*heads*sectors; i++)</span>
00205 <span class="comment">        fwrite(buf, sizeof(unsigned char), 512 , nDev-&gt;fd);</span>
00206 <span class="comment">*/</span>
00207     r=fseek(nDev-&gt;fd, ((cylinders*heads*sectors)-1)*LOGICAL_BLOCK_SIZE, SEEK_SET);
00208     <span class="keywordflow">if</span> (r==-1) {
00209         fclose(nDev-&gt;fd); free(nDev); free(dev);
00210         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateDumpDevice : fseek"</span>);
00211         <span class="keywordflow">return</span> NULL;
00212     }
00213 
00214     fwrite(buf, LOGICAL_BLOCK_SIZE, 1, nDev-&gt;fd);
00215 
00216     fclose(nDev-&gt;fd);
00217 
00218     nDev-&gt;fd=(FILE*)fopen(filename,<span class="stringliteral">"rb+"</span>);
00219     <span class="keywordflow">if</span> (!nDev-&gt;fd) {
00220         free(nDev); free(dev);
00221         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateDumpDevice : fopen"</span>);
00222         <span class="keywordflow">return</span> NULL;
00223     }
00224     dev-&gt;cylinders = cylinders;
00225     dev-&gt;heads = heads;
00226     dev-&gt;sectors = sectors;
00227     dev-&gt;size = cylinders*heads*sectors* LOGICAL_BLOCK_SIZE;    
00228 
00229     <span class="keywordflow">if</span> (dev-&gt;size==80*11*2*LOGICAL_BLOCK_SIZE)
00230         dev-&gt;devType = DEVTYPE_FLOPDD;
00231     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dev-&gt;size==80*22*2*LOGICAL_BLOCK_SIZE)
00232         dev-&gt;devType = DEVTYPE_FLOPHD;
00233     <span class="keywordflow">else</span>    
00234         dev-&gt;devType = DEVTYPE_HARDDISK;
00235         
00236     dev-&gt;nVol = 0;
00237     dev-&gt;isNativeDev = FALSE;
00238     dev-&gt;readOnly = FALSE;
00239 
00240     <span class="keywordflow">return</span>(dev);
00241 }
00242 
00243 <span class="comment">/*##################################################################################*/</span>
00244 
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:38 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

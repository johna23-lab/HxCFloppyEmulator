<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ChildCommon.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>ChildCommon.c</h1><a href="_child_common_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * ADF Opus Copyright 1998-2002 by </span>
00003 <span class="comment"> * Dan Sutherland &lt;dan@chromerhino.demon.co.uk&gt; and Gary Harris &lt;gharris@zip.com.au&gt;.   </span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> */</span>
00012 <span class="preprocessor">#include "Pch.h"</span>
00013 
00014 <span class="preprocessor">#include "ADFOpus.h"</span>
00015 <span class="preprocessor">#include "ChildCommon.h"</span>
00016 <span class="preprocessor">#include "ListView.h"</span>
00017 <span class="preprocessor">#include "Utils.h"</span>
00018 <span class="preprocessor">#include "VolSelect.h"</span>
00019 <span class="preprocessor">#include "Options.h"</span>
00020 <span class="preprocessor">#include &lt;direct.h&gt;</span>
00021 
00022     
00023 <span class="preprocessor">#include "ADFLib.h"</span>
00024 <span class="preprocessor">#include "ADF_err.h"</span> 
00025 
00026 <span class="comment">// For conversions.</span>
00027 <span class="preprocessor">#include "xDMS.h"</span>
00028 <span class="preprocessor">#include "BatchConvert.h"</span>
00029 <span class="preprocessor">#include "zLib.h"</span>
00030 
00031 
00032 <span class="keyword">extern</span> HIMAGELIST ghwndImageList;
00033 <span class="keyword">extern</span> HINSTANCE instance;
00034 <span class="keyword">extern</span> HWND ghwndFrame;
00035 <span class="keyword">extern</span> BOOL gbIsDragging;
00036 <span class="keyword">extern</span> HWND ghwndDragSource;
00037 <span class="keyword">extern</span> HWND ghwndSB;
00038 <span class="keyword">extern</span> HWND ghwndTB;
00039 <span class="keyword">extern</span> <span class="keywordtype">char</span> gstrFileName[MAX_PATH * 2];
00040 <span class="keyword">extern</span> BOOL ReadOnly;
00041 
00042 <span class="keyword">extern</span> HCURSOR ghcurNormal;
00043 <span class="keyword">extern</span> HCURSOR ghcurNo;
00044 
00045 <span class="keyword">extern</span> <span class="keywordtype">int</span> volToOpen;
00046 <span class="keyword">extern</span> <span class="keyword">struct </span>OPTIONS Options;
00047 
00048 BOOL    bClicked = FALSE;
00049 BOOL    bUndeleting = FALSE;
00050 
00052 <span class="keywordtype">long</span> newWinType;
00053 
00054 <span class="comment">/* local function prototypes */</span>
00055 LRESULT ChildOnCreate(HWND);
00056 BOOL ChildOnCommand(HWND, WPARAM, LPARAM);
00057 <span class="keywordtype">void</span> ChildOnPaint(HWND);
00058 <span class="keywordtype">void</span> ChildOnDestroy(HWND);
00059 BOOL ChildOnNotify(HWND, WPARAM, LPARAM);
00060 <span class="keywordtype">void</span> ChildOnSize(HWND);
00061 HWND CreateListView(HWND);
00062 <span class="keywordtype">void</span> ChildUpOneLevel(HWND);
00063 <span class="keywordtype">void</span> ChildSelectAll(HWND);
00064 <span class="keywordtype">void</span> ChildSelectNone(HWND);
00065 <span class="keywordtype">void</span> ChildInvertSelection(HWND);
00066 <span class="keywordtype">void</span> ChildUpdate(HWND);
00067 <span class="keywordtype">void</span> ChildClearContent(HWND);
00068 <span class="keywordtype">void</span> ChildDelete(HWND);
00069 BOOL ChildShowUndeletable(HWND);
00070 BOOL ChildUndelete(HWND);
00071 <span class="keywordtype">void</span> WinGetDir(HWND);
00072 BOOL WinAddFile(CHILDINFO *, WIN32_FIND_DATA *);
00073 <span class="keywordtype">void</span> AmiGetDir(HWND);
00074 <span class="keywordtype">void</span> AmiAddFile(CHILDINFO *, <span class="keyword">struct</span> List *);
00075 <span class="keywordtype">void</span> WinGetDrives(HWND);
00076 <span class="keywordtype">void</span> ChildSortDir(HWND, <span class="keywordtype">long</span>);
00077 <span class="keywordtype">void</span> SwapContent(DIRENTRY *, DIRENTRY *);
00078 BOOL ChildOnContextMenu(HWND, <span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
00079 <span class="keywordtype">void</span> DisplayContextMenu(HWND, POINT);
00080 BOOL ChildRename(HWND, LV_DISPINFO *);
00081 BOOL ChildCheckRename(HWND, LV_DISPINFO *);
00082 <span class="keywordtype">void</span> ChildMakeDir(HWND);
00083 BOOL RemoveDirectoryRecursive(<span class="keywordtype">char</span> *);
00084 BOOL RemoveAmiDirectoryRecursive(<span class="keyword">struct</span> Volume *, SECTNUM, <span class="keywordtype">char</span> *);
00085 
00086 <span class="comment">/***************************************************************************/</span>
00087 
<a name="l00088"></a><a class="code" href="_child_common_8c.html#a46">00088</a> HWND <a class="code" href="_child_common_8c.html#a46">CreateChildWin</a>(HWND client, <span class="keywordtype">long</span> type)
00091 {
00092     MDICREATESTRUCT mcs;
00093     <span class="keywordtype">char</span> title[MAX_PATH + 12];
00094 
00095     <span class="keywordflow">if</span> (type == CHILD_AMILISTER) {
00096         strcpy(title, gstrFileName);
00097         <span class="keywordflow">if</span> (ReadOnly)
00098             strcat(title, <span class="stringliteral">" [read-only]"</span>);
00099         volToOpen = -1;
00100         DialogBox(instance, MAKEINTRESOURCE(IDD_VOLSELECT), ghwndFrame, (DLGPROC)VolSelectProc);
00101         <span class="keywordflow">if</span> (volToOpen == -1)
00102             <span class="keywordflow">return</span> NULL;
00103     } <span class="keywordflow">else</span>
00104         strcpy(title, <span class="stringliteral">"Windows Directory"</span>);
00105 
00106     <span class="comment">/* Initialize the MDI create struct */</span>
00107     mcs.szClass = (type == CHILD_WINLISTER) ? WINLISTERCLASSNAME : AMILISTERCLASSNAME;
00108     mcs.szTitle = title;
00109     mcs.hOwner = instance;
00110     mcs.x = CW_USEDEFAULT;
00111     mcs.y = CW_USEDEFAULT;
00112     mcs.cx = CW_USEDEFAULT;
00113     mcs.cy = CW_USEDEFAULT;
00114     mcs.style = 0l;
00115     mcs.lParam  = 0l;
00116 
00117     newWinType = type;
00118 
00119     <span class="keywordflow">return</span> (HWND)SendMessage(client, WM_MDICREATE, 0, (LONG)(LPMDICREATESTRUCT)&amp;mcs);
00120 }
00121 
00122 LRESULT CALLBACK ChildWinProc(HWND win, UINT msg, WPARAM wp, LPARAM lp)
00123 {
00124     CHILDINFO *ci;
00125 
00126     <span class="keywordflow">switch</span>(msg)
00127     {
00128         <span class="keywordflow">case</span> WM_CREATE:
00129             <span class="keywordflow">return</span> ChildOnCreate(win);
00130             <span class="keywordflow">break</span>;
00131         <span class="keywordflow">case</span> WM_MDIACTIVATE:
00132             ci = (CHILDINFO *)GetWindowLong(win, 0);
00133             SetFocus(ci-&gt;lv);
00134             UpdateToolbar();
00135             bClicked = FALSE;                   <span class="comment">// Reset the Properties context menu item.</span>
00136             <span class="keywordflow">break</span>;
00137         <span class="keywordflow">case</span> WM_COMMAND:
00138             ChildOnCommand(win, wp, lp);
00139             <span class="keywordflow">break</span>;
00140         <span class="keywordflow">case</span> WM_PAINT:
00141             ChildOnPaint(win);
00142             <span class="keywordflow">break</span>;
00143         <span class="keywordflow">case</span> WM_NOTIFY:
00144             ChildOnNotify(win, wp, lp);
00145             <span class="keywordflow">break</span>;
00146         <span class="keywordflow">case</span> WM_DESTROY:
00147             ChildOnDestroy(win);
00148             <span class="keywordflow">break</span>;
00149         <span class="keywordflow">case</span> WM_CONTEXTMENU:
00150             <span class="keywordflow">if</span> (! ChildOnContextMenu(win, LOWORD(lp), HIWORD(lp)))
00151                 <span class="keywordflow">return</span> DefMDIChildProc(win, msg, wp, lp);
00152             <span class="keywordflow">break</span>;
00153         <span class="keywordflow">case</span> WM_NCDESTROY:
00154             UpdateToolbar();
00155         <span class="keywordflow">case</span> WM_SIZE:
00156             ChildOnSize(win);
00157             <span class="comment">/* must fall though to DefMDIChildProc */</span>
00158         <span class="keywordflow">default</span>:
00159             <span class="keywordflow">return</span>(DefMDIChildProc(win, msg, wp, lp));
00160     }
00161     <span class="keywordflow">return</span> 0l;
00162 }
00163 
00164 LRESULT ChildOnCreate(HWND win)
00165 {
00166     CHILDINFO   *ci;
00167 
00168     <span class="comment">/* set the user data long to identify what type of child this is */</span>
00169     SetWindowLong(win, GWL_USERDATA, newWinType);
00170 
00171     <span class="comment">/* allocate an info struct and store the address in the extra window space */</span>
00172     ci = malloc(<span class="keyword">sizeof</span>(CHILDINFO));
00173     SetWindowLong(win, 0, (LONG) ci);
00174 
00175     <span class="comment">/* set the current directory */</span>
00176     <span class="keywordflow">if</span>(GetWindowLong(win, GWL_USERDATA) == CHILD_WINLISTER){
00177         <span class="keywordflow">if</span>(Options.defDriveList){
00178             strcpy(ci-&gt;curDir, <span class="stringliteral">""</span>);
00179             ci-&gt;atRoot = TRUE;
00180         }
00181         <span class="keywordflow">else</span>{
00182             strcpy(ci-&gt;curDir, Options.defaultDir);
00183             ci-&gt;atRoot = FALSE;
00184         }
00185     }
00186     <span class="keywordflow">else</span>{
00187         strcpy(ci-&gt;curDir, <span class="stringliteral">"/"</span>);
00188         <span class="comment">// Save disk type and compressed size to info structure.</span>
00189         ci-&gt;dfDisk = dfDisk;
00190         ci-&gt;compSize = comp_size;
00191 
00192         ci-&gt;dev = adfMountDev(gstrFileName, ReadOnly);
00193         <span class="keywordflow">if</span> (ci-&gt;dev == NULL)
00194             <span class="keywordflow">return</span> -1;
00195 
00196         ci-&gt;vol = adfMount(ci-&gt;dev, volToOpen, FALSE);
00197         <span class="keywordflow">if</span> (ci-&gt;vol == NULL)
00198             <span class="keywordflow">return</span> -1;
00199         ci-&gt;atRoot = TRUE;
00200     }
00201 
00202     ci-&gt;readOnly = ReadOnly;
00203 
00204     <span class="comment">/* create the listview control and store the handle */</span>
00205     ci-&gt;lv = CreateListView(win);
00206 
00207     <span class="comment">/* create the status bar */</span>
00208     ci-&gt;sb = CreateWindow(
00209         STATUSCLASSNAME,
00210         <span class="stringliteral">""</span>,
00211         WS_CHILD | WS_VISIBLE | CCS_TOP,
00212         CW_USEDEFAULT, CW_USEDEFAULT,
00213         CW_USEDEFAULT, CW_USEDEFAULT,
00214         win,
00215         NULL,
00216         instance,
00217         NULL
00218     );
00219 
00220     <span class="comment">/* init linked list of dir entries */</span>
00221     ci-&gt;content = NULL;
00222 
00223     ci-&gt;isAmi = (newWinType == CHILD_AMILISTER);
00224 
00225     strcpy(ci-&gt;orig_path, buf);                 <span class="comment">// Store original filename.</span>
00226     <span class="keywordflow">if</span>(ci-&gt;dfDisk != ADF)
00227         strcpy(ci-&gt;temp_path, gstrFileName);    <span class="comment">// Store temp adf filename.</span>
00228     
00229     <span class="comment">// Disable properties menu item and toolbar button, in case they've been left active.</span>
00230     hMenu = GetMenu(ghwndFrame);
00231     EnableMenuItem(hMenu, ID_ACTION_PROPERTIES, MF_GRAYED);
00232     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_PROPERTIES, MAKELONG(FALSE, 0));
00233 
00234     ChildUpdate(win);
00235 
00236     <span class="keywordflow">return</span> 0;
00237 }
00238 
00239 BOOL ChildOnCommand(HWND win, WPARAM wp, LPARAM lp)
00240 <span class="comment">/* WM_COMMAND messages, mostly passed on from frame window */</span>
00241 {
00242     CHILDINFO *ci;
00243 
00244     <span class="keywordflow">switch</span>(wp)
00245     {
00246     <span class="keywordflow">case</span> ID_ACTION_UPONELEVEL:
00247         ChildUpOneLevel(win);
00248         <span class="keywordflow">break</span>;
00249     <span class="keywordflow">case</span> ID_EDIT_SELECTALL:
00250         ChildSelectAll(win);
00251         <span class="keywordflow">break</span>;
00252     <span class="keywordflow">case</span> ID_EDIT_SELECTNONE:
00253         ChildSelectNone(win);
00254         <span class="keywordflow">break</span>;
00255     <span class="keywordflow">case</span> ID_EDIT_INVERTSELECTION:
00256         ChildInvertSelection(win);
00257         <span class="keywordflow">break</span>;
00258     <span class="keywordflow">case</span> ID_VIEW_REFRESH:
00259         ChildUpdate(win);
00260         <span class="keywordflow">break</span>;
00261     <span class="keywordflow">case</span> ID_VIEW_SHOWUNDELETABLEFILES:
00262         ChildShowUndeletable(win);
00263         <span class="keywordflow">break</span>;
00264     <span class="keywordflow">case</span> ID_ACTION_DELETE:
00265         ChildDelete(win);
00266         <span class="keywordflow">break</span>;
00267     <span class="keywordflow">case</span> ID_ACTION_UNDELETE:
00268         ChildUndelete(win);
00269         <span class="keywordflow">break</span>;
00270     <span class="keywordflow">case</span> ID_ACTION_RENAME:
00271         ci = (CHILDINFO *)GetWindowLong(win, 0);
00272         ListView_EditLabel(ci-&gt;lv, LVGetItemFocused(ci-&gt;lv));
00273         <span class="keywordflow">break</span>;
00274     <span class="keywordflow">case</span> ID_ACTION_NEWDIRECTORY:
00275         ChildMakeDir(win);
00276         <span class="keywordflow">break</span>;
00277     }
00278     <span class="keywordflow">return</span> TRUE;
00279 }
00280 
00281 <span class="keywordtype">void</span> ChildOnPaint(HWND win)
00282 <span class="comment">/* standard do-nothing WM_PAINT handler */</span>
00283 {
00284     HDC dc;
00285     PAINTSTRUCT ps;
00286 
00287     dc = BeginPaint(win, &amp;ps);
00288     <span class="keywordflow">if</span> (dc)
00289         EndPaint(win, &amp;ps);
00290 }
00291 
00292 <span class="keywordtype">void</span> ChildOnDestroy(HWND win)
00293 <span class="comment">// Cleanup after child window. Delete temp adf and recompress if adz.</span>
00294 <span class="comment">// Gets items from VolSelect.h and ADFOpus.h.</span>
00295 {
00296     CHILDINFO   *ci = (CHILDINFO *)GetWindowLong(win, 0);
00297 
00298     <span class="comment">/* unmount volume and device if this an amiga lister */</span>
00300 
00301     
00302     <span class="keywordflow">if</span> (GetWindowLong(win, GWL_USERDATA) == CHILD_AMILISTER) {
00303         <span class="keywordflow">if</span> (ci-&gt;vol) {
00304             adfUnMount(ci-&gt;vol);
00305         }
00306         <span class="keywordflow">if</span> (ci-&gt;dev) {
00307             adfUnMountDev(ci-&gt;dev);
00308         }
00309     }
00310 
00311     <span class="comment">// Cleanup temp files. Recompress adz.</span>
00312     <span class="keywordflow">if</span>(ci-&gt;dfDisk == ADZ){
00313         GZCompress(NULL, ci-&gt;temp_path, ci-&gt;orig_path);
00314         remove(ci-&gt;temp_path);
00315     }
00316 
00317     <span class="comment">// Disable properties menu item and toolbar button, in case they've been left active.</span>
00318     hMenu = GetMenu(ghwndFrame);
00319     EnableMenuItem(hMenu, ID_ACTION_PROPERTIES, MF_GRAYED);
00320     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_PROPERTIES, MAKELONG(FALSE, 0));
00321 
00322     <span class="comment">/* free the extra info we allocated when the window was created */</span>
00323     free(ci);
00324 
00325 }
00326 
00327 <span class="keywordtype">void</span> ChildOnSize(HWND win)
00328 <span class="comment">/* adjust the listview and status bar when window is resized */</span>
00329 {
00330     RECT winRec, sbRec;
00331     <span class="keywordtype">int</span> sbHeight;
00332     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00333 
00334     GetWindowRect(ci-&gt;sb, &amp;sbRec);
00335     sbHeight = (sbRec.bottom - sbRec.top);
00336 
00337     GetClientRect(win, &amp;winRec);
00338     MoveWindow(ci-&gt;lv, 0, sbHeight, winRec.right, winRec.bottom - sbHeight, TRUE);
00339 
00340     SendMessage(ci-&gt;sb, WM_SIZE, 0, 0l);
00341 }
00342 
00343 BOOL ChildOnNotify(HWND win, WPARAM wp, LONG lp)
00344 <span class="comment">/* process WM_NOTIFY events.  these will always come from the list-view</span>
00345 <span class="comment">   control. */</span>
00346 {
00347     NMHDR       *nmhdr = (NMHDR *) lp;
00348     <span class="keywordtype">int</span>         index;
00349     HMENU       hMenu;
00350     <span class="keyword">extern</span> HWND ghwndFrame;
00351     <span class="keywordtype">char</span>        szError[MAX_PATH], szWinFile[MAX_PATH];
00352     <span class="keywordtype">int</span>         iError;
00353 
00354 
00355     ci = (CHILDINFO *)GetWindowLong(win, 0);            
00356     hMenu = GetMenu(ghwndFrame);
00357     <span class="keywordflow">switch</span>(nmhdr-&gt;code){
00358         <span class="keywordflow">case</span> NM_CLICK:
00359             <span class="comment">// An item was single-clicked.</span>
00360             <span class="comment">// Find out which file.</span>
00361             index = LVGetItemFocused(ci-&gt;lv);
00362             LVGetItemCaption(ci-&gt;lv, buf, <span class="keyword">sizeof</span>(buf), index);
00363             <span class="comment">// Return if a drive icon was clicked.</span>
00364             <span class="keywordflow">switch</span> (LVGetItemImageIndex(ci-&gt;lv, index)) {
00365                 <span class="keywordflow">case</span> ICO_DRIVEHD:
00366                 <span class="keywordflow">case</span> ICO_DRIVECD:
00367                 <span class="keywordflow">case</span> ICO_DRIVENET:
00368                 <span class="keywordflow">case</span> ICO_DRIVEFLOP35:
00369                 <span class="keywordflow">case</span> ICO_DRIVEFLOP514:
00370                     <span class="keywordflow">return</span> TRUE;
00371             }
00372             <span class="comment">// Item is a deleted file.</span>
00373             <span class="keywordflow">if</span>(ListView_GetItemState(ci-&gt;lv, index, LVIS_CUT)){
00374                 <span class="comment">// Enable menu and toolbar items for undelete.</span>
00375                 EnableMenuItem(hMenu, ID_ACTION_UNDELETE, MF_ENABLED);
00376                 SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_UNDELETE, MAKELONG(TRUE, 0));
00377                 <span class="comment">// Disable properties, rename, delete.</span>
00378                 EnableMenuItem(hMenu, ID_ACTION_DELETE, MF_GRAYED);
00379                 EnableMenuItem(hMenu, ID_ACTION_RENAME, MF_GRAYED);
00380                 EnableMenuItem(hMenu, ID_ACTION_PROPERTIES, MF_GRAYED);
00381                 SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_DELETE, MAKELONG(FALSE, 0));
00382                 SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_RENAME, MAKELONG(FALSE, 0));
00383                 SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_PROPERTIES, MAKELONG(FALSE, 0));
00384                 bUndeleting = TRUE;
00385             }
00386             <span class="keywordflow">else</span>{
00387                 EnableMenuItem(hMenu, ID_ACTION_UNDELETE, MF_GRAYED);
00388                 SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_UNDELETE, MAKELONG(FALSE, 0));
00389                 <span class="comment">// Activate Properties items if not a drive.</span>
00390                 <span class="keywordflow">if</span>(ListView_GetSelectedCount(ci-&gt;lv) &gt; 0){
00391                     bClicked = TRUE;
00392                     <span class="comment">// Enable properties, rename, delete.</span>
00393                     EnableMenuItem(hMenu, ID_ACTION_DELETE, MF_ENABLED);
00394                     EnableMenuItem(hMenu, ID_ACTION_RENAME, MF_ENABLED);
00395                     EnableMenuItem(hMenu, ID_ACTION_PROPERTIES, MF_ENABLED);
00396                     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_DELETE, MAKELONG(TRUE, 0));
00397                     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_RENAME, MAKELONG(TRUE, 0));
00398                     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_PROPERTIES, MAKELONG(TRUE, 0));
00399                 }
00400                 bUndeleting = FALSE;
00401             }
00402 
00403             <span class="keywordflow">break</span>;
00404     
00405         <span class="keywordflow">case</span> NM_DBLCLK:
00406             <span class="comment">/* an item was double-clicked, find out which one */</span>
00407             <span class="comment">/*** THIS IS A KLUDGE - it will return the focused</span>
00408 <span class="comment">                item even if the user double clicks an empty</span>
00409 <span class="comment">                part of the listview control! */</span>
00410             index = LVGetItemFocused(ci-&gt;lv);
00411             <span class="comment">// Item is a deleted file, return.</span>
00412             <span class="keywordflow">if</span>(ListView_GetItemState(ci-&gt;lv, index, LVIS_CUT))
00413                 <span class="keywordflow">return</span> TRUE;
00414             LVGetItemCaption(ci-&gt;lv, buf, <span class="keyword">sizeof</span>(buf), index);
00415             <span class="comment">// Deactivate the Properties context and main menu items and toolbar button.</span>
00416             EnableMenuItem(hMenu, ID_ACTION_PROPERTIES, MF_GRAYED);
00417             SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_PROPERTIES, MAKELONG(FALSE, 0));
00418             bClicked = FALSE;
00419 
00420             <span class="keywordflow">switch</span> (LVGetItemImageIndex(ci-&gt;lv, index)) {
00421                 <span class="keywordflow">case</span> ICO_WINFILE:
00422                     strcpy(szWinFile, ci-&gt;curDir);
00423                     strcat(szWinFile, buf);
00424                     iError = (int)ShellExecute(win, <span class="stringliteral">"open"</span>, szWinFile, NULL, NULL, SW_SHOWNORMAL);
00425                     ChildUpdate(win);
00426                     <span class="keywordflow">break</span>;
00427             
00428                 <span class="keywordflow">case</span> ICO_WINDIR:
00429                     <span class="comment">/* it is a dir, append the name to the</span>
00430 <span class="comment">                       current directory */</span>
00431                     strcat(ci-&gt;curDir, buf);
00432                     strcat(ci-&gt;curDir, <span class="stringliteral">"\\"</span>);
00433                     ci-&gt;atRoot = FALSE;
00434 
00435                     ChildUpdate(win);
00436                     <span class="keywordflow">break</span>;
00437                 <span class="keywordflow">case</span> ICO_AMIFILE:
00438                     <span class="comment">// Get the file and copy it to the temp dir.</span>
00439                     <span class="keywordflow">if</span>(_chdir(dirTemp) == -1){                      <span class="comment">// Change to temp dir.</span>
00440                         _mkdir(dirTemp);                            <span class="comment">// Create if doesn't yet exist.</span>
00441                         _chdir(dirTemp);
00442                     }
00443                     <span class="keywordflow">if</span>(GetFileFromADF(ci-&gt;vol, buf) &lt; 0){
00444                         sprintf(szError, <span class="stringliteral">"Error extracting %s from %s."</span>, buf, ci-&gt;orig_path);
00445                         MessageBox(win, szError, <span class="stringliteral">"ADF Opus Error"</span>, MB_ICONSTOP);
00446                         <span class="keywordflow">break</span>;
00447                     }
00448                     <span class="comment">// Run the file.</span>
00449                     iError = (int)ShellExecute(win, <span class="stringliteral">"open"</span>, buf, NULL, NULL, SW_SHOWNORMAL);
00450                     _chdir(dirOpus);                                <span class="comment">// Change back to Opus dir.</span>
00451                     
00452                     <span class="keywordflow">if</span>(iError == SE_ERR_NOASSOC){       <span class="comment">// No file asociation.</span>
00453                         sprintf(szError,
00454                                 <span class="stringliteral">"ADF Opus is unable to open %s because no application is "</span>
00455                                  <span class="stringliteral">"associated with this file type under Windows. See Help for how "</span>
00456                                  <span class="stringliteral">"to register this file type with Windows and then try again."</span>,
00457                                  buf);
00458                         MessageBox(win, szError, <span class="stringliteral">"ADF Opus Error"</span>, MB_ICONINFORMATION);
00459                     }
00460                     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(iError &lt;= 32){              <span class="comment">// Other error.</span>
00461                         sprintf(szError, <span class="stringliteral">"Unable to open %s under Windows."</span>, buf);
00462                         MessageBox(win, szError, <span class="stringliteral">"ADF Opus Error"</span>, MB_ICONEXCLAMATION);
00463                     }
00464 
00465                     ChildUpdate(win);
00466                     <span class="keywordflow">break</span>;
00467                 
00468                 <span class="keywordflow">case</span> ICO_AMIDIR:
00469                     strcat(ci-&gt;curDir, buf);
00470                     strcat(ci-&gt;curDir, <span class="stringliteral">"/"</span>);
00471                     ci-&gt;atRoot = FALSE;
00472                     adfChangeDir(ci-&gt;vol, buf);
00473 
00474                     ChildUpdate(win);
00475                     <span class="keywordflow">break</span>;
00476 
00477                 <span class="keywordflow">case</span> ICO_DRIVEHD:
00478                 <span class="keywordflow">case</span> ICO_DRIVECD:
00479                 <span class="keywordflow">case</span> ICO_DRIVENET:
00480                 <span class="keywordflow">case</span> ICO_DRIVEFLOP35:
00481                 <span class="keywordflow">case</span> ICO_DRIVEFLOP514:
00482                     <span class="comment">/* it is a drive, set the current dir</span>
00483 <span class="comment">                    to the root dir of the drive */</span>
00484                     strcpy(ci-&gt;curDir, buf);
00485                     strcat(ci-&gt;curDir, <span class="stringliteral">":\\"</span>);
00486                     ci-&gt;atRoot = FALSE;
00487 
00488                     ChildUpdate(win);
00489                     <span class="keywordflow">break</span>;
00490             }
00491             <span class="keywordflow">break</span>;
00492         <span class="keywordflow">case</span> NM_KILLFOCUS:
00493             <span class="comment">// Disable properties menu item and toolbar button when the current window loses</span>
00494             <span class="comment">// focus, in case they've been left active.</span>
00495             EnableMenuItem(hMenu, ID_ACTION_PROPERTIES, MF_GRAYED);
00496             SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_PROPERTIES, MAKELONG(FALSE, 0));
00497             bClicked = FALSE;                                           <span class="comment">// Deactivate the Properties context menu item.</span>
00498             <span class="comment">// ..and undeletion items.</span>
00499             EnableMenuItem(hMenu, ID_ACTION_UNDELETE, MF_GRAYED);
00500             EnableMenuItem(hMenu, ID_VIEW_SHOWUNDELETABLEFILES, MF_GRAYED);
00501             <span class="keywordflow">break</span>;
00502 
00503         <span class="keywordflow">case</span> LVN_BEGINDRAG:
00504             <span class="comment">/* user started dragging an item */</span>
00505             SetCursor(ghcurNo);
00506             ghwndDragSource = win;
00507             SetCapture(ghwndFrame);
00508             gbIsDragging = TRUE;
00509             <span class="keywordflow">break</span>;
00510         <span class="keywordflow">case</span> LVN_BEGINLABELEDIT:
00511             <span class="comment">/* stop user from editing things that can't be edited */</span>
00513             <span class="keywordflow">return</span> ChildCheckRename(win, (LV_DISPINFO *)lp);
00514         <span class="keywordflow">case</span> LVN_ENDLABELEDIT:
00515             <span class="comment">/* an item was renamed */</span>
00516             <span class="keywordflow">return</span> ChildRename(win, (LV_DISPINFO *)lp);
00517     }
00518     <span class="keywordflow">return</span> TRUE;
00519 }
00520 
00521 
00522 HWND CreateListView(HWND win)
00523 {
00524     HWND lv;
00525 
00526     <span class="comment">/* Create the control */</span>
00527     lv = CreateWindowEx(
00528         WS_EX_CLIENTEDGE,
00529         WC_LISTVIEW,
00530         <span class="stringliteral">""</span>,
00531         WS_CHILD | LVS_REPORT | LVS_EDITLABELS | WS_VISIBLE | 
00532             LVS_SHAREIMAGELISTS | LVS_NOSORTHEADER,
00533         0, 0,
00534         300, 100,
00535         win,
00536         NULL,
00537         instance,
00538         NULL
00539     );
00540 
00541     <span class="keywordflow">if</span> (lv == NULL)
00542         <span class="keywordflow">return</span> NULL;
00543 
00544     <span class="comment">/* add the columns */</span>
00545     LVAddColumn(lv, <span class="stringliteral">"Name"</span>, 200, 0);
00546     LVAddColumn(lv, <span class="stringliteral">"Size"</span>, 70, 1);
00547     LVAddColumn(lv, <span class="stringliteral">"Flags"</span>, 75, 2);
00548     <span class="comment">// Create a Comment column in Amiga listers.</span>
00549     <span class="keywordflow">if</span>(GetWindowLong(win, GWL_USERDATA) != CHILD_WINLISTER)
00550         LVAddColumn(lv, <span class="stringliteral">"Comment"</span>, 605, 3);
00551 
00552     <span class="comment">/* assign the image list */</span>
00553     ListView_SetImageList(lv, ghwndImageList, LVSIL_SMALL);
00554     <span class="comment">// Set full row selection.</span>
00555     ListView_SetExtendedListViewStyle(lv, LVS_EX_FULLROWSELECT);
00556 
00557     <span class="keywordflow">return</span> lv;
00558 } 
00559 
00560 <span class="keywordtype">void</span> ChildUpdate(HWND win)
00561 <span class="comment">/* fills the list view control with the directory content */</span>
00562 {
00563     CHILDINFO   *ci = (CHILDINFO *)GetWindowLong(win, 0);
00564     DIRENTRY    *ce;
00565     <span class="keywordtype">char</span>        strBuf[20];
00566     <span class="keywordtype">int</span>         pos;
00567     <span class="keyword">struct </span>File *amiFile;
00568     BOOL        bAmi = FALSE;
00569 
00570 
00571     SetWindowText(ghwndSB, <span class="stringliteral">"Reading directory..."</span>);
00572 
00573     <span class="keywordflow">if</span> (GetWindowLong(win, GWL_USERDATA) == CHILD_WINLISTER)
00574         <span class="keywordflow">if</span> (strcmp(ci-&gt;curDir, <span class="stringliteral">""</span>) == 0)
00575             WinGetDrives(win);
00576         <span class="keywordflow">else</span>
00577             WinGetDir(win);
00578     
00579     <span class="keywordflow">else</span>{
00580         bAmi = TRUE;
00581         AmiGetDir(win);
00582     }
00583     ChildSortDir(win, 0l);
00584 
00585     SendMessage(ci-&gt;lv, WM_SETREDRAW, FALSE, 0);
00586 
00587     ListView_DeleteAllItems(ci-&gt;lv);
00588 
00589     ListView_SetItemCount(ci-&gt;lv, ci-&gt;totalCount);
00590 
00591     ce = ci-&gt;content;
00592     <span class="keywordflow">while</span> (ce != NULL) {
00593         pos = LVAddItem(ci-&gt;lv, ce-&gt;name, ce-&gt;icon);
00594         <span class="keywordflow">if</span> (pos == -1)
00595             pos++;
00596         <span class="keywordflow">if</span> (ce-&gt;icon == ICO_WINFILE || ce-&gt;icon == ICO_AMIFILE) {
00597             itoa(ce-&gt;size, strBuf, 10);
00598             LVAddSubItem(ci-&gt;lv, strBuf, pos, 1);
00599         }
00600         LVAddSubItem(ci-&gt;lv, ce-&gt;flags, pos, 2);
00601 
00602         <span class="comment">// Display amiga file comment.</span>
00603         <span class="keywordflow">if</span>(bAmi){
00604             amiFile = adfOpenFile(ci-&gt;vol, ce-&gt;name, <span class="stringliteral">"r"</span>);
00605             LVAddSubItem(ci-&gt;lv, amiFile-&gt;fileHdr-&gt;comment, pos, 3);
00606             adfCloseFile(amiFile);
00607         }
00608         ce = ce-&gt;next;
00609     }
00610 
00611     SendMessage(ci-&gt;lv, WM_SETREDRAW, TRUE, 0);
00612     InvalidateRect(ci-&gt;lv, NULL, FALSE);
00613 
00614     <span class="comment">/* update status bars */</span>
00615     <span class="keywordflow">if</span> (! strcmp(ci-&gt;curDir, <span class="stringliteral">""</span>))
00616         SetWindowText(ci-&gt;sb, <span class="stringliteral">"All drives"</span>);
00617     <span class="keywordflow">else</span>
00618         SetWindowText(ci-&gt;sb, ci-&gt;curDir);
00619     UpdateToolbar();
00620     SetWindowText(ghwndSB, <span class="stringliteral">"Idle"</span>);
00621 
00622 }
00623 
00624 <span class="keywordtype">void</span> WinGetDir(HWND win)
00625 <span class="comment">/* fills the internal directory list with the contents of the current windows dir */</span>
00626 {
00627     WIN32_FIND_DATA wfd;
00628     HANDLE search;
00629     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00630     <span class="keywordtype">char</span> searchPath[MAX_PATH];
00631 
00632     ChildClearContent(win);
00633 
00634     sprintf(searchPath, <span class="stringliteral">"%s*"</span>, ci-&gt;curDir);
00635 
00636     search = FindFirstFile(searchPath, &amp;wfd);
00637     <span class="keywordflow">if</span> (search == INVALID_HANDLE_VALUE)
00638         <span class="keywordflow">return</span>;
00639 
00640     <span class="keywordflow">if</span> (WinAddFile(ci, &amp;wfd))
00641         ci-&gt;totalCount++;
00642 
00643     <span class="keywordflow">while</span> (FindNextFile(search, &amp;wfd))
00644         <span class="keywordflow">if</span> (WinAddFile(ci, &amp;wfd))
00645             ci-&gt;totalCount++;
00646 
00647     FindClose(search);
00648 }
00649 
00650 BOOL WinAddFile(CHILDINFO *ci, WIN32_FIND_DATA *wfd)
00651 <span class="comment">/* returns TRUE if a file was actually added (not . or ..), FALSE otherwise</span>
00652 <span class="comment"> */</span>
00653 {
00654     DIRENTRY *de;
00655 
00656     <span class="keywordflow">if</span> ((strcmp(wfd-&gt;cFileName, <span class="stringliteral">"."</span>) == 0) || (strcmp(wfd-&gt;cFileName, <span class="stringliteral">".."</span>) == 0))
00657         <span class="keywordflow">return</span> FALSE;
00658 
00659     de = malloc(<span class="keyword">sizeof</span>(DIRENTRY));
00660     strcpy(de-&gt;name, wfd-&gt;cFileName);
00661     de-&gt;size = wfd-&gt;nFileSizeLow;
00662     de-&gt;icon = ((wfd-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY))
00663         ? ICO_WINDIR : ICO_WINFILE;
00664 
00665     strcpy(de-&gt;flags, <span class="stringliteral">""</span>);
00666     <span class="keywordflow">if</span> (wfd-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_READONLY)
00667         strcat(de-&gt;flags, <span class="stringliteral">"R"</span>);
00668     <span class="keywordflow">if</span> (wfd-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_HIDDEN)
00669         strcat(de-&gt;flags, <span class="stringliteral">"H"</span>);
00670     <span class="keywordflow">if</span> (wfd-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_SYSTEM)
00671         strcat(de-&gt;flags, <span class="stringliteral">"S"</span>);
00672     <span class="keywordflow">if</span> (wfd-&gt;dwFileAttributes &amp; FILE_ATTRIBUTE_ARCHIVE)
00673         strcat(de-&gt;flags, <span class="stringliteral">"A"</span>);
00674 
00675     de-&gt;next = ci-&gt;content;
00676     ci-&gt;content = de;
00677 
00678     <span class="keywordflow">return</span> TRUE;
00679 }
00680 
00681 <span class="keywordtype">void</span> AmiGetDir(HWND win)
00682 {
00683     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00684     <span class="keyword">struct </span>List *list;
00685 
00686     ChildClearContent(win);
00687 
00688     list = adfGetDirEnt(ci-&gt;vol, ci-&gt;vol-&gt;curDirPtr);
00689 
00690     <span class="keywordflow">while</span> (list) {
00691         AmiAddFile(ci, list);
00692         adfFreeEntry(list-&gt;content);
00693         list = list-&gt;next;
00694         ci-&gt;totalCount++;
00695     }
00696     freeList(list);
00697 }
00698 
00699 <span class="keywordtype">void</span> AmiAddFile(CHILDINFO *ci, <span class="keyword">struct</span> List *list)
00700 {
00701     DIRENTRY *de = malloc(<span class="keyword">sizeof</span>(DIRENTRY));
00702     <span class="keyword">struct </span>Entry *ent = (<span class="keyword">struct </span>Entry *)list-&gt;content;
00703 
00704     strcpy(de-&gt;name, ent-&gt;name);
00705     de-&gt;size = ent-&gt;size;
00706     de-&gt;icon = ent-&gt;type == ST_FILE ? ICO_AMIFILE : ICO_AMIDIR;
00707     strcpy(de-&gt;flags, <span class="stringliteral">""</span>);
00708     <span class="keywordflow">if</span> (!hasR(ent-&gt;access))
00709         strcat(de-&gt;flags, <span class="stringliteral">"R"</span>);
00710     <span class="keywordflow">if</span> (!hasW(ent-&gt;access))
00711         strcat(de-&gt;flags, <span class="stringliteral">"W"</span>);
00712     <span class="keywordflow">if</span> (!hasE(ent-&gt;access))
00713         strcat(de-&gt;flags, <span class="stringliteral">"E"</span>);
00714     <span class="keywordflow">if</span> (!hasD(ent-&gt;access))
00715         strcat(de-&gt;flags, <span class="stringliteral">"D"</span>);
00716     <span class="keywordflow">if</span> (hasS(ent-&gt;access))
00717         strcat(de-&gt;flags, <span class="stringliteral">"S"</span>);
00718     <span class="keywordflow">if</span> (hasA(ent-&gt;access))
00719         strcat(de-&gt;flags, <span class="stringliteral">"A"</span>);
00720     <span class="keywordflow">if</span> (hasP(ent-&gt;access))
00721         strcat(de-&gt;flags, <span class="stringliteral">"P"</span>);
00722     <span class="keywordflow">if</span> (hasH(ent-&gt;access))
00723         strcat(de-&gt;flags, <span class="stringliteral">"H"</span>);
00724 
00725     de-&gt;next = ci-&gt;content;
00726     ci-&gt;content = de;
00727 }
00728 
00729 <span class="keywordtype">void</span> ChildClearContent(HWND win)
00730 {
00731     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00732     DIRENTRY *ce, *cd;
00733 
00734     ce = ci-&gt;content;
00735 
00736     <span class="keywordflow">while</span> (ce != NULL) {
00737         cd = ce;
00738         ce = ce-&gt;next;
00739         free(cd);
00740     }
00741 
00742     ci-&gt;content = NULL;
00743     ci-&gt;totalCount = 0;
00744 }
00745 
00746 <span class="keywordtype">void</span> ChildUpOneLevel(HWND win)
00747 <span class="comment">/* go to the parent directory, or display the drive list if we are already</span>
00748 <span class="comment"> * at the root directory</span>
00749 <span class="comment"> */</span>
00750 {
00751     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00752     <span class="keywordtype">int</span> i, max;
00753     BOOL isAmi = GetWindowLong(win, GWL_USERDATA) == CHILD_AMILISTER;
00754 
00755     <span class="keywordflow">if</span> (ci-&gt;atRoot)
00756         <span class="keywordflow">return</span>;
00757 
00758     max = strlen(ci-&gt;curDir);
00759 
00760     <span class="keywordflow">if</span> (max &lt; (isAmi ? 2 : 4)) { <span class="comment">/* at root */</span>
00761         <span class="keywordflow">if</span> (! isAmi)
00762             strcpy(ci-&gt;curDir, <span class="stringliteral">""</span>);
00763         ci-&gt;atRoot = TRUE;
00764         <span class="comment">// This doesn't flag atRoot correctly. It waits until the root directory is</span>
00765         <span class="comment">// displayed and the button is clicked again before flagging it. The button</span>
00766         <span class="comment">// is therefore left active whilst actually in the root dir.</span>
00767         <span class="comment">// NOT ANY MORE.</span>
00768     }
00769     <span class="keywordflow">else</span>{
00770         <span class="comment">/* replace last \ character in pathname with a null */</span>
00771         <span class="keywordflow">for</span> (i = max - 2 ; i &gt;= 0 ; i--) {
00772             <span class="keywordflow">if</span> (ci-&gt;curDir[i] == (isAmi ? <span class="charliteral">'/'</span> : <span class="charliteral">'\\'</span>)) {
00773                 ci-&gt;curDir[i + 1] = 0;
00774                 <span class="comment">// Fix the above "up one level" button problem.</span>
00775                 <span class="keywordflow">if</span>(strcmp(ci-&gt;curDir, <span class="stringliteral">"/"</span>) == 0)
00776                     ci-&gt;atRoot = TRUE;              
00777                 <span class="keywordflow">break</span>;
00778             }
00779 
00780         }
00781         <span class="keywordflow">if</span> (isAmi)
00782             adfParentDir(ci-&gt;vol);
00783     }
00784 
00785     <span class="comment">// Deactivate the Properties context menu item, menu and toolbar items.</span>
00786     bClicked = FALSE;
00787     EnableMenuItem(hMenu, ID_ACTION_PROPERTIES, MF_GRAYED);
00788     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_PROPERTIES, MAKELONG(FALSE, 0));
00789 
00790     ChildUpdate(win);
00791 }
00792 
00793 <span class="keywordtype">void</span> WinGetDrives(HWND win)
00794 <span class="comment">/* get available windows drives</span>
00795 <span class="comment"> */</span>
00796 {
00797     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00798     DIRENTRY *de;
00799     <span class="keywordtype">char</span> driveLetter[2];
00800     DWORD dm;
00801     <span class="keywordtype">char</span> i;
00802     <span class="keywordtype">char</span> driveSpec[4];
00803 
00804     driveLetter[1] = 0; <span class="comment">/* null-terminator */</span>
00805 
00806     ChildClearContent(win);
00807 
00808     dm = GetLogicalDrives();
00809 
00810     <span class="keywordflow">for</span> (i = 25 ; i &gt;= 0 ; i--) {
00811         <span class="keywordflow">if</span> (dm &amp; (1 &lt;&lt; i)) {
00812             driveLetter[0] = <span class="charliteral">'A'</span> + i;
00813             de = malloc(<span class="keyword">sizeof</span>(DIRENTRY));
00814             de-&gt;size = 0;
00815             strcpy(de-&gt;name, driveLetter);
00816 
00817             sprintf(driveSpec, <span class="stringliteral">"%c:"</span>, driveLetter[0]);
00818 
00819             <span class="keywordflow">switch</span> (GetDriveType(driveSpec)) {
00820             <span class="keywordflow">case</span> DRIVE_REMOVABLE:
00821                 de-&gt;icon = ICO_DRIVEFLOP35;
00822                 <span class="keywordflow">break</span>;
00823             <span class="keywordflow">case</span> DRIVE_REMOTE:
00824                 de-&gt;icon = ICO_DRIVENET;
00825                 <span class="keywordflow">break</span>;
00826             <span class="keywordflow">case</span> DRIVE_CDROM:
00827                 de-&gt;icon = ICO_DRIVECD;
00828                 <span class="keywordflow">break</span>;
00829             <span class="keywordflow">default</span>:
00830                 de-&gt;icon = ICO_DRIVEHD;
00831             }
00832 
00833             strcpy(de-&gt;flags, <span class="stringliteral">""</span>);
00834             de-&gt;next = ci-&gt;content;
00835             ci-&gt;content = de;
00836             ci-&gt;totalCount++;
00837         }
00838     }
00839 }
00840 
00841 <span class="keywordtype">void</span> ChildSelectAll(HWND win)
00842 {
00843     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00844 
00845     LVSelectAll(ci-&gt;lv);
00846     SendMessage(win, WM_MDIACTIVATE, 0, 0l);
00847 }
00848 
00849 <span class="keywordtype">void</span> ChildSelectNone(HWND win)
00850 {
00851     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00852 
00853     LVSelectNone(ci-&gt;lv);
00854     SendMessage(win, WM_MDIACTIVATE, 0, 0l);
00855 }
00856 
00857 <span class="keywordtype">void</span> ChildInvertSelection(HWND win)
00858 {
00859     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00860 
00861     LVInvert(ci-&gt;lv);
00862     SendMessage(win, WM_MDIACTIVATE, 0, 0l);
00863 }
00864 
00865 <span class="keywordtype">void</span> ChildSortDir(HWND win, <span class="keywordtype">long</span> type)
00866 <span class="comment">/* My entry for the "shittest sorting code ever" championships</span>
00867 <span class="comment"> */</span>
00868 {
00869     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00870     DIRENTRY *de1, *de2;
00871     <span class="keywordtype">char</span> t1[MAX_PATH], t2[MAX_PATH];
00872 
00873     <span class="keywordflow">if</span> (ci-&gt;content == NULL)
00874         <span class="keywordflow">return</span>;
00875 
00876     de1 = de2 = ci-&gt;content;
00877 
00878     <span class="comment">/* sort by icon (type) first */</span>
00879     <span class="keywordflow">if</span> (de1-&gt;icon &lt; ICO_DRIVEHD) { <span class="comment">/* only if this isn't a drive list */</span>
00880         <span class="keywordflow">while</span> (de1) {
00881             de2 = ci-&gt;content;
00882             <span class="keywordflow">while</span> (de2) {
00883                 <span class="keywordflow">if</span> (de1-&gt;icon &gt; de2-&gt;icon)
00884                     SwapContent(de1, de2);
00885                 de2 = de2-&gt;next;
00886             }
00887             de1 = de1-&gt;next;
00888         }
00889     }
00890 
00891     <span class="comment">/* now items with same icon by name */</span>
00892     de1 = de2 = ci-&gt;content;
00893 
00894     <span class="keywordflow">while</span> (de1) {
00895         de2 = ci-&gt;content;
00896         <span class="keywordflow">while</span> (de2) {
00897             strcpy(t1, de1-&gt;name);
00898             strcpy(t2, de2-&gt;name);
00899             strupr(t1);
00900             strupr(t2);
00901             <span class="keywordflow">if</span> ((de1-&gt;icon == de2-&gt;icon) &amp;&amp; (strcmp(t1, t2) &lt; 0))
00902                 SwapContent(de1, de2);
00903             de2 = de2-&gt;next;
00904         }
00905         de1 = de1-&gt;next;
00906     }
00907 }
00908 
00909 <span class="keywordtype">void</span> SwapContent(DIRENTRY *de1, DIRENTRY *de2)
00910 <span class="comment">/* the lamest function in this program</span>
00911 <span class="comment"> */</span>
00912 {
00913     DIRENTRY tmpde;
00914 
00915     strcpy(tmpde.name, de1-&gt;name);
00916     strcpy(tmpde.flags, de1-&gt;flags);
00917     tmpde.size = de1-&gt;size;
00918     tmpde.icon = de1-&gt;icon;
00919 
00920     strcpy(de1-&gt;name, de2-&gt;name);
00921     strcpy(de1-&gt;flags, de2-&gt;flags);
00922     de1-&gt;size = de2-&gt;size;
00923     de1-&gt;icon = de2-&gt;icon;
00924 
00925     strcpy(de2-&gt;name, tmpde.name);
00926     strcpy(de2-&gt;flags, tmpde.flags);
00927     de2-&gt;size = tmpde.size;
00928     de2-&gt;icon = tmpde.icon;
00929 }
00930 
00931 BOOL ChildOnContextMenu(HWND win, <span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
00932 <span class="comment">/* on context-click decide if we should display a context menu</span>
00933 <span class="comment"> */</span>
00934 {
00935     RECT rec;
00936     POINT pt = { x, y };
00937 
00938     GetClientRect(win, &amp;rec); 
00939 
00940     ScreenToClient(win, &amp;pt);
00941  
00942     <span class="keywordflow">if</span> (PtInRect(&amp;rec, pt)) {
00943         ClientToScreen(win, &amp;pt);
00944         DisplayContextMenu(win, pt);
00945         <span class="keywordflow">return</span> TRUE;
00946     }
00947  
00948     <span class="keywordflow">return</span> FALSE;
00949 }
00950 
00951 <span class="keywordtype">void</span> DisplayContextMenu(HWND win, POINT pt)
00952 <span class="comment">/* bring up the context menu</span>
00953 <span class="comment"> */</span>
00954 {
00955     HMENU   menu, popup;
00956     HBITMAP bmpMenu;
00957 
00958     menu = LoadMenu(instance, MAKEINTRESOURCE(IDR_LISTERMENU));
00959     <span class="keywordflow">if</span> (menu == NULL)
00960         <span class="keywordflow">return</span>;
00961     popup = GetSubMenu(menu, 0);
00962     <span class="comment">// Load and display menu bitmaps.</span>
00963     bmpMenu =  (HBITMAP)LoadImage(instance, MAKEINTRESOURCE(IDB_UPONELEVEL), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_DEFAULTCOLOR);
00964     SetMenuItemBitmaps(popup, 0, MF_BYPOSITION, bmpMenu, bmpMenu);
00965     bmpMenu =  (HBITMAP)LoadImage(instance, MAKEINTRESOURCE(IDB_PROPERTIES), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE|LR_DEFAULTCOLOR);
00966     SetMenuItemBitmaps(popup, 6, MF_BYPOSITION, bmpMenu, bmpMenu);
00967     
00968     <span class="comment">// Activate the Properties item if a file has been clicked.</span>
00969     <span class="keywordflow">if</span>(bClicked == TRUE)
00970         EnableMenuItem(popup, ID_ACTION_PROPERTIES, MF_ENABLED);
00971 
00972     TrackPopupMenuEx(popup, 0, pt.x, pt.y, ghwndFrame, NULL);
00973     DestroyMenu(menu);
00974     DeleteObject(bmpMenu);
00975 }
00976 
00977 <span class="keywordtype">void</span> ChildDelete(HWND win)
00978 <span class="comment">/* delete selected files</span>
00979 <span class="comment"> */</span>
00980 {
00981     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
00982     <span class="keywordtype">char</span> nam[60];
00983     <span class="keywordtype">char</span> path[MAX_PATH];
00984     <span class="keywordtype">char</span> msg[MAX_PATH + 60];
00985     <span class="keywordtype">int</span> i, icon;
00986     BOOL doit;
00987 
00988     <span class="comment">/* confirm before commencing delete (unless user has disabled it) */</span>
00989     <span class="keywordflow">if</span> (Options.confirmDelete)
00990         <span class="keywordflow">if</span> (MessageBox(win, <span class="stringliteral">"Are you sure you want to delete the selected item(s)?"</span>,
00991         <span class="stringliteral">"Question"</span>, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) != IDYES)
00992             <span class="keywordflow">return</span>;
00993 
00994     <span class="comment">/* delete windows files */</span>
00995     <span class="keywordflow">if</span> (GetWindowLong(win, GWL_USERDATA) == CHILD_WINLISTER) {
00996         <span class="keywordflow">for</span> (i = 0 ; i &lt; ListView_GetItemCount(ci-&gt;lv) ; i++) {
00997             <span class="keywordflow">if</span> (LVIsItemSelected(ci-&gt;lv, i)) {
00998                 icon = LVGetItemImageIndex(ci-&gt;lv, i);
00999                 <span class="keywordflow">if</span> ((icon == ICO_WINFILE) || (icon == ICO_WINDIR)) {
01000                     strcpy(path, ci-&gt;curDir);
01001                     LVGetItemCaption(ci-&gt;lv, nam, <span class="keyword">sizeof</span>(nam), i);
01002                     strcat(path, nam);
01003                     <span class="keywordflow">if</span> (icon == ICO_WINFILE) {
01004                         <span class="keywordflow">if</span> (! DeleteFile(path)) {
01005                             sprintf(msg, <span class="stringliteral">"Couldn't delete file '%s'.  Maybe it is in use or the device is write-protected."</span>, path);
01006                             MessageBox(win, msg, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
01007                         }
01008                     } <span class="keywordflow">else</span> {
01009                         <span class="keywordflow">if</span> (Options.confirmDeleteDirs) {
01010                             sprintf(msg, <span class="stringliteral">"'%s' is a directory. Are you sure you want to delete it and all its contents?"</span>, path);
01011                             doit = (MessageBox(win, msg, <span class="stringliteral">"Question"</span>, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES);
01012                         } <span class="keywordflow">else</span>
01013                             doit = TRUE;
01014                         <span class="keywordflow">if</span> (doit)
01015                             <span class="keywordflow">if</span> (! RemoveDirectoryRecursive(path)) {
01016                                 sprintf(msg, <span class="stringliteral">"Deletion of directory '%s' was not entirely successful."</span>, path);
01017                                 MessageBox(win, msg, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
01018                             }
01019                     }
01020                 }
01021             }
01022         }
01023     }
01024 
01025     <span class="comment">/* delete amiga files */</span>
01026     <span class="keywordflow">if</span> (GetWindowLong(win, GWL_USERDATA) == CHILD_AMILISTER) {
01027         <span class="keywordflow">for</span> (i = 0 ; i &lt; ListView_GetItemCount(ci-&gt;lv) ; i++) {
01028             <span class="keywordflow">if</span> (LVIsItemSelected(ci-&gt;lv, i)) {
01029                 icon = LVGetItemImageIndex(ci-&gt;lv, i);
01030                 <span class="keywordflow">if</span> (icon == ICO_AMIFILE || icon == ICO_AMIDIR) {
01031                     LVGetItemCaption(ci-&gt;lv, path, <span class="keyword">sizeof</span>(path), i);
01032                     <span class="keywordflow">if</span> (icon == ICO_AMIFILE) {
01033                         <span class="keywordflow">if</span> (adfRemoveEntry(ci-&gt;vol, ci-&gt;vol-&gt;curDirPtr, path) != RC_OK) {
01034                             sprintf(msg, <span class="stringliteral">"Couldn't delete file '%s'.  I don't know why."</span>, path);
01035                             MessageBox(win, msg, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
01036                         }
01037                     } <span class="keywordflow">else</span> {
01038                         <span class="keywordflow">if</span> (Options.confirmDeleteDirs) {
01039                             sprintf(msg, <span class="stringliteral">"'%s' is a directory. Are you sure you want to delete it and all its contents?"</span>, path);
01040                             doit = (MessageBox(win, msg, <span class="stringliteral">"Question"</span>, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES);
01041                         } <span class="keywordflow">else</span>
01042                             doit = TRUE;
01043                         <span class="keywordflow">if</span> (doit)
01044                             <span class="keywordflow">if</span> (! RemoveAmiDirectoryRecursive(ci-&gt;vol, ci-&gt;vol-&gt;curDirPtr, path) ) {
01045                                 sprintf(msg, <span class="stringliteral">"Deletion of directory '%s' was not entirely successful."</span>, path);
01046                                 MessageBox(win, msg, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
01047                             }
01048                     }
01049                 }
01050             }
01051         }
01052     }
01053 
01054     <span class="comment">/* refresh dir listing */</span>
01055     SendMessage(win, WM_COMMAND, ID_VIEW_REFRESH, 0l);
01056 }
01057 
01058 
01059 BOOL ChildShowUndeletable(HWND win)
01060 <span class="comment">/*  Show undeletable files.</span>
01061 <span class="comment"> */</span>
01062 {
01063     <span class="keyword">struct </span>List     *list, *cell;
01064     <span class="keyword">struct </span>GenBlock *block;
01065     <span class="keywordtype">char</span>            undel[MAX_PATH];
01066     <span class="keywordtype">int</span>             pos;
01067 
01068 
01069     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
01070     cell = list = adfGetDelEnt(ci-&gt;vol);
01071     <span class="keywordflow">if</span>(cell == NULL){
01072         MessageBox(win, <span class="stringliteral">"There are no undeletable files or directories on this volume"</span>, <span class="stringliteral">"Undelete Message"</span>, 
01073                     MB_ICONINFORMATION|MB_OK);
01074         <span class="keywordflow">return</span> FALSE;
01075     }
01076     <span class="comment">// Read undeletable files list.</span>
01077     <span class="keywordflow">while</span>(cell){
01078         block =(<span class="keyword">struct </span>GenBlock*) cell-&gt;content;
01079         sprintf(undel, <span class="stringliteral">"%s"</span>,block-&gt;name);
01080         <span class="keywordflow">if</span>(adfCheckEntry(ci-&gt;vol, block-&gt;sect, 0) == RC_OK){
01081             <span class="keywordflow">if</span>(block-&gt;secType == 2)
01082                 pos = LVAddItem(ci-&gt;lv, undel, ICO_AMIDIR);
01083             <span class="keywordflow">else</span>
01084                 pos = LVAddItem(ci-&gt;lv, undel, ICO_AMIFILE);
01085             ListView_SetItemState(ci-&gt;lv, pos, LVIS_CUT, LVIS_CUT);
01086             pos++;
01087         }
01088         
01089         cell = cell-&gt;next;
01090     }
01091   
01092     adfFreeDelList(list);
01093     <span class="comment">// Prevent multiple listings.</span>
01094     EnableMenuItem(hMenu, ID_VIEW_SHOWUNDELETABLEFILES, MF_GRAYED);
01095     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_VIEW_SHOWUNDELETABLEFILES, MAKELONG(FALSE, 0));
01096     bUndeleting = TRUE;
01097     <span class="keywordflow">return</span> TRUE;
01098 }
01099 
01100 
01101 BOOL ChildUndelete(HWND win)
01102 <span class="comment">/*  Undelete files.</span>
01103 <span class="comment"> */</span>
01104 {
01105     <span class="keyword">struct </span>List     *list, *cell;
01106     <span class="keyword">struct </span>GenBlock *block;
01107     <span class="keywordtype">int</span>             index, iNumSelected, i;
01108     <span class="keywordtype">char</span>            buf[MAX_PATH];
01109     CHILDINFO       *ci = (CHILDINFO *)GetWindowLong(win, 0);
01110 
01111     
01112 <span class="comment">//  index = LVGetItemFocused(ci-&gt;lv);</span>
01113     iNumSelected = ListView_GetSelectedCount(ci-&gt;lv);
01114     index = ListView_GetNextItem(ci-&gt;lv, -1, LVNI_CUT|LVNI_SELECTED);                   <span class="comment">// Get first selected file.</span>
01115     <span class="keywordflow">for</span>(i = 0;i &lt; iNumSelected;i++){
01116         LVGetItemCaption(ci-&gt;lv, buf, <span class="keyword">sizeof</span>(buf), index);
01117         cell = list = adfGetDelEnt(ci-&gt;vol);
01118         <span class="comment">// Read undeletable files list.</span>
01119         <span class="keywordflow">while</span>(cell){
01120             block =(<span class="keyword">struct </span>GenBlock*) cell-&gt;content;
01121             <span class="comment">// Check if names match and undelete if they do.</span>
01122             <span class="keywordflow">if</span>(strcmp(buf, block-&gt;name) == 0){
01123                 <span class="keywordflow">if</span>(adfUndelEntry(ci-&gt;vol, ci-&gt;vol-&gt;curDirPtr, block-&gt;sect) == RC_OK){   <span class="comment">// Undelete it.</span>
01124                     ListView_SetItemState(ci-&gt;lv, index, 0, LVIS_CUT);                  <span class="comment">// Reset list state.</span>
01125                     ChildUpdate(win);
01126                 }
01127                 <span class="keywordflow">break</span>;
01128             }
01129             cell = cell-&gt;next;
01130         }
01131         index = ListView_GetNextItem(ci-&gt;lv, index, LVNI_CUT|LVNI_SELECTED);            <span class="comment">// Get next selected file.</span>
01132     }
01133     adfFreeDelList(list);
01134     EnableMenuItem(hMenu, ID_ACTION_UNDELETE, MF_GRAYED);                               <span class="comment">// Reset menu and toolbar.</span>
01135     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_UNDELETE, MAKELONG(FALSE, 0));
01136     <span class="keywordflow">return</span> TRUE;
01137 }
01138 
01139 
01140 BOOL ChildRename(HWND win, LV_DISPINFO *di)
01141 <span class="comment">/* rename a file</span>
01142 <span class="comment"> */</span>
01143 {
01144     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
01145     <span class="keywordtype">char</span> oldName[MAX_PATH];
01146     <span class="keywordtype">char</span> newName[MAX_PATH];
01147     <span class="keywordtype">char</span> newPath[MAX_PATH];
01148     <span class="keywordtype">char</span> oldPath[MAX_PATH];
01149     <span class="keywordtype">char</span> errMess[MAX_PATH * 2];
01150 
01151     LVGetItemCaption(ci-&gt;lv, oldName, <span class="keyword">sizeof</span>(oldName), di-&gt;item.iItem);
01152 
01153     <span class="keywordflow">if</span> (di-&gt;item.pszText == NULL)
01154         <span class="keywordflow">return</span> FALSE;
01155 
01156     strcpy(newName, di-&gt;item.pszText);
01157 
01158     <span class="keywordflow">if</span> (GetWindowLong(win, GWL_USERDATA) == CHILD_WINLISTER) {
01159         strcpy(oldPath, ci-&gt;curDir);
01160         strcat(oldPath, oldName);
01161         strcpy(newPath, ci-&gt;curDir);
01162         strcat(newPath, newName);
01163         <span class="keywordflow">if</span> (! MoveFile(oldPath, newPath)) {
01164             sprintf(errMess, <span class="stringliteral">"Could not rename '%s' to '%s' for some reason."</span>, oldName, newName);
01165             MessageBox(win, errMess, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
01166             <span class="keywordflow">return</span> FALSE;
01167         } <span class="keywordflow">else</span> {
01168             ListView_SetItemText(ci-&gt;lv, di-&gt;item.iItem, 0, newName);
01169         }
01170     }
01171 
01172     <span class="keywordflow">if</span> (GetWindowLong(win, GWL_USERDATA) == CHILD_AMILISTER) {
01173         <span class="keywordflow">if</span> (adfRenameEntry(ci-&gt;vol, ci-&gt;vol-&gt;curDirPtr, oldName, ci-&gt;vol-&gt;curDirPtr, newName) != RC_OK) {
01174             sprintf(errMess, <span class="stringliteral">"Could not rename '%s' to '%s'.  Don't ask me why."</span>, oldName, newName);
01175             MessageBox(win, errMess, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
01176             <span class="keywordflow">return</span> FALSE;
01177         } <span class="keywordflow">else</span> {
01178             ListView_SetItemText(ci-&gt;lv, di-&gt;item.iItem, 0, newName);
01179         }
01180     }
01181     <span class="keywordflow">return</span> TRUE;
01182 }
01183 
01184 BOOL ChildCheckRename(HWND win, LV_DISPINFO *di)
01185 <span class="comment">/* return TRUE if item can be edited, FALSE otherwise */</span>
01187 {
01188     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
01189     <span class="keywordtype">int</span> ii;
01190 
01191     ii = LVGetItemImageIndex(ci-&gt;lv, di-&gt;item.iItem);
01192 
01193     <span class="keywordflow">if</span> (ii &gt;= ICO_DRIVEHD)
01194         <span class="keywordflow">return</span> FALSE;
01195     <span class="keywordflow">else</span>
01196         <span class="keywordflow">return</span> TRUE;
01197 }
01198 
01199 <span class="keywordtype">void</span> ChildMakeDir(HWND win)
01200 <span class="comment">/* create a new dir "New Directory" and call the rename function on it</span>
01201 <span class="comment"> */</span>
01202 {
01203     CHILDINFO *ci = (CHILDINFO *)GetWindowLong(win, 0);
01204     <span class="keywordtype">char</span> newPath[MAX_PATH];
01205     <span class="keywordtype">int</span> pos;
01206 
01207     <span class="keywordflow">if</span> (GetWindowLong(win, GWL_USERDATA) == CHILD_AMILISTER) {
01208         <span class="keywordflow">if</span> (adfCreateDir(ci-&gt;vol, ci-&gt;vol-&gt;curDirPtr, <span class="stringliteral">"New Directory"</span>) != RC_OK) {
01209             MessageBox(win, <span class="stringliteral">"Couldn't create directory, the volume is probably full."</span>,
01210                 <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
01211             <span class="keywordflow">return</span>;
01212         }
01213     } <span class="keywordflow">else</span> {
01214         strcpy(newPath, ci-&gt;curDir);
01215         strcat(newPath, <span class="stringliteral">"New Directory"</span>);
01216         <span class="keywordflow">if</span> (! CreateDirectory(newPath, NULL)) {
01217             MessageBox(win, <span class="stringliteral">"Couldn't create directory."</span>, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
01218             <span class="keywordflow">return</span>;
01219         }
01220     }
01221 
01222     pos = LVAddItem(ci-&gt;lv, <span class="stringliteral">"New Directory"</span>, (GetWindowLong(win, GWL_USERDATA) ==
01223      CHILD_AMILISTER) ? ICO_AMIDIR : ICO_WINDIR);
01224     
01225     LVAddSubItem(ci-&gt;lv, (GetWindowLong(win, GWL_USERDATA) ==
01226      CHILD_AMILISTER) ? <span class="stringliteral">"RWED"</span> : <span class="stringliteral">""</span>, pos, 2);
01227     ListView_EditLabel(ci-&gt;lv, pos);
01228         
01229 }
01230 
01231 BOOL RemoveDirectoryRecursive(<span class="keywordtype">char</span> *path)
01232 {
01233     WIN32_FIND_DATA wfd;
01234     HANDLE search;
01235     <span class="keywordtype">char</span> curPath[MAX_PATH * 2];
01236     <span class="keywordtype">char</span> searchPath[MAX_PATH * 2];
01237     <span class="keywordtype">char</span> subdir[MAX_PATH * 2];
01238 
01239     strcpy(curPath, path);
01240     sprintf(searchPath, <span class="stringliteral">"%s\\*"</span>, curPath);
01241 
01242     search = FindFirstFile(searchPath, &amp;wfd);
01243     <span class="keywordflow">if</span> (search == INVALID_HANDLE_VALUE)
01244         <span class="keywordflow">return</span> FALSE;
01245 
01246     <span class="keywordflow">do</span> {
01247         <span class="comment">/* if current entry is a dir, and isn't the current or parent dir, then delete it */</span>
01248         <span class="keywordflow">if</span> (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
01249             <span class="keywordflow">if</span> ( !((wfd.cFileName[1] == 0) &amp;&amp; (wfd.cFileName[0] == <span class="charliteral">'.'</span>)) )
01250                 <span class="keywordflow">if</span> ( !((wfd.cFileName[2] == 0) &amp;&amp; (wfd.cFileName[1] == <span class="charliteral">'.'</span>) &amp;&amp; (wfd.cFileName[0] == <span class="charliteral">'.'</span>)) ) {
01251                     sprintf(subdir, <span class="stringliteral">"%s\\%s"</span>, curPath, wfd.cFileName);
01252                     RemoveDirectoryRecursive(subdir);
01253                 }
01254         } <span class="keywordflow">else</span> {
01255             sprintf(subdir, <span class="stringliteral">"%s\\%s"</span>, curPath, wfd.cFileName);
01256             DeleteFile(subdir); 
01257         }
01258 
01259     } <span class="keywordflow">while</span> (FindNextFile(search, &amp;wfd));
01260 
01261     FindClose(search);
01262 
01263     <span class="keywordflow">return</span> RemoveDirectory(curPath);
01264 }
01265 
01266 BOOL RemoveAmiDirectoryRecursive(<span class="keyword">struct</span> Volume *vol, SECTNUM curDir, <span class="keywordtype">char</span> *path)
01267 {
01268     <span class="keyword">struct </span>List *list;
01269     <span class="keyword">struct </span>Entry *ent;
01270 
01271     adfChangeDir(vol, path);
01272     list = adfGetDirEnt(vol, vol-&gt;curDirPtr);
01273 
01274     <span class="keywordflow">while</span> (list) {
01275         ent = (<span class="keyword">struct </span>Entry *)list-&gt;content;
01276         <span class="keywordflow">if</span> (ent-&gt;type == ST_DIR) {
01277             <span class="comment">/* it's a dir - recurse into it */</span>
01278             RemoveAmiDirectoryRecursive(vol, vol-&gt;curDirPtr, ent-&gt;name);
01279         } <span class="keywordflow">else</span> {
01280             <span class="comment">/* it's a file or a link, just remove it */</span>
01281             adfRemoveEntry(vol, vol-&gt;curDirPtr, ent-&gt;name);
01282         }
01283         adfFreeEntry(list-&gt;content);
01284         list = list-&gt;next;
01285     }
01286     freeList(list);
01287 
01288     adfParentDir(vol);
01289 
01290     <span class="keywordflow">if</span> (adfRemoveEntry(vol, curDir, path) != RC_OK)
01291         <span class="keywordflow">return</span> FALSE;
01292 
01293     <span class="keywordflow">return</span> TRUE;
01294 }
01295 
01296 
01297 <span class="keywordtype">int</span> GetFileFromADF(<span class="keyword">struct</span> Volume *vol, <span class="keywordtype">char</span> *szFileName)
01298 <span class="comment">// Reads a file from an ADF and writes it to Windows.</span>
01299 <span class="comment">// Taken from an example in the ADFLib documentation by Laurent Clevy.</span>
01300 <span class="comment">// Input:  The volume structure of the current ADF, the name of the file to extract.</span>
01301 <span class="comment">// Output: </span>
01302 {
01303     <span class="keyword">struct </span>File*    file;
01304     FILE*           out;
01305     <span class="keywordtype">long</span>            n;
01306     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>   buf[600];
01307     <span class="keywordtype">int</span>             len = 600;
01308 
01309     <span class="comment">/* a device and a volume 'vol' has been successfully mounted */</span>
01310     <span class="comment">/* opens the Amiga file */</span>
01311     file = adfOpenFile(vol, szFileName,<span class="stringliteral">"r"</span>);
01312 
01313     <span class="keywordflow">if</span>(!file){ 
01314         <span class="comment">/* frees resources and exits */</span>
01315         <span class="keywordflow">return</span>(-1);                     <span class="comment">//******************** value here</span>
01316     }
01317     <span class="comment">/* opens the output classic file */</span>
01318     out = fopen(szFileName,<span class="stringliteral">"wb"</span>);
01319     <span class="keywordflow">if</span>(!out){
01320         adfCloseFile(file);
01321         <span class="keywordflow">return</span>(-2);                     <span class="comment">//******************** value here</span>
01322     }
01323     
01324     <span class="comment">/* copy the Amiga file into the standard file, 600 bytes per 600 bytes */</span>
01325     n = adfReadFile(file, len, buf);
01326     <span class="keywordflow">while</span>(!adfEndOfFile(file)){
01327         fwrite(buf, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>), n, out);
01328         n = adfReadFile(file, len, buf);
01329     }
01330     <span class="comment">/* even if the EOF is reached, some bytes may need to be written */</span>
01331     <span class="keywordflow">if</span>(n &gt; 0)
01332         fwrite(buf, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>), n, out);
01333     <span class="comment">/* closes the standard file */</span>
01334     fclose(out);
01335     <span class="comment">/* closes the Amiga file */</span>
01336     adfCloseFile(file);
01337     <span class="keywordflow">return</span>(0);                          <span class="comment">//******************** value here</span>
01338 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:39 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

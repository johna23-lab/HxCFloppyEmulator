<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>inflate.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>inflate.c</h1><div class="fragment"><pre>00001 <span class="comment">/* inflate.c -- zlib interface to inflate modules</span>
00002 <span class="comment"> * Copyright (C) 1995-2002 Mark Adler</span>
00003 <span class="comment"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
00004 <span class="comment"> */</span>
00005 
00006 <span class="preprocessor">#include "zutil.h"</span>
00007 <span class="preprocessor">#include "infblock.h"</span>
00008 
00009 <span class="keyword">struct </span>inflate_blocks_state {<span class="keywordtype">int</span> dummy;}; <span class="comment">/* for buggy compilers */</span>
00010 
00011 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
00012       METHOD,   <span class="comment">/* waiting for method byte */</span>
00013       FLAG,     <span class="comment">/* waiting for flag byte */</span>
00014       DICT4,    <span class="comment">/* four dictionary check bytes to go */</span>
00015       DICT3,    <span class="comment">/* three dictionary check bytes to go */</span>
00016       DICT2,    <span class="comment">/* two dictionary check bytes to go */</span>
00017       DICT1,    <span class="comment">/* one dictionary check byte to go */</span>
00018       DICT0,    <span class="comment">/* waiting for inflateSetDictionary */</span>
00019       BLOCKS,   <span class="comment">/* decompressing blocks */</span>
00020       CHECK4,   <span class="comment">/* four check bytes to go */</span>
00021       CHECK3,   <span class="comment">/* three check bytes to go */</span>
00022       CHECK2,   <span class="comment">/* two check bytes to go */</span>
00023       CHECK1,   <span class="comment">/* one check byte to go */</span>
00024       DONE,     <span class="comment">/* finished check, done */</span>
00025       BAD}      <span class="comment">/* got an error--stay here */</span>
00026 inflate_mode;
00027 
00028 <span class="comment">/* inflate private state */</span>
00029 <span class="keyword">struct </span>internal_state {
00030 
00031   <span class="comment">/* mode */</span>
00032   inflate_mode  mode;   <span class="comment">/* current inflate mode */</span>
00033 
00034   <span class="comment">/* mode dependent information */</span>
00035   <span class="keyword">union </span>{
00036     uInt method;        <span class="comment">/* if FLAGS, method byte */</span>
00037     <span class="keyword">struct </span>{
00038       uLong was;                <span class="comment">/* computed check value */</span>
00039       uLong need;               <span class="comment">/* stream check value */</span>
00040     } check;            <span class="comment">/* if CHECK, check values to compare */</span>
00041     uInt marker;        <span class="comment">/* if BAD, inflateSync's marker bytes count */</span>
00042   } sub;        <span class="comment">/* submode */</span>
00043 
00044   <span class="comment">/* mode independent information */</span>
00045   <span class="keywordtype">int</span>  nowrap;          <span class="comment">/* flag for no wrapper */</span>
00046   uInt wbits;           <span class="comment">/* log2(window size)  (8..15, defaults to 15) */</span>
00047   inflate_blocks_statef 
00048     *blocks;            <span class="comment">/* current inflate_blocks state */</span>
00049 
00050 };
00051 
00052 
00053 <span class="keywordtype">int</span> ZEXPORT inflateReset(z)
00054 z_streamp z;
00055 {
00056   <span class="keywordflow">if</span> (z == Z_NULL || z-&gt;state == Z_NULL)
00057     <span class="keywordflow">return</span> Z_STREAM_ERROR;
00058   z-&gt;total_in = z-&gt;total_out = 0;
00059   z-&gt;msg = Z_NULL;
00060   z-&gt;state-&gt;mode = z-&gt;state-&gt;nowrap ? BLOCKS : METHOD;
00061   inflate_blocks_reset(z-&gt;state-&gt;blocks, z, Z_NULL);
00062   Tracev((stderr, <span class="stringliteral">"inflate: reset\n"</span>));
00063   <span class="keywordflow">return</span> Z_OK;
00064 }
00065 
00066 
00067 <span class="keywordtype">int</span> ZEXPORT inflateEnd(z)
00068 z_streamp z;
00069 {
00070   <span class="keywordflow">if</span> (z == Z_NULL || z-&gt;state == Z_NULL || z-&gt;zfree == Z_NULL)
00071     <span class="keywordflow">return</span> Z_STREAM_ERROR;
00072   <span class="keywordflow">if</span> (z-&gt;state-&gt;blocks != Z_NULL)
00073     inflate_blocks_free(z-&gt;state-&gt;blocks, z);
00074   ZFREE(z, z-&gt;state);
00075   z-&gt;state = Z_NULL;
00076   Tracev((stderr, <span class="stringliteral">"inflate: end\n"</span>));
00077   <span class="keywordflow">return</span> Z_OK;
00078 }
00079 
00080 
00081 <span class="keywordtype">int</span> ZEXPORT inflateInit2_(z, w, version, stream_size)
00082 z_streamp z;
00083 <span class="keywordtype">int</span> w;
00084 <span class="keyword">const</span> <span class="keywordtype">char</span> *version;
00085 <span class="keywordtype">int</span> stream_size;
00086 {
00087   <span class="keywordflow">if</span> (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
00088       stream_size != <span class="keyword">sizeof</span>(z_stream))
00089       <span class="keywordflow">return</span> Z_VERSION_ERROR;
00090 
00091   <span class="comment">/* initialize state */</span>
00092   <span class="keywordflow">if</span> (z == Z_NULL)
00093     <span class="keywordflow">return</span> Z_STREAM_ERROR;
00094   z-&gt;msg = Z_NULL;
00095   <span class="keywordflow">if</span> (z-&gt;zalloc == Z_NULL)
00096   {
00097     z-&gt;zalloc = zcalloc;
00098     z-&gt;opaque = (voidpf)0;
00099   }
00100   <span class="keywordflow">if</span> (z-&gt;zfree == Z_NULL) z-&gt;zfree = zcfree;
00101   <span class="keywordflow">if</span> ((z-&gt;state = (<span class="keyword">struct </span>internal_state FAR *)
00102        ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
00103     <span class="keywordflow">return</span> Z_MEM_ERROR;
00104   z-&gt;state-&gt;blocks = Z_NULL;
00105 
00106   <span class="comment">/* handle undocumented nowrap option (no zlib header or check) */</span>
00107   z-&gt;state-&gt;nowrap = 0;
00108   <span class="keywordflow">if</span> (w &lt; 0)
00109   {
00110     w = - w;
00111     z-&gt;state-&gt;nowrap = 1;
00112   }
00113 
00114   <span class="comment">/* set window size */</span>
00115   <span class="keywordflow">if</span> (w &lt; 8 || w &gt; 15)
00116   {
00117     inflateEnd(z);
00118     <span class="keywordflow">return</span> Z_STREAM_ERROR;
00119   }
00120   z-&gt;state-&gt;wbits = (uInt)w;
00121 
00122   <span class="comment">/* create inflate_blocks state */</span>
00123   <span class="keywordflow">if</span> ((z-&gt;state-&gt;blocks =
00124       inflate_blocks_new(z, z-&gt;state-&gt;nowrap ? Z_NULL : adler32, (uInt)1 &lt;&lt; w))
00125       == Z_NULL)
00126   {
00127     inflateEnd(z);
00128     <span class="keywordflow">return</span> Z_MEM_ERROR;
00129   }
00130   Tracev((stderr, <span class="stringliteral">"inflate: allocated\n"</span>));
00131 
00132   <span class="comment">/* reset state */</span>
00133   inflateReset(z);
00134   <span class="keywordflow">return</span> Z_OK;
00135 }
00136 
00137 
00138 <span class="keywordtype">int</span> ZEXPORT inflateInit_(z, version, stream_size)
00139 z_streamp z;
00140 <span class="keyword">const</span> <span class="keywordtype">char</span> *version;
00141 <span class="keywordtype">int</span> stream_size;
00142 {
00143   <span class="keywordflow">return</span> inflateInit2_(z, DEF_WBITS, version, stream_size);
00144 }
00145 
00146 
00147 <span class="preprocessor">#define NEEDBYTE {if(z-&gt;avail_in==0)return r;r=f;}</span>
00148 <span class="preprocessor"></span><span class="preprocessor">#define NEXTBYTE (z-&gt;avail_in--,z-&gt;total_in++,*z-&gt;next_in++)</span>
00149 <span class="preprocessor"></span>
00150 <span class="keywordtype">int</span> ZEXPORT inflate(z, f)
00151 z_streamp z;
00152 <span class="keywordtype">int</span> f;
00153 {
00154   <span class="keywordtype">int</span> r;
00155   uInt b;
00156 
00157   <span class="keywordflow">if</span> (z == Z_NULL || z-&gt;state == Z_NULL || z-&gt;next_in == Z_NULL)
00158     <span class="keywordflow">return</span> Z_STREAM_ERROR;
00159   f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
00160   r = Z_BUF_ERROR;
00161   <span class="keywordflow">while</span> (1) <span class="keywordflow">switch</span> (z-&gt;state-&gt;mode)
00162   {
00163     <span class="keywordflow">case</span> METHOD:
00164       NEEDBYTE
00165       <span class="keywordflow">if</span> (((z-&gt;state-&gt;sub.method = NEXTBYTE) &amp; 0xf) != Z_DEFLATED)
00166       {
00167         z-&gt;state-&gt;mode = BAD;
00168         z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"unknown compression method"</span>;
00169         z-&gt;state-&gt;sub.marker = 5;       <span class="comment">/* can't try inflateSync */</span>
00170         <span class="keywordflow">break</span>;
00171       }
00172       <span class="keywordflow">if</span> ((z-&gt;state-&gt;sub.method &gt;&gt; 4) + 8 &gt; z-&gt;state-&gt;wbits)
00173       {
00174         z-&gt;state-&gt;mode = BAD;
00175         z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"invalid window size"</span>;
00176         z-&gt;state-&gt;sub.marker = 5;       <span class="comment">/* can't try inflateSync */</span>
00177         <span class="keywordflow">break</span>;
00178       }
00179       z-&gt;state-&gt;mode = FLAG;
00180     <span class="keywordflow">case</span> FLAG:
00181       NEEDBYTE
00182       b = NEXTBYTE;
00183       <span class="keywordflow">if</span> (((z-&gt;state-&gt;sub.method &lt;&lt; 8) + b) % 31)
00184       {
00185         z-&gt;state-&gt;mode = BAD;
00186         z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"incorrect header check"</span>;
00187         z-&gt;state-&gt;sub.marker = 5;       <span class="comment">/* can't try inflateSync */</span>
00188         <span class="keywordflow">break</span>;
00189       }
00190       Tracev((stderr, <span class="stringliteral">"inflate: zlib header ok\n"</span>));
00191       <span class="keywordflow">if</span> (!(b &amp; PRESET_DICT))
00192       {
00193         z-&gt;state-&gt;mode = BLOCKS;
00194         <span class="keywordflow">break</span>;
00195       }
00196       z-&gt;state-&gt;mode = DICT4;
00197     <span class="keywordflow">case</span> DICT4:
00198       NEEDBYTE
00199       z-&gt;state-&gt;sub.check.need = (uLong)NEXTBYTE &lt;&lt; 24;
00200       z-&gt;state-&gt;mode = DICT3;
00201     <span class="keywordflow">case</span> DICT3:
00202       NEEDBYTE
00203       z-&gt;state-&gt;sub.check.need += (uLong)NEXTBYTE &lt;&lt; 16;
00204       z-&gt;state-&gt;mode = DICT2;
00205     <span class="keywordflow">case</span> DICT2:
00206       NEEDBYTE
00207       z-&gt;state-&gt;sub.check.need += (uLong)NEXTBYTE &lt;&lt; 8;
00208       z-&gt;state-&gt;mode = DICT1;
00209     <span class="keywordflow">case</span> DICT1:
00210       NEEDBYTE
00211       z-&gt;state-&gt;sub.check.need += (uLong)NEXTBYTE;
00212       z-&gt;adler = z-&gt;state-&gt;sub.check.need;
00213       z-&gt;state-&gt;mode = DICT0;
00214       <span class="keywordflow">return</span> Z_NEED_DICT;
00215     <span class="keywordflow">case</span> DICT0:
00216       z-&gt;state-&gt;mode = BAD;
00217       z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"need dictionary"</span>;
00218       z-&gt;state-&gt;sub.marker = 0;       <span class="comment">/* can try inflateSync */</span>
00219       <span class="keywordflow">return</span> Z_STREAM_ERROR;
00220     <span class="keywordflow">case</span> BLOCKS:
00221       r = inflate_blocks(z-&gt;state-&gt;blocks, z, r);
00222       <span class="keywordflow">if</span> (r == Z_DATA_ERROR)
00223       {
00224         z-&gt;state-&gt;mode = BAD;
00225         z-&gt;state-&gt;sub.marker = 0;       <span class="comment">/* can try inflateSync */</span>
00226         <span class="keywordflow">break</span>;
00227       }
00228       <span class="keywordflow">if</span> (r == Z_OK)
00229         r = f;
00230       <span class="keywordflow">if</span> (r != Z_STREAM_END)
00231         <span class="keywordflow">return</span> r;
00232       r = f;
00233       inflate_blocks_reset(z-&gt;state-&gt;blocks, z, &amp;z-&gt;state-&gt;sub.check.was);
00234       <span class="keywordflow">if</span> (z-&gt;state-&gt;nowrap)
00235       {
00236         z-&gt;state-&gt;mode = DONE;
00237         <span class="keywordflow">break</span>;
00238       }
00239       z-&gt;state-&gt;mode = CHECK4;
00240     <span class="keywordflow">case</span> CHECK4:
00241       NEEDBYTE
00242       z-&gt;state-&gt;sub.check.need = (uLong)NEXTBYTE &lt;&lt; 24;
00243       z-&gt;state-&gt;mode = CHECK3;
00244     <span class="keywordflow">case</span> CHECK3:
00245       NEEDBYTE
00246       z-&gt;state-&gt;sub.check.need += (uLong)NEXTBYTE &lt;&lt; 16;
00247       z-&gt;state-&gt;mode = CHECK2;
00248     <span class="keywordflow">case</span> CHECK2:
00249       NEEDBYTE
00250       z-&gt;state-&gt;sub.check.need += (uLong)NEXTBYTE &lt;&lt; 8;
00251       z-&gt;state-&gt;mode = CHECK1;
00252     <span class="keywordflow">case</span> CHECK1:
00253       NEEDBYTE
00254       z-&gt;state-&gt;sub.check.need += (uLong)NEXTBYTE;
00255 
00256       <span class="keywordflow">if</span> (z-&gt;state-&gt;sub.check.was != z-&gt;state-&gt;sub.check.need)
00257       {
00258         z-&gt;state-&gt;mode = BAD;
00259         z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"incorrect data check"</span>;
00260         z-&gt;state-&gt;sub.marker = 5;       <span class="comment">/* can't try inflateSync */</span>
00261         <span class="keywordflow">break</span>;
00262       }
00263       Tracev((stderr, <span class="stringliteral">"inflate: zlib check ok\n"</span>));
00264       z-&gt;state-&gt;mode = DONE;
00265     <span class="keywordflow">case</span> DONE:
00266       <span class="keywordflow">return</span> Z_STREAM_END;
00267     <span class="keywordflow">case</span> BAD:
00268       <span class="keywordflow">return</span> Z_DATA_ERROR;
00269     <span class="keywordflow">default</span>:
00270       <span class="keywordflow">return</span> Z_STREAM_ERROR;
00271   }
00272 <span class="preprocessor">#ifdef NEED_DUMMY_RETURN</span>
00273 <span class="preprocessor"></span>  <span class="keywordflow">return</span> Z_STREAM_ERROR;  <span class="comment">/* Some dumb compilers complain without this */</span>
00274 <span class="preprocessor">#endif</span>
00275 <span class="preprocessor"></span>}
00276 
00277 
00278 <span class="keywordtype">int</span> ZEXPORT inflateSetDictionary(z, dictionary, dictLength)
00279 z_streamp z;
00280 <span class="keyword">const</span> Bytef *dictionary;
00281 uInt  dictLength;
00282 {
00283   uInt length = dictLength;
00284 
00285   <span class="keywordflow">if</span> (z == Z_NULL || z-&gt;state == Z_NULL || z-&gt;state-&gt;mode != DICT0)
00286     <span class="keywordflow">return</span> Z_STREAM_ERROR;
00287 
00288   <span class="keywordflow">if</span> (adler32(1L, dictionary, dictLength) != z-&gt;adler) <span class="keywordflow">return</span> Z_DATA_ERROR;
00289   z-&gt;adler = 1L;
00290 
00291   <span class="keywordflow">if</span> (length &gt;= ((uInt)1&lt;&lt;z-&gt;state-&gt;wbits))
00292   {
00293     length = (1&lt;&lt;z-&gt;state-&gt;wbits)-1;
00294     dictionary += dictLength - length;
00295   }
00296   inflate_set_dictionary(z-&gt;state-&gt;blocks, dictionary, length);
00297   z-&gt;state-&gt;mode = BLOCKS;
00298   <span class="keywordflow">return</span> Z_OK;
00299 }
00300 
00301 
00302 <span class="keywordtype">int</span> ZEXPORT inflateSync(z)
00303 z_streamp z;
00304 {
00305   uInt n;       <span class="comment">/* number of bytes to look at */</span>
00306   Bytef *p;     <span class="comment">/* pointer to bytes */</span>
00307   uInt m;       <span class="comment">/* number of marker bytes found in a row */</span>
00308   uLong r, w;   <span class="comment">/* temporaries to save total_in and total_out */</span>
00309 
00310   <span class="comment">/* set up */</span>
00311   <span class="keywordflow">if</span> (z == Z_NULL || z-&gt;state == Z_NULL)
00312     <span class="keywordflow">return</span> Z_STREAM_ERROR;
00313   <span class="keywordflow">if</span> (z-&gt;state-&gt;mode != BAD)
00314   {
00315     z-&gt;state-&gt;mode = BAD;
00316     z-&gt;state-&gt;sub.marker = 0;
00317   }
00318   <span class="keywordflow">if</span> ((n = z-&gt;avail_in) == 0)
00319     <span class="keywordflow">return</span> Z_BUF_ERROR;
00320   p = z-&gt;next_in;
00321   m = z-&gt;state-&gt;sub.marker;
00322 
00323   <span class="comment">/* search */</span>
00324   <span class="keywordflow">while</span> (n &amp;&amp; m &lt; 4)
00325   {
00326     <span class="keyword">static</span> <span class="keyword">const</span> Byte mark[4] = {0, 0, 0xff, 0xff};
00327     <span class="keywordflow">if</span> (*p == mark[m])
00328       m++;
00329     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (*p)
00330       m = 0;
00331     <span class="keywordflow">else</span>
00332       m = 4 - m;
00333     p++, n--;
00334   }
00335 
00336   <span class="comment">/* restore */</span>
00337   z-&gt;total_in += p - z-&gt;next_in;
00338   z-&gt;next_in = p;
00339   z-&gt;avail_in = n;
00340   z-&gt;state-&gt;sub.marker = m;
00341 
00342   <span class="comment">/* return no joy or set up to restart on a new block */</span>
00343   <span class="keywordflow">if</span> (m != 4)
00344     <span class="keywordflow">return</span> Z_DATA_ERROR;
00345   r = z-&gt;total_in;  w = z-&gt;total_out;
00346   inflateReset(z);
00347   z-&gt;total_in = r;  z-&gt;total_out = w;
00348   z-&gt;state-&gt;mode = BLOCKS;
00349   <span class="keywordflow">return</span> Z_OK;
00350 }
00351 
00352 
00353 <span class="comment">/* Returns true if inflate is currently at the end of a block generated</span>
00354 <span class="comment"> * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP</span>
00355 <span class="comment"> * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH</span>
00356 <span class="comment"> * but removes the length bytes of the resulting empty stored block. When</span>
00357 <span class="comment"> * decompressing, PPP checks that at the end of input packet, inflate is</span>
00358 <span class="comment"> * waiting for these length bytes.</span>
00359 <span class="comment"> */</span>
00360 <span class="keywordtype">int</span> ZEXPORT inflateSyncPoint(z)
00361 z_streamp z;
00362 {
00363   <span class="keywordflow">if</span> (z == Z_NULL || z-&gt;state == Z_NULL || z-&gt;state-&gt;blocks == Z_NULL)
00364     <span class="keywordflow">return</span> Z_STREAM_ERROR;
00365   <span class="keywordflow">return</span> inflate_blocks_sync_point(z-&gt;state-&gt;blocks);
00366 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:41 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

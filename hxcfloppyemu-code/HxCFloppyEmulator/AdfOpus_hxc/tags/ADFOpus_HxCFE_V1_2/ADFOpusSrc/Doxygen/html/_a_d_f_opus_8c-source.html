<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ADFOpus.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>ADFOpus.c</h1><a href="_a_d_f_opus_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00035 <span class="preprocessor">#define OEMRESOURCE</span>
00036 <span class="preprocessor"></span><span class="preprocessor">#include "Pch.h"</span>
00037 
00038 <span class="preprocessor">#include "ADFOpus.h"</span>
00039 <span class="preprocessor">#include "Init.h"</span>
00040 <span class="preprocessor">#include "ChildCommon.h"</span>
00041 <span class="preprocessor">#include "About.h"</span>
00042 <span class="preprocessor">#include "Utils.h"</span>
00043 <span class="preprocessor">#include "ListView.h"</span>
00044 <span class="preprocessor">#include "New.h"</span>
00045 <span class="preprocessor">#include "VolInfo.h"</span>
00046 <span class="preprocessor">#include "BatchConvert.h"</span>
00047 <span class="preprocessor">#include "Options.h"</span>
00048 <span class="preprocessor">#include "Properties.h"</span>
00049 <span class="preprocessor">#include &lt;direct.h&gt;</span>
00050 <span class="preprocessor">#include "winbase.h"</span>
00051 <span class="preprocessor">#include "Install.h"</span>
00052 <span class="preprocessor">#include "FDI.h"</span>
00053 <span class="preprocessor">#include "Bootblock.h"</span>
00054 
00055 <span class="preprocessor">#include "ADFLib.h"</span>
00056 <span class="preprocessor">#include "Help\AdfOpusHlp.h"</span>
00057 
00058 <span class="keyword">extern</span> <span class="keywordtype">char</span>* adfGetVersionNumber(); <span class="comment">/* this shouldn't be here */</span>
00059 
00060 ENV_DECLARATION;
00061 
00062 <span class="comment">/* function prototypes */</span>
00063 LRESULT CALLBACK MainWinProc(HWND, UINT, WPARAM, LPARAM);
00064 BOOL CreateProc(HWND);
00065 BOOL CommandProc(HWND, WPARAM, LPARAM);
00066 <span class="keywordtype">void</span> PaintProc(HWND);
00067 <span class="keywordtype">void</span> DestroyProc(HWND);
00068 <span class="keywordtype">void</span> MainWinOnDragOver(<span class="keywordtype">int</span>, <span class="keywordtype">int</span>);
00069 <span class="keywordtype">void</span> MainWinOnDrop();
00070 <span class="keywordtype">void</span> CopyAmi2Win(<span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *, <span class="keyword">struct</span> Volume *, <span class="keywordtype">long</span>);
00071 BOOL CopyAmiDir2Win(<span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *, <span class="keyword">struct</span> Volume *);
00072 <span class="keywordtype">void</span> CopyWin2Ami(<span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *, <span class="keyword">struct</span> Volume *, <span class="keywordtype">long</span>);
00073 BOOL CopyWinDir2Ami(<span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *, <span class="keyword">struct</span> Volume *);
00074 <span class="keywordtype">void</span> CopyWin2Win(<span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *);
00075 BOOL CopyWinDir2Win(<span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *, <span class="keywordtype">char</span> *);
00076 <span class="keywordtype">void</span> CopyAmi2Ami(<span class="keywordtype">char</span> *, <span class="keyword">struct</span> Volume *, <span class="keyword">struct</span> Volume *, <span class="keywordtype">long</span>);
00077 BOOL CopyAmiDir2Ami(<span class="keywordtype">char</span> *, <span class="keyword">struct</span> Volume *, <span class="keyword">struct</span> Volume *);
00078 <span class="keywordtype">void</span> GetTooltipText(<span class="keywordtype">char</span> *, <span class="keywordtype">int</span>);
00079 <span class="keywordtype">void</span> doCopy(<span class="keywordtype">void</span> *);
00080 LRESULT CALLBACK copyProgressProc(HWND, UINT, WPARAM, LPARAM);
00081 <span class="keywordtype">long</span> AOGetFileSize(CHILDINFO *, <span class="keywordtype">char</span> *);
00082 
00083 
00084 <span class="comment">/* global variables (too many) */</span>
00085 HINSTANCE       instance = NULL;
00086 HWND            ghwndFrame;
00087 HWND            ghwndMDIClient = NULL;
00088 HIMAGELIST      ghwndImageList = NULL;
00089 HWND            ghwndTB = NULL;
00090 HWND            ghwndSB = NULL;
00091 <span class="keywordtype">char</span>            gstrFileName[MAX_PATH * 2];
00092 BOOL            gbToolbarVisible = TRUE;
00093 BOOL            gbStatusBarVisible = TRUE;
00094 BOOL            gbFirstTime = FALSE;
00095 BOOL            gbIsDragging = FALSE;
00096 HWND            ghwndDragSource, ghwndDragTarget = NULL;
00097 HCURSOR         ghcurNormal, ghcurNo, ghcurDrag;
00098 <span class="keywordtype">int</span>             volToOpen;
00099 <span class="keywordtype">int</span>             Percent;
00100 CHILDINFO       *CopySource, *CopyDest;
00101 <span class="keywordtype">int</span>             Done;
00102 UINT            Timer;
00103 <span class="keywordtype">long</span>            CurrentSect;
00104 <span class="keyword">struct </span>OPTIONS  Options;
00105 BOOL            ReadOnly;
00106 
00107 BOOL            bCmdLineArgs = FALSE;
00108 <span class="keywordtype">char</span>            gstrCmdLineArgs[MAX_PATH * 2];          <span class="comment">// Command line argument string.</span>
00109 
00110 
00111 <span class="keywordtype">int</span> PASCAL WinMain(HINSTANCE inst, HINSTANCE prevInst, LPSTR cmdLine, <span class="keywordtype">int</span> show)
00112 <span class="comment">/* windows entry point function - initialises everything and enters the</span>
00113 <span class="comment"> * message loop</span>
00114 <span class="comment"> */</span>
00115 {
00116     MSG msg;
00117 
00118     instance = inst;
00119     <span class="keywordflow">if</span> (! RegisterAppClass(inst))
00120         <span class="keywordflow">return</span> 1;
00121 
00122     <span class="comment">/* load the common control dll */</span>
00123     InitCommonControls();
00124 
00125     <span class="comment">/* load cursors */</span>
00126     ghcurNormal = LoadCursor(NULL, IDC_ARROW);
00127     ghcurNo = LoadCursor(NULL, IDC_NO);
00128     ghcurDrag = LoadCursor(instance, MAKEINTRESOURCE(IDC_POINTER_COPY));
00129 
00130     <span class="comment">/* get user options */</span>
00131     ReadOptions();
00132 
00133     <span class="comment">/* initialise ADFLib */</span>
00134     adfEnvInitDefault();
00135     adfSetEnvFct(ADFError, ADFWarning, ADFVerbose);
00136 
00137     adfEnv.rwhAccess = ADFAccess;
00138     adfEnv.progressBar = ADFProgress;
00139     adfEnv.useRWAccess = TRUE;
00140     adfEnv.useProgressBar = TRUE;
00141     adfEnv.useDirCache = Options.useDirCache;
00142 
00143     <span class="comment">// Create path to temp directory in Opus root directory.</span>
00144     getcwd(dirTemp, 100);
00145     strcpy(dirOpus, dirTemp);
00146     strcat(dirTemp, <span class="stringliteral">"\\opustemp\\"</span>);
00147 
00148     <span class="comment">/* the main loop */</span>
00149     msg.wParam = 1;
00150 
00151     <span class="comment">// Store command line arguments for processing in WM_CREATE.</span>
00152     strcpy(gstrCmdLineArgs, cmdLine);
00153 
00154     ghwndFrame = CreateAppWindow(inst);
00155     <span class="keywordflow">if</span> (ghwndFrame)
00156     {
00157         ShowWindow(ghwndFrame, show);
00158         UpdateWindow(ghwndFrame);
00159 
00160         <span class="comment">/* standard message loop for MDI apps */</span>
00161         <span class="keywordflow">while</span>(GetMessage(&amp;msg, NULL, 0, 0))
00162         {
00163             <span class="keywordflow">if</span>(! TranslateMDISysAccel(ghwndMDIClient, &amp;msg)) {
00164                 TranslateMessage(&amp;msg);
00165                 DispatchMessage(&amp;msg);
00166             }
00167         }
00168     }
00169 
00170     <span class="comment">/* clean up ADFLib */</span>
00171     adfEnvCleanUp();
00172 
00173     <span class="comment">/* save options */</span>
00174     WriteOptions();
00175 
00176     <span class="comment">/* unregister all the classes we registered (not really needed but...) */</span>
00177     UnregisterAllClasses(inst);
00178 
00179     <span class="keywordflow">return</span> msg.wParam;
00180 }
00181 
00182 LRESULT CALLBACK MainWinProc(HWND hwndFrame, UINT wMsg, WPARAM wParam, LPARAM lParam)
00183 <span class="comment">/* handles all messages for the main window and passes messages on to the</span>
00184 <span class="comment"> * MDI child windows where applicable</span>
00185 <span class="comment"> */</span>
00186 {
00187     HANDLE          hDrop;
00188     <span class="keywordtype">int</span>             i, iCount;
00189     NMHDR           *nmhdr = (NMHDR *) lParam;
00190     LPTOOLTIPTEXT   lpTTT;
00191     DWORD           dwVersion;                          <span class="comment">// OS version.</span>
00192 
00193 
00194     <span class="keywordflow">switch</span>(wMsg)
00195     {
00196     <span class="keywordflow">case</span> WM_CREATE:
00197         CreateProc(hwndFrame);
00198         
00199         <span class="comment">// Open files given on the command line.</span>
00200         <span class="keywordflow">if</span>(strcmp(gstrCmdLineArgs, <span class="stringliteral">""</span>) != 0){
00201 
00202             <span class="keywordtype">char</span> sep[] = <span class="stringliteral">" "</span>;
00203             <span class="keywordtype">char</span> *token;
00204             <span class="keywordtype">char</span> ArgArray[20][MAX_PATH * 2];
00205         
00206             bCmdLineArgs = TRUE;
00207 
00208             <span class="comment">// Get argument sub-strings as disk file names.</span>
00209             i = 0;
00210             token = strtok(gstrCmdLineArgs, sep);   
00211             <span class="keywordflow">while</span>(token != NULL){
00212                 <span class="comment">/* While there are tokens in "string" */</span>      
00213                 strcpy(ArgArray[i], token);
00214                 <span class="comment">/* Get next token: */</span>      
00215                 token = strtok(NULL, sep);
00216                 i++;
00217             }
00218 
00219             <span class="comment">/* open an Amiga lister child window for each file */</span>
00220             <span class="keywordflow">for</span>(iCount = 0;iCount &lt; i;iCount++){
00221                 strcpy(gstrFileName, ArgArray[iCount]);
00222                 <a class="code" href="_child_common_8c.html#a46">CreateChildWin</a>(ghwndMDIClient, CHILD_AMILISTER);
00223             }
00224         }
00225         <span class="keywordflow">break</span>;
00226 
00227     <span class="keywordflow">case</span> WM_PAINT:
00228 
00229         <span class="comment">// Push the Windows lister to the back and cascade the open windows if file names have been given on the</span>
00230         <span class="comment">// command line. Reset flag afterwards as this is a once-only event.</span>
00231         <span class="keywordflow">if</span>(bCmdLineArgs){
00232             HWND hwndActiveChild;
00233             hwndActiveChild = (HWND) SendMessage(ghwndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM) NULL);
00234             SendMessage(ghwndMDIClient, WM_MDINEXT, (WPARAM)hwndActiveChild, 0l);
00235             SendMessage(ghwndMDIClient, WM_MDICASCADE, 0, 0l);
00236             bCmdLineArgs = FALSE;
00237         }
00238 
00239         PaintProc(hwndFrame);
00240         <span class="keywordflow">break</span>;
00241     <span class="keywordflow">case</span> WM_DESTROY:
00242         DestroyProc(hwndFrame);
00243         <span class="keywordflow">break</span>;
00244     <span class="keywordflow">case</span> WM_QUIT:
00245         _chdir(dirOpus);
00246         _rmdir(dirTemp);
00247         <span class="keywordflow">break</span>;
00248 
00249     <span class="keywordflow">case</span> WM_COMMAND:
00250         <span class="keywordflow">if</span> (! CommandProc(hwndFrame, wParam, lParam))
00251             <span class="keywordflow">return</span>(DefFrameProc(hwndFrame, ghwndMDIClient, wMsg, wParam, lParam));
00252         <span class="keywordflow">break</span>;
00253     <span class="keywordflow">case</span> WM_DROPFILES:
00254         <span class="comment">/* file(s) dropped from explorer */</span>
00255         hDrop = (HANDLE) wParam;
00256 
00257         <span class="comment">/* find out how many files were dropped */</span>
00258         iCount = DragQueryFile(hDrop, 0xFFFFFFFF, gstrFileName, <span class="keyword">sizeof</span>(gstrFileName));
00259 
00260         <span class="comment">/* open an Amiga lister child window for each file */</span>
00261         <span class="keywordflow">for</span> (i = 0 ; i &lt; iCount ; i++) {
00262             DragQueryFile(hDrop, i, gstrFileName, <span class="keyword">sizeof</span>(gstrFileName));
00263             <a class="code" href="_child_common_8c.html#a46">CreateChildWin</a>(ghwndMDIClient, CHILD_AMILISTER);            
00264         }
00265         <span class="keywordflow">break</span>;
00266     <span class="keywordflow">case</span> WM_SIZE:
00267         <span class="comment">/* resize toolbar and status bar */</span>
00268         SendMessage(ghwndTB, WM_SIZE, 0, 0);
00269         SendMessage(ghwndSB, WM_SIZE, 0, 0);
00270 
00271         ResizeMDIClientWin(hwndFrame, ghwndMDIClient);
00272 
00273         <span class="keywordflow">if</span> (! gbFirstTime) {
00274             <a class="code" href="_child_common_8c.html#a46">CreateChildWin</a>(ghwndMDIClient, CHILD_WINLISTER);
00275             gbFirstTime = TRUE;
00276         }
00277         <span class="keywordflow">break</span>;
00278     <span class="keywordflow">case</span> WM_INITMENU:
00279         ghmenuMain = (HMENU)wParam;
00280         UpdateMenuItems(ghmenuMain);
00281         CheckMenuItem(ghmenuMain, ID_VIEW_TOOL_BAR, gbToolbarVisible ? MF_CHECKED : MF_UNCHECKED);
00282         CheckMenuItem(ghmenuMain, ID_VIEW_THE_STATUSBAR, gbStatusBarVisible ?MF_CHECKED : MF_UNCHECKED);
00283 
00284         <span class="comment">// Disable the Disk2FDI interface for NT, 2K and XP.</span>
00285         dwVersion = GetVersion();
00286         <span class="comment">// High order bit is 1 (0x80000000) for Windows NT, 2K or XP. If less, we have 95, 98 or ME.</span>
00287         <span class="keywordflow">if</span>(dwVersion &lt; 0x80000000)                
00288             EnableMenuItem(ghmenuMain, ID_TOOLS_DISK2FDI, MF_GRAYED);
00289 
00290         SetMenuBitmaps(instance, ghmenuMain);
00291         <span class="keywordflow">break</span>;
00292     <span class="keywordflow">case</span> WM_LBUTTONUP:
00293         <span class="keywordflow">if</span> (gbIsDragging)
00294             MainWinOnDrop();
00295         <span class="keywordflow">break</span>;
00296     <span class="keywordflow">case</span> WM_MOUSEMOVE:
00297         <span class="keywordflow">if</span> (gbIsDragging)
00298             MainWinOnDragOver(LOWORD(lParam), HIWORD(lParam));
00299         <span class="keywordflow">break</span>;
00300     <span class="keywordflow">case</span> WM_KEYDOWN:
00301         <span class="keywordflow">if</span> (gbIsDragging)
00302             MainWinOnDrop();
00303         <span class="keywordflow">break</span>;
00304     <span class="keywordflow">case</span> WM_NOTIFY:
00305         <span class="keywordflow">switch</span> (nmhdr-&gt;code) {
00306         <span class="keywordflow">case</span> TTN_NEEDTEXT:
00307             lpTTT = (LPTOOLTIPTEXT)lParam;
00308             GetTooltipText(lpTTT-&gt;szText, wParam);
00309         }
00310         <span class="keywordflow">break</span>;
00311     <span class="keywordflow">default</span>:
00312         <span class="keywordflow">return</span>(DefFrameProc(hwndFrame, ghwndMDIClient, wMsg, wParam, lParam));
00313     }
00314     <span class="keywordflow">return</span>(0l);
00315 }
00316 
00317 
00318 BOOL CreateProc(HWND hwndFrame)
00319 <span class="comment">/* handler for the WM_CREATE message - creates the toolbar, status bar and</span>
00320 <span class="comment"> * MDI client window</span>
00321 <span class="comment"> */</span>
00322 {
00323     ghwndTB = CreateToolBar(hwndFrame);
00324     ghwndSB = CreateStatusBar(hwndFrame);
00325     ghwndImageList = CreateImageList(hwndFrame);
00326     ghwndMDIClient = CreateMDIClientWindow(hwndFrame);
00327 
00328     <span class="comment">/* register this window as a shell drop target */</span>
00329     DragAcceptFiles(hwndFrame, TRUE);
00330 
00331     <span class="keywordflow">return</span> TRUE;
00332 }
00333 
00334 BOOL CommandProc(HWND win, WPARAM wp, LONG lp)
00335 <span class="comment">/* handles WM_COMMAND messages for the main window</span>
00336 <span class="comment"> */</span>
00337 {
00338     CHILDINFO *ci;
00339 
00340     HWND hwndActiveChild;
00341 
00342     hwndActiveChild = (HWND) SendMessage(ghwndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM) NULL);
00343     ci = (CHILDINFO *)GetWindowLong(hwndActiveChild, 0);
00344     <span class="keywordflow">switch</span>(wp)
00345     {
00346     <span class="comment">/* commands that are passed on to active MDI child window */</span>
00347     <span class="keywordflow">case</span> ID_EDIT_SELECTALL:
00348     <span class="keywordflow">case</span> ID_EDIT_SELECTNONE:
00349     <span class="keywordflow">case</span> ID_EDIT_INVERTSELECTION:
00350     <span class="keywordflow">case</span> ID_VIEW_REFRESH:
00351     <span class="keywordflow">case</span> ID_VIEW_SHOWUNDELETABLEFILES:
00352     <span class="keywordflow">case</span> ID_ACTION_UPONELEVEL:
00353     <span class="keywordflow">case</span> ID_ACTION_RENAME:
00354     <span class="keywordflow">case</span> ID_ACTION_DELETE:
00355     <span class="keywordflow">case</span> ID_ACTION_UNDELETE:
00356     <span class="keywordflow">case</span> ID_ACTION_NEWDIRECTORY:
00357         hwndActiveChild = (HWND) SendMessage(ghwndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM) NULL);
00358         SendMessage(hwndActiveChild, WM_COMMAND, wp, 0);
00359         <span class="keywordflow">break</span>;
00360 
00361     <span class="comment">/* commands from the file menu */</span>
00362     <span class="keywordflow">case</span> ID_FIL_NEW:
00363         DialogBox(instance, MAKEINTRESOURCE(IDD_NEWVOLUME), win, (DLGPROC) NewDlgProc);
00364         <span class="keywordflow">break</span>;      
00365     <span class="keywordflow">case</span> ID_FIL_OPEN:
00366         <span class="keywordflow">if</span> (OpenDlg(win))
00367             <a class="code" href="_child_common_8c.html#a46">CreateChildWin</a>(ghwndMDIClient, CHILD_AMILISTER);
00368         <span class="keywordflow">break</span>;
00369     <span class="keywordflow">case</span> ID_FIL_OPENDEVICE:
00370         strcpy(gstrFileName, <span class="stringliteral">"|H1"</span>); 
00371         <a class="code" href="_child_common_8c.html#a46">CreateChildWin</a>(ghwndMDIClient, CHILD_AMILISTER);
00372         <span class="keywordflow">break</span>;
00373     <span class="keywordflow">case</span> ID_FIL_CLOSE:
00374         hwndActiveChild = (HWND) SendMessage(ghwndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM) NULL);
00375         SendMessage(hwndActiveChild, WM_CLOSE, 0, 0);
00376         <span class="keywordflow">break</span>;
00377     <span class="keywordflow">case</span> ID_FIL_INFORMATION:
00378 
00379 <span class="preprocessor">#ifdef DEBUG_INFO</span>
00380 <span class="preprocessor"></span>        <span class="comment">// Debug info dialogue using adfVolumeInfoWin().</span>
00381         hwndActiveChild = (HWND) SendMessage(ghwndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM) NULL);
00382         ci = (CHILDINFO *)GetWindowLong(hwndActiveChild, 0);
00383         adfVolumeInfoWin(win, ci-&gt;vol);
00384 <span class="preprocessor">#else</span>
00385 <span class="preprocessor"></span>        <span class="comment">// Normal dialogue.</span>
00386         DialogBox(instance, MAKEINTRESOURCE(IDD_VOLINFO), win, (DLGPROC)VolInfoDlgProc);
00387 <span class="preprocessor">#endif</span>
00388 <span class="preprocessor"></span>
00389         <span class="keywordflow">break</span>;
00390     <span class="keywordflow">case</span> ID_FIL_EXIT:
00391         SendMessage(win, WM_CLOSE, 0, 0l);
00392         <span class="keywordflow">break</span>;
00393 
00394     <span class="comment">/* commands from the view menu */</span>
00395     <span class="keywordflow">case</span> ID_VIEW_TOOL_BAR:
00396         gbToolbarVisible = ! gbToolbarVisible;
00397         SendMessage(ghwndFrame, WM_INITMENU, (WPARAM) ghmenuMain, 0);
00398         ShowWindow(ghwndTB, gbToolbarVisible ? SW_SHOW : SW_HIDE);
00399         ResizeMDIClientWin();           
00400         <span class="keywordflow">break</span>;
00401     <span class="keywordflow">case</span> ID_VIEW_THE_STATUSBAR:
00402         gbStatusBarVisible = ! gbStatusBarVisible;
00403         SendMessage(ghwndFrame, WM_INITMENU, (WPARAM) ghmenuMain, 0);
00404         ShowWindow(ghwndSB, gbStatusBarVisible ? SW_SHOW : SW_HIDE);
00405         ResizeMDIClientWin();
00406         <span class="keywordflow">break</span>;
00407     <span class="keywordflow">case</span> ID_VIEW_NEWWINDOWSLISTER:
00408         <a class="code" href="_child_common_8c.html#a46">CreateChildWin</a>(ghwndMDIClient, CHILD_WINLISTER);
00409         <span class="keywordflow">break</span>;
00410 
00411     <span class="comment">/* commands from the Action menu */</span>
00412     <span class="keywordflow">case</span> ID_ACTION_PROPERTIES:
00413     <span class="comment">// The file properties dialogue.</span>
00414         <span class="keywordflow">if</span>(ci-&gt;isAmi)
00415             DialogBox(instance, MAKEINTRESOURCE(IDD_FILEPROPERTIES_AMI), win, (DLGPROC)PropertiesProcAmi);
00416         <span class="keywordflow">else</span>
00417             DialogBox(instance, MAKEINTRESOURCE(IDD_FILEPROPERTIES_WIN), win, (DLGPROC)PropertiesProcWin);
00418         <span class="keywordflow">break</span>;
00419 
00420     <span class="comment">/* commands from the Tools menu */</span>
00421     <span class="keywordflow">case</span> ID_TOOLS_BATCHCONVERTER:
00422         DialogBox(instance, MAKEINTRESOURCE(IDD_BATCHCONVERTER), win, (DLGPROC)BatchConvertProc);
00423         <span class="keywordflow">break</span>;
00424 
00425     <span class="keywordflow">case</span> ID_TOOLS_DISPLAYBOOTBLOCK:
00426         DialogBox(instance, MAKEINTRESOURCE(IDD_DISPLAY_BOOTBLOCK), win, (DLGPROC)DisplayBootblockProc);
00427         <span class="keywordflow">break</span>;
00428     
00429     <span class="keywordflow">case</span> ID_TOOLS_INSTALL:
00430         InstallBootBlock(win, ci-&gt;vol);
00431         EnableMenuItem(ghmenuMain, ID_TOOLS_INSTALL, MF_GRAYED);
00432 
00433         <span class="keywordflow">break</span>;
00434 
00435     <span class="keywordflow">case</span> ID_TOOLS_DISK2FDI:
00436         DialogBox(instance, MAKEINTRESOURCE(IDD_DISK2FDI), win, (DLGPROC)Disk2FDIProc);
00437         <span class="keywordflow">break</span>;
00438 
00439     <span class="keywordflow">case</span> ID_TOOLS_OPTIONS:
00440         DialogBox(instance, MAKEINTRESOURCE(IDD_OPTIONS), win, (DLGPROC)OptionsProc);
00441         <span class="keywordflow">break</span>;
00442 
00443     <span class="comment">/* commands from the Window menu */</span>
00444     <span class="keywordflow">case</span> ID_WIN_CASCADE:
00445         SendMessage(ghwndMDIClient, WM_MDICASCADE, 0, 0l);
00446         <span class="keywordflow">break</span>;
00447     <span class="keywordflow">case</span> ID_WIN_TILEHORIZONTAL:
00448         SendMessage(ghwndMDIClient, WM_MDITILE, MDITILE_HORIZONTAL, 0l);
00449         <span class="keywordflow">break</span>;
00450     <span class="keywordflow">case</span> ID_WIN_TILEVERTICAL:
00451         SendMessage(ghwndMDIClient, WM_MDITILE, MDITILE_VERTICAL, 0l);
00452         <span class="keywordflow">break</span>;
00453     <span class="keywordflow">case</span> ID_WIN_ARRANGEICONS:
00454         SendMessage(ghwndMDIClient, WM_MDIICONARRANGE, 0, 0l);
00455         <span class="keywordflow">break</span>;
00456     <span class="keywordflow">case</span> ID_WIN_CLOSEALL:
00457         hwndActiveChild = (HWND) SendMessage(ghwndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM) NULL);
00458         <span class="keywordflow">while</span> (hwndActiveChild != NULL) {
00459             SendMessage(hwndActiveChild, WM_CLOSE, 0, 0l);
00460             hwndActiveChild = (HWND) SendMessage(ghwndMDIClient, WM_MDIGETACTIVE, 0, (LPARAM) NULL);
00461         }
00462         <span class="keywordflow">break</span>;
00463 
00464     <span class="comment">/* commands from the Help menu */</span>
00465     <span class="keywordflow">case</span> ID_HELP_ABOUT:
00466         DialogBox(instance, MAKEINTRESOURCE(IDD_ABOUT), win, (DLGPROC) AboutDlgProc);
00467         <span class="keywordflow">break</span>;
00468 
00469     <span class="comment">// Implement help menu items.</span>
00470     <span class="keywordflow">case</span> ID_HELP_HELPTOPICS:
00471         WinHelp(win, <span class="stringliteral">"ADFOpus.hlp&gt;Opus_win"</span>, HELP_FINDER, 0L);
00472         <span class="keywordflow">return</span> TRUE;
00473     
00474     <span class="keywordflow">case</span> ID_HELP_MAIN:
00475         WinHelp(win, <span class="stringliteral">"ADFOpus.hlp&gt;Opus_win"</span>, HELP_CONTEXT, IDH_MAIN);
00476         <span class="keywordflow">return</span> TRUE;
00477     
00478     <span class="keywordflow">default</span>:
00479         <span class="keywordflow">return</span>(FALSE);
00480     }
00481     <span class="keywordflow">return</span>(TRUE);
00482 }
00483 
00484 VOID PaintProc(HWND win)
00485 <span class="comment">/* handles WM_PAINT messages for the MDI client window</span>
00486 <span class="comment"> */</span>
00487 {
00488     HDC dc;
00489     PAINTSTRUCT ps;
00490 
00491     dc = BeginPaint(win, &amp;ps);
00492     <span class="keywordflow">if</span>(dc)
00493         EndPaint(win, &amp;ps);
00494 
00495     <span class="keywordflow">return</span>;
00496 }
00497 
00498 VOID DestroyProc(HWND hwndFrame)
00499 <span class="comment">/* game over</span>
00500 <span class="comment"> */</span>
00501 {
00502     WIN32_FIND_DATA fileFound;
00503     HANDLE          hFile;
00504     <span class="keywordtype">char</span>            lpFileName[MAX_PATH];
00505 
00506     <span class="comment">// Delete any files left in temp directory.</span>
00507     strcpy(tempName , dirTemp);
00508     strcat(tempName, <span class="stringliteral">"*.*"</span>);            <span class="comment">// Include any files extracted by GetFileFromADF().</span>
00509     strcpy(lpFileName, tempName);
00510 
00511     hFile = FindFirstFile(lpFileName, &amp;fileFound);
00512     <span class="keywordflow">if</span>(hFile != INVALID_HANDLE_VALUE){
00513         strcpy(tempName, dirTemp);
00514         strcat(tempName, fileFound.cFileName);
00515         remove(tempName);
00516         <span class="keywordflow">while</span>(FindNextFile(hFile, &amp;fileFound)){
00517             strcpy(tempName, dirTemp);
00518                 strcat(tempName, fileFound.cFileName);
00519             remove(tempName);
00520         }
00521     }
00522     FindClose(hFile);
00523 
00524     _chdir(dirOpus);
00525     _rmdir(dirTemp);                                        <span class="comment">// Remove "Temp" directory.</span>
00526     
00527     WinHelp(hwndFrame, <span class="stringliteral">"ADFOpus.hlp"</span>, HELP_QUIT, 0L);       <span class="comment">// Free help resources.</span>
00528 <span class="comment">//  DeleteObject(bmpMenu);                                  // Delete menu bitmap.</span>
00529 
00530     PostQuitMessage(0);
00531 
00532     <span class="keywordflow">return</span>;
00533 }
00534 
00535 <span class="comment">/* the callback functions for ADFLib - simply redirects the messages to a</span>
00536 <span class="comment"> * standard Windows message box</span>
00537 <span class="comment"> */</span>
00538 VOID ADFError(<span class="keywordtype">char</span> *strMessage)
00539 {
00540     MessageBox(ghwndFrame, strMessage, <span class="stringliteral">"ADFLib Error"</span>, MB_OK | MB_ICONERROR);
00541 }
00542 
00543 VOID ADFWarning(<span class="keywordtype">char</span> *strMessage)
00544 {
00545     MessageBox(ghwndFrame, strMessage, <span class="stringliteral">"ADFLib Warning"</span>, MB_OK | MB_ICONWARNING);
00546 }
00547 
00548 VOID ADFVerbose(<span class="keywordtype">char</span> *strMessage)
00549 {
00550     MessageBox(ghwndFrame, strMessage, <span class="stringliteral">"ADFLib Message"</span>, MB_OK | MB_ICONINFORMATION);
00551 }
00552 
00553 <span class="keywordtype">void</span> ADFAccess(SECTNUM physical, SECTNUM logical, BOOL write)
00554 {
00555     CurrentSect = physical;
00556 }
00557 
00558 <span class="keywordtype">void</span> ADFProgress(<span class="keywordtype">int</span> perCentDone)
00559 {
00560     Percent = perCentDone;
00561 }
00562 
00563 <span class="keywordtype">void</span> MainWinOnDragOver(<span class="keywordtype">int</span> x, <span class="keywordtype">int</span> y)
00564 {
00565     POINT pt;
00566     HWND target = NULL;
00567     <span class="keywordtype">long</span> type;
00568     RECT rTB;
00569     CHILDINFO *ci;
00570 
00571     pt.x = x;
00572     pt.y = y;
00573 
00574     <span class="comment">/* the co-ords are from the frame window - convert them to MDI client co-ords */</span>
00575     <span class="keywordflow">if</span> (gbToolbarVisible) {
00576         GetWindowRect(ghwndTB, &amp;rTB);
00577         pt.y -= (rTB.bottom - rTB.top);
00578     }
00579 
00580     target = ChildWindowFromPoint(ghwndMDIClient, pt);
00581 
00582     <span class="keywordflow">if</span> ((target == NULL) || (target == ghwndDragSource)) {
00583         SetCursor(ghcurNo);
00584         ghwndDragTarget = NULL;
00585     } <span class="keywordflow">else</span> {
00586         type = GetWindowLong(target, GWL_USERDATA);
00587         ghwndDragTarget = NULL;
00588 
00589         <span class="keywordflow">if</span> ((type == CHILD_AMILISTER) || (type == CHILD_WINLISTER)) {
00590             ci = (CHILDINFO *)GetWindowLong(target, 0);
00591             <span class="keywordflow">if</span> (! ( (type == CHILD_WINLISTER) &amp;&amp; (ci-&gt;atRoot) ) )
00592                 ghwndDragTarget = target;
00593             <span class="keywordflow">if</span> (ci-&gt;readOnly)
00594                 ghwndDragTarget = NULL;
00595         }
00596         SetCursor((ghwndDragTarget == NULL) ? ghcurNo : ghcurDrag);
00597     }
00598 }
00599 
00600 <span class="keywordtype">void</span> MainWinOnDrop()
00601 {
00602     <span class="comment">/* stop the dragging action */</span>
00603     gbIsDragging = FALSE;
00604     ReleaseCapture();
00605     SetCursor(ghcurNormal);
00606 
00607     <span class="keywordflow">if</span> (ghwndDragTarget == NULL)
00608         <span class="keywordflow">return</span>;
00609 
00610     CopySource = (CHILDINFO *)GetWindowLong(ghwndDragSource, 0);
00611     CopyDest = (CHILDINFO *)GetWindowLong(ghwndDragTarget, 0);
00612     Done = FALSE;
00613     Percent = 0;
00614 
00615     _beginthread(doCopy, 0, ghwndFrame);
00616     DialogBox(instance, MAKEINTRESOURCE(IDD_PROGRESS2), ghwndFrame, (DLGPROC)copyProgressProc);
00617 
00618     <span class="comment">/* refresh destination lister */</span>
00619     SendMessage(ghwndDragTarget, WM_COMMAND, ID_VIEW_REFRESH, (LPARAM)NULL);
00620 }
00621 
00622 <span class="keywordtype">void</span> doCopy(<span class="keywordtype">void</span> *arse)
00623 {
00624     <span class="keywordtype">char</span> curFile[256];
00625     <span class="keywordtype">char</span> destPath[MAX_PATH];
00626     <span class="keywordtype">char</span> srcPath[MAX_PATH];
00627     <span class="keywordtype">int</span> i;
00628     BOOL isDir;
00629 
00630     <span class="keywordflow">for</span> (i = 0 ; i &lt; ListView_GetItemCount(CopySource-&gt;lv) ; i++) {
00631         <span class="keywordflow">if</span> (LVIsItemSelected(CopySource-&gt;lv, i)) {
00632             LVGetItemCaption(CopySource-&gt;lv, curFile, <span class="keyword">sizeof</span>(curFile), i);
00633             isDir = ((LVGetItemImageIndex(CopySource-&gt;lv, i) == ICO_AMIDIR) || (LVGetItemImageIndex(CopySource-&gt;lv, i)
00634                 == ICO_WINDIR));
00635 
00636             <span class="comment">/* ami to win */</span>
00637             <span class="keywordflow">if</span> ((CopySource-&gt;isAmi == TRUE) &amp;&amp; (CopyDest-&gt;isAmi == FALSE)) {
00638                 strcpy(destPath, CopyDest-&gt;curDir);
00639                 strcat(destPath, curFile);
00640                 <span class="keywordflow">if</span> (isDir)
00641                     CopyAmiDir2Win(curFile, destPath, CopySource-&gt;vol);
00642                 <span class="keywordflow">else</span>
00643                     CopyAmi2Win(curFile, destPath, CopySource-&gt;vol, AOGetFileSize(CopySource, curFile));
00644             }
00645 
00646             <span class="comment">/* win to ami */</span>
00647             <span class="keywordflow">if</span> ((CopySource-&gt;isAmi == FALSE) &amp;&amp; (CopyDest-&gt;isAmi == TRUE)) {
00648                 strcpy(srcPath, CopySource-&gt;curDir);
00649                 strcat(srcPath, curFile);
00650                 <span class="keywordflow">if</span> (isDir)
00651                     CopyWinDir2Ami(curFile, srcPath, CopyDest-&gt;vol);
00652                 <span class="keywordflow">else</span>
00653                     CopyWin2Ami(curFile, srcPath, CopyDest-&gt;vol, AOGetFileSize(CopySource, curFile));
00654             }
00655 
00656             <span class="comment">/* win to win */</span>
00657             <span class="keywordflow">if</span> ((CopySource-&gt;isAmi == FALSE) &amp;&amp; (CopyDest-&gt;isAmi == FALSE)) {
00658                 strcpy(srcPath, CopySource-&gt;curDir);
00659                 strcpy(destPath, CopyDest-&gt;curDir);
00660                 <span class="keywordflow">if</span> (isDir)
00661                     CopyWinDir2Win(srcPath, destPath, curFile);
00662                 <span class="keywordflow">else</span> {
00663                     strcat(srcPath, curFile);
00664                     strcat(destPath, curFile);
00665                     CopyWin2Win(srcPath, destPath);
00666                 }
00667             }
00668 
00669             <span class="comment">/* ami to ami */</span>
00670             <span class="keywordflow">if</span> ((CopySource-&gt;isAmi == TRUE) &amp;&amp; (CopyDest-&gt;isAmi == TRUE))
00671                 <span class="keywordflow">if</span> (isDir)
00672                     CopyAmiDir2Ami(curFile, CopySource-&gt;vol, CopyDest-&gt;vol);
00673                 <span class="keywordflow">else</span>
00674                     CopyAmi2Ami(curFile, CopySource-&gt;vol, CopyDest-&gt;vol, AOGetFileSize(CopySource, curFile));
00675         }
00676     }
00677 
00678     Done = TRUE;
00679 }
00680 
00681 <span class="keywordtype">void</span> CopyAmi2Win(<span class="keywordtype">char</span> *fileName, <span class="keywordtype">char</span> *destPath, <span class="keyword">struct</span> Volume *vol, <span class="keywordtype">long</span> fileSize)
00682 {
00683     <span class="keyword">struct </span>File *amiFile;
00684     <span class="keywordtype">long</span> act;
00685     DWORD dwActual;
00686     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[600];
00687     HANDLE winFile;
00688     <span class="keywordtype">long</span> bread = 0l;
00689 
00690     winFile = CreateFile(destPath, GENERIC_WRITE, 0, NULL,
00691         CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
00692     <span class="keywordflow">if</span> (winFile == INVALID_HANDLE_VALUE) {
00693         MessageBox(ghwndFrame, <span class="stringliteral">"Couldn't create destination file."</span>,
00694         <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00695         <span class="keywordflow">return</span>;
00696     }
00697 
00698     amiFile = adfOpenFile(vol, fileName, <span class="stringliteral">"r"</span>);
00699     <span class="keywordflow">if</span> (! amiFile) {
00700         CloseHandle(winFile);
00701         MessageBox(ghwndFrame, <span class="stringliteral">"Error opening source file (probably"</span>
00702             <span class="stringliteral">" a bug)"</span>, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00703         <span class="keywordflow">return</span>;
00704     }
00705 
00706     <span class="comment">/* copy data */</span>
00707     <span class="keywordflow">while</span> (! adfEndOfFile(amiFile)) {
00708         act = adfReadFile(amiFile, <span class="keyword">sizeof</span>(buf), buf);
00709         bread += <span class="keyword">sizeof</span>(buf);
00710         <span class="keywordflow">if</span> (! WriteFile(winFile, buf, act, &amp;dwActual, NULL)) {
00711             CloseHandle(winFile);
00712             MessageBox(ghwndFrame, <span class="stringliteral">"Error writing destination"</span>
00713             <span class="stringliteral">" file (disk full, maybe?)"</span>, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00714             <span class="keywordflow">return</span>;
00715         }
00716         Percent = (100 * bread) / fileSize;
00717     }
00718     adfCloseFile(amiFile);
00719     CloseHandle(winFile);
00720 }
00721 
00722 <span class="keywordtype">void</span> CopyWin2Ami(<span class="keywordtype">char</span> *fileName, <span class="keywordtype">char</span> *srcPath, <span class="keyword">struct</span> Volume *vol, <span class="keywordtype">long</span> fileSize)
00723 {
00724     <span class="keyword">struct </span>File *amiFile;
00725     HANDLE winFile;
00726     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[600];
00727     DWORD act;
00728     <span class="keywordtype">char</span> errMess[200];
00729     <span class="keywordtype">long</span> bread = 0, bn;
00730 
00731     bn = adfFileRealSize(fileSize, LOGICAL_BLOCK_SIZE, NULL, NULL);
00732     <span class="keywordflow">if</span> (adfCountFreeBlocks(vol) &lt; bn) {
00733         MessageBox(ghwndFrame, <span class="stringliteral">"Could not copy file. There is insufficient "</span>
00734             <span class="stringliteral">"free space on the destination volume."</span>, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00735         <span class="keywordflow">return</span>;
00736     }
00737 
00738     <span class="comment">/* open source file */</span>
00739     winFile = CreateFile(srcPath, GENERIC_READ, 0, NULL, OPEN_EXISTING,
00740         0, NULL);
00741     <span class="keywordflow">if</span> (winFile == INVALID_HANDLE_VALUE) {
00742         MessageBox(ghwndFrame, <span class="stringliteral">"Couldn't open source file."</span>,
00743         <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00744         <span class="keywordflow">return</span>;
00745     }
00746 
00747     <span class="comment">/* open dest file */</span>
00748     amiFile = adfOpenFile(vol, fileName, <span class="stringliteral">"w"</span>);
00749 
00750     <span class="keywordflow">if</span> (! amiFile) {
00751         CloseHandle(winFile);
00752         MessageBox(ghwndFrame, <span class="stringliteral">"Error opening destination file (volume"</span>
00753             <span class="stringliteral">" full perhaps?)"</span>, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00754         <span class="keywordflow">return</span>;
00755     }
00756 
00757     <span class="comment">/* write the file */</span>
00758     act = 1;
00759     <span class="keywordflow">while</span> (act &gt; 0) {
00760         ReadFile(winFile, buf, <span class="keyword">sizeof</span>(buf), &amp;act, NULL);
00761         bread += <span class="keyword">sizeof</span>(buf);
00762         <span class="keywordflow">if</span> (adfWriteFile(amiFile, act, buf) != (long)act) {
00763             CloseHandle(winFile);
00764             adfCloseFile(amiFile);
00765             sprintf(errMess, <span class="stringliteral">"Could not write file '%s'.  Not enough free space on volume."</span>, fileName);
00766             MessageBox(ghwndFrame, errMess, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00767             <span class="keywordflow">return</span>;
00768         }
00769         Percent = (100 * bread) / fileSize;
00770     }
00771 
00772     adfCloseFile(amiFile);
00773     CloseHandle(winFile);
00774 }
00775 
00776 <span class="keywordtype">void</span> CopyWin2Win(<span class="keywordtype">char</span> *srcPath, <span class="keywordtype">char</span> *destPath)
00777 {
00778     HANDLE srcFile, destFile;
00779     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[600];
00780     DWORD read, written, crap;
00781     <span class="keywordtype">long</span> fileSize, bread = 0;
00782 
00783     <span class="comment">/* open source file */</span>
00784     srcFile = CreateFile(srcPath, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
00785     <span class="keywordflow">if</span> (srcFile == INVALID_HANDLE_VALUE) {
00786         MessageBox(ghwndFrame, <span class="stringliteral">"Couldn't open source file."</span>,
00787         <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00788         <span class="keywordflow">return</span>;
00789     }
00790 
00791     fileSize = GetFileSize(srcFile, &amp;crap);
00792 
00793     <span class="comment">/* open dest file */</span>
00794     destFile = CreateFile(destPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
00795         0, NULL);
00796     <span class="keywordflow">if</span> (destFile == INVALID_HANDLE_VALUE) {
00797         CloseHandle(srcFile);
00798         MessageBox(ghwndFrame, <span class="stringliteral">"Couldn't create destination file."</span>,
00799         <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00800         <span class="keywordflow">return</span>;
00801     }
00802 
00803     <span class="comment">/* copy data */</span>
00804     read = 1;
00805     <span class="keywordflow">while</span> (read) {
00806         ReadFile(srcFile, buf, <span class="keyword">sizeof</span>(buf), &amp;read, NULL);
00807         bread += <span class="keyword">sizeof</span>(buf);
00808         WriteFile(destFile, buf, read, &amp;written, NULL);
00809         <span class="keywordflow">if</span> (written != read) {
00810             MessageBox(ghwndFrame, <span class="stringliteral">"Error writing destination "</span>
00811                 <span class="stringliteral">"file.  Maybe disk full?"</span>, <span class="stringliteral">"Error"</span>, MB_OK |
00812                 MB_ICONERROR);
00813             CloseHandle(srcFile);
00814             CloseHandle(destFile);
00815             <span class="keywordflow">return</span>;
00816         }
00817         Percent = (100 * bread) / fileSize;
00818     }
00819 
00820     CloseHandle(srcFile);
00821     CloseHandle(destFile);
00822 }
00823 
00824 <span class="keywordtype">void</span> CopyAmi2Ami(<span class="keywordtype">char</span> *fileName, <span class="keyword">struct</span> Volume *srcVol, <span class="keyword">struct</span> Volume *destVol, <span class="keywordtype">long</span> fileSize)
00825 {
00826     <span class="keyword">struct </span>File *srcFile, *destFile;
00827     <span class="keywordtype">long</span> read, written;
00828     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[600];
00829     <span class="keywordtype">long</span> bread = 0;
00830     <span class="keywordtype">long</span> bn;
00831 
00832     bn = adfFileRealSize(fileSize, LOGICAL_BLOCK_SIZE, NULL, NULL);
00833     <span class="keywordflow">if</span> (adfCountFreeBlocks(destVol) &lt; bn) {
00834         MessageBox(ghwndFrame, <span class="stringliteral">"Could not copy file. There is insufficient "</span>
00835             <span class="stringliteral">"free space on the destination volume."</span>, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00836         <span class="keywordflow">return</span>;
00837     }
00838 
00839     <span class="comment">/* open source file */</span>
00840     srcFile = adfOpenFile(srcVol, fileName, <span class="stringliteral">"r"</span>);
00841 
00842     <span class="keywordflow">if</span> (! srcFile) {
00843         MessageBox(ghwndFrame, <span class="stringliteral">"Error opening source file (probably"</span>
00844             <span class="stringliteral">" a bug)."</span>, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00845         <span class="keywordflow">return</span>;
00846     }
00847 
00848     <span class="comment">/* open dest file */</span>
00849     destFile = adfOpenFile(destVol, fileName, <span class="stringliteral">"w"</span>);
00850 
00851     <span class="keywordflow">if</span> (! destFile) {
00852         adfCloseFile(srcFile);
00853         MessageBox(ghwndFrame, <span class="stringliteral">"Error opening destination file"</span>
00854             <span class="stringliteral">" (probably a bug)."</span>, <span class="stringliteral">"Error"</span>, MB_OK | MB_ICONERROR);
00855         <span class="keywordflow">return</span>;
00856     }
00857 
00858     <span class="comment">/* copy data */</span>
00859     <span class="keywordflow">while</span>(! adfEndOfFile(srcFile)) {
00860         read = adfReadFile(srcFile, <span class="keyword">sizeof</span>(buf), buf);
00861         bread += read;
00862         written = adfWriteFile(destFile, read, buf);
00863         <span class="keywordflow">if</span> (written != read) {
00864             adfCloseFile(srcFile);
00865             adfCloseFile(destFile);
00866             MessageBox(ghwndFrame, <span class="stringliteral">"Error writing destination "</span>
00867                 <span class="stringliteral">"file (maybe volume full?)."</span>, <span class="stringliteral">"Error"</span>,
00868                 MB_OK | MB_ICONERROR);
00869         }
00870         Percent = (100 * bread) / fileSize;
00871     }
00872 
00873     adfCloseFile(srcFile);
00874     adfCloseFile(destFile);
00875 }
00876 
00877 <span class="keywordtype">void</span> GetTooltipText(<span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> cmd)
00878 {
00879     <span class="keywordflow">switch</span>(cmd) {
00880     <span class="keywordflow">case</span> ID_FIL_NEW:
00881         strcpy(buf, <span class="stringliteral">"New"</span>);
00882         <span class="keywordflow">break</span>;
00883     <span class="keywordflow">case</span> ID_FIL_OPEN:
00884         strcpy(buf, <span class="stringliteral">"Open"</span>);
00885         <span class="keywordflow">break</span>;
00886     <span class="keywordflow">case</span> ID_FIL_CLOSE:
00887         strcpy(buf, <span class="stringliteral">"Close"</span>);
00888         <span class="keywordflow">break</span>;
00889     <span class="keywordflow">case</span> ID_FIL_INFORMATION:
00890         strcpy(buf, <span class="stringliteral">"Information"</span>);
00891         <span class="keywordflow">break</span>;
00892     <span class="keywordflow">case</span> ID_ACTION_RENAME:
00893         strcpy(buf, <span class="stringliteral">"Rename"</span>);
00894         <span class="keywordflow">break</span>;
00895     <span class="keywordflow">case</span> ID_ACTION_DELETE:
00896         strcpy(buf, <span class="stringliteral">"Delete"</span>);
00897         <span class="keywordflow">break</span>;
00898     <span class="keywordflow">case</span> ID_ACTION_NEWDIRECTORY:
00899         strcpy(buf, <span class="stringliteral">"New Directory"</span>);
00900         <span class="keywordflow">break</span>;
00901     <span class="keywordflow">case</span> ID_ACTION_PROPERTIES:
00902         strcpy(buf, <span class="stringliteral">"Properties"</span>);
00903         <span class="keywordflow">break</span>;
00904     <span class="keywordflow">case</span> ID_VIEW_NEWWINDOWSLISTER:
00905         strcpy(buf, <span class="stringliteral">"New Windows Lister"</span>);
00906         <span class="keywordflow">break</span>;
00907     <span class="keywordflow">case</span> ID_ACTION_UPONELEVEL:
00908         strcpy(buf, <span class="stringliteral">"Up One Level"</span>);
00909         <span class="keywordflow">break</span>;
00910     <span class="keywordflow">case</span> ID_VIEW_SHOWUNDELETABLEFILES:
00911         strcpy(buf, <span class="stringliteral">"Show Undeletable Files"</span>);
00912         <span class="keywordflow">break</span>;
00913     <span class="keywordflow">case</span> ID_ACTION_UNDELETE:
00914         strcpy(buf, <span class="stringliteral">"Undelete"</span>);
00915         <span class="keywordflow">break</span>;
00916     <span class="keywordflow">case</span> ID_TOOLS_OPTIONS:
00917         strcpy(buf, <span class="stringliteral">"Options"</span>);
00918         <span class="keywordflow">break</span>;
00919     <span class="keywordflow">case</span> ID_TOOLS_BATCHCONVERTER:
00920         strcpy(buf, <span class="stringliteral">"Batch Converter"</span>);
00921         <span class="keywordflow">break</span>;
00922     <span class="keywordflow">case</span> ID_TOOLS_DISK2FDI:
00923         strcpy(buf, <span class="stringliteral">"Disk2FDI"</span>);
00924         <span class="keywordflow">break</span>;
00925     <span class="keywordflow">case</span> ID_TOOLS_INSTALL:
00926         strcpy(buf, <span class="stringliteral">"Install Bootblock"</span>);
00927         <span class="keywordflow">break</span>;
00928     <span class="keywordflow">case</span> ID_TOOLS_DISPLAYBOOTBLOCK:
00929         strcpy(buf, <span class="stringliteral">"Display Bootblock"</span>);
00930         <span class="keywordflow">break</span>;
00931 
00932     }
00933 }
00934     
00935 
00936 LRESULT CALLBACK copyProgressProc(HWND dlg, UINT msg, WPARAM wp, LPARAM lp)
00937 {
00938     <span class="keyword">static</span> <span class="keywordtype">char</span> cs[20];
00939 
00940     <span class="keywordflow">switch</span> (msg) {
00941     <span class="keywordflow">case</span> WM_INITDIALOG:
00942         Timer = SetTimer(dlg, 1, 100, NULL);
00943         <span class="keywordflow">return</span> TRUE;
00944     <span class="keywordflow">case</span> WM_COMMAND:
00945         <span class="keywordflow">switch</span> (wp) {
00946         <span class="keywordflow">case</span> IDCANCEL:
00947             Done = TRUE;
00948             <span class="keywordflow">return</span> TRUE;
00949         }
00950     <span class="keywordflow">case</span> WM_TIMER:
00951         <span class="keywordflow">if</span> (Done) {
00952             KillTimer(dlg, Timer);
00953             EndDialog(dlg, TRUE);
00954         }
00955         SendMessage(GetDlgItem(dlg, IDC_CURFILEPROGRESS), PBM_SETPOS, Percent, 0l);
00956         itoa(CurrentSect, cs, 10);
00957         SetDlgItemText(dlg, IDC_CURRENTSECTOR, cs);
00958         <span class="keywordflow">return</span> TRUE;
00959     }
00960 
00961     <span class="keywordflow">return</span> FALSE;
00962 }
00963 
00964 <span class="keywordtype">long</span> AOGetFileSize(CHILDINFO *ci, <span class="keywordtype">char</span> *fn)
00965 {
00966     DIRENTRY *ce = ci-&gt;content;
00967 
00968     <span class="keywordflow">while</span> (strcmp(ce-&gt;name, fn) != 0)
00969         ce = ce-&gt;next;
00970 
00971     <span class="keywordflow">return</span> ce-&gt;size;
00972 }
00973 
00974 BOOL CopyAmiDir2Win(<span class="keywordtype">char</span> *srcDir, <span class="keywordtype">char</span> *destPath, <span class="keyword">struct</span> Volume *vol)
00975 {
00976     <span class="keywordtype">char</span> tp[4096];
00977     <span class="keyword">struct </span>List *list;
00978     <span class="keyword">struct </span>Entry *ent;
00979 
00980     CreateDirectory(destPath, NULL);
00981 
00982     adfChangeDir(vol, srcDir);
00983     list = adfGetDirEnt(vol, vol-&gt;curDirPtr);
00984 
00985     <span class="keywordflow">while</span> (list) {
00986         ent = (<span class="keyword">struct </span>Entry *)list-&gt;content;
00987         strcpy(tp, destPath);
00988         strcat(tp, <span class="stringliteral">"\\"</span>);
00989         strcat(tp, ent-&gt;name);
00990         <span class="keywordflow">if</span> (ent-&gt;type == ST_DIR) {
00991             <span class="comment">/* it's a dir - recurse into it */</span>
00992             CopyAmiDir2Win(ent-&gt;name, tp, vol);
00993         } <span class="keywordflow">else</span> {
00994             <span class="comment">/* it's a file or a link, just copy it */</span>
00995             CopyAmi2Win(ent-&gt;name, tp, vol, ent-&gt;size);
00996         }
00997         adfFreeEntry(list-&gt;content);
00998         list = list-&gt;next;
00999     }
01000     freeList(list);
01001 
01002     adfParentDir(vol);
01003 
01004     <span class="keywordflow">return</span> TRUE;
01005 }
01006 
01007 BOOL CopyWinDir2Ami(<span class="keywordtype">char</span> *srcDir, <span class="keywordtype">char</span> *srcPath, <span class="keyword">struct</span> Volume *vol)
01008 {
01009     WIN32_FIND_DATA wfd;
01010     HANDLE search;
01011     <span class="keywordtype">char</span> curPath[MAX_PATH * 2];
01012     <span class="keywordtype">char</span> searchPath[MAX_PATH * 2];
01013     <span class="keywordtype">char</span> subdir[MAX_PATH * 2];
01014 
01015     strcpy(curPath, srcPath);
01016     sprintf(searchPath, <span class="stringliteral">"%s\\*"</span>, curPath);
01017 
01018     adfCreateDir(vol, vol-&gt;curDirPtr, srcDir);
01019     adfChangeDir(vol, srcDir);
01020 
01021     search = FindFirstFile(searchPath, &amp;wfd);
01022     <span class="keywordflow">if</span> (search == INVALID_HANDLE_VALUE)
01023         <span class="keywordflow">return</span> FALSE;
01024 
01025     <span class="keywordflow">do</span> {
01026         <span class="comment">/* if current entry is a dir, and isn't the current or parent dir, then copy it */</span>
01027         <span class="keywordflow">if</span> (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
01028             <span class="keywordflow">if</span> ( !((wfd.cFileName[1] == 0) &amp;&amp; (wfd.cFileName[0] == <span class="charliteral">'.'</span>)) )
01029                 <span class="keywordflow">if</span> ( !((wfd.cFileName[2] == 0) &amp;&amp; (wfd.cFileName[1] == <span class="charliteral">'.'</span>) &amp;&amp; (wfd.cFileName[0] == <span class="charliteral">'.'</span>)) ) {
01030                     sprintf(subdir, <span class="stringliteral">"%s\\%s"</span>, curPath, wfd.cFileName);
01031                     CopyWinDir2Ami(wfd.cFileName, subdir, vol);
01032                     <span class="comment">//RemoveDirectoryRecursive(subdir);</span>
01033                 }
01034         } <span class="keywordflow">else</span> {
01035             <span class="comment">/* it's a file so just copy it */</span>
01036             sprintf(subdir, <span class="stringliteral">"%s\\%s"</span>, curPath, wfd.cFileName);
01037             CopyWin2Ami(wfd.cFileName, subdir, vol, wfd.nFileSizeLow);
01038         }
01039 
01040     } <span class="keywordflow">while</span> (FindNextFile(search, &amp;wfd));
01041 
01042     FindClose(search);
01043 
01044     adfParentDir(vol);
01045 
01046     <span class="keywordflow">return</span> TRUE;
01047 }
01048 
01049 BOOL CopyWinDir2Win(<span class="keywordtype">char</span> *srcPath, <span class="keywordtype">char</span> *destPath, <span class="keywordtype">char</span> *dirName)
01050 {
01051     WIN32_FIND_DATA wfd;
01052     HANDLE search;
01053     <span class="keywordtype">char</span> searchPath[MAX_PATH * 2];
01054     <span class="keywordtype">char</span> subdir[MAX_PATH * 2];
01055     <span class="keywordtype">char</span> subdir2[MAX_PATH * 2];
01056 
01057     sprintf(searchPath, <span class="stringliteral">"%s\\%s"</span>, destPath, dirName);
01058     CreateDirectory(searchPath, NULL);
01059 
01060     sprintf(searchPath, <span class="stringliteral">"%s\\%s\\*"</span>, srcPath, dirName);
01061 
01062     search = FindFirstFile(searchPath, &amp;wfd);
01063     <span class="keywordflow">if</span> (search == INVALID_HANDLE_VALUE)
01064         <span class="keywordflow">return</span> FALSE;
01065 
01066     <span class="keywordflow">do</span> {
01067         <span class="comment">/* if current entry is a dir, and isn't the current or parent dir, then copy it */</span>
01068         <span class="keywordflow">if</span> (wfd.dwFileAttributes &amp; FILE_ATTRIBUTE_DIRECTORY) {
01069             <span class="keywordflow">if</span> ( !((wfd.cFileName[1] == 0) &amp;&amp; (wfd.cFileName[0] == <span class="charliteral">'.'</span>)) )
01070                 <span class="keywordflow">if</span> ( !((wfd.cFileName[2] == 0) &amp;&amp; (wfd.cFileName[1] == <span class="charliteral">'.'</span>) &amp;&amp; (wfd.cFileName[0] == <span class="charliteral">'.'</span>)) ) {
01071                     sprintf(subdir, <span class="stringliteral">"%s\\%s"</span>, srcPath, dirName);
01072                     sprintf(subdir2, <span class="stringliteral">"%s\\%s"</span>, destPath, dirName);
01073                     CopyWinDir2Win(subdir, subdir2, wfd.cFileName);
01074                 }
01075         } <span class="keywordflow">else</span> {
01076             <span class="comment">/* it's a file so just copy it */</span>
01077             sprintf(subdir, <span class="stringliteral">"%s\\%s\\%s"</span>, srcPath, dirName, wfd.cFileName);
01078             sprintf(subdir2, <span class="stringliteral">"%s\\%s\\%s"</span>, destPath, dirName, wfd.cFileName);
01079             CopyWin2Win(subdir, subdir2);
01080         }
01081 
01082     } <span class="keywordflow">while</span> (FindNextFile(search, &amp;wfd));
01083 
01084     FindClose(search);
01085 
01086     <span class="keywordflow">return</span> TRUE;
01087 }
01088 
01089 BOOL CopyAmiDir2Ami(<span class="keywordtype">char</span> *dirName, <span class="keyword">struct</span> Volume *src, <span class="keyword">struct</span> Volume *dest)
01090 {
01091     <span class="keyword">struct </span>List *list;
01092     <span class="keyword">struct </span>Entry *ent;
01093 
01094     adfCreateDir(dest, dest-&gt;curDirPtr, dirName);
01095 
01096     adfChangeDir(src, dirName);
01097     adfChangeDir(dest, dirName);
01098 
01099     list = adfGetDirEnt(src, src-&gt;curDirPtr);
01100 
01101     <span class="keywordflow">while</span> (list) {
01102         ent = (<span class="keyword">struct </span>Entry *)list-&gt;content;
01103         <span class="keywordflow">if</span> (ent-&gt;type == ST_DIR) {
01104             <span class="comment">/* it's a dir - recurse into it */</span>
01105             CopyAmiDir2Ami(ent-&gt;name, src, dest);
01106         } <span class="keywordflow">else</span> {
01107             <span class="comment">/* it's a file or a link, just copy it */</span>
01108             CopyAmi2Ami(ent-&gt;name, src, dest, ent-&gt;size);
01109         }
01110         adfFreeEntry(list-&gt;content);
01111         list = list-&gt;next;
01112     }
01113     freeList(list);
01114 
01115     adfParentDir(dest);
01116     adfParentDir(src);
01117 
01118     <span class="keywordflow">return</span> TRUE;
01119 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:38 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

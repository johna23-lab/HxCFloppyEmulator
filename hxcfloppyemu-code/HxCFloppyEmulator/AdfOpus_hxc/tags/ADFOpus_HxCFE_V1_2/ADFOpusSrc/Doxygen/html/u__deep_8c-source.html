<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>u_deep.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>u_deep.c</h1><div class="fragment"><pre>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> *     xDMS  v1.3  -  Portable DMS archive unpacker  -  Public Domain</span>
00004 <span class="comment"> *     Written by     Andre Rodrigues de la Rocha  &lt;adlroc@usa.net&gt;</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *     Lempel-Ziv-DynamicHuffman decompression functions used in Deep</span>
00007 <span class="comment"> *     mode.</span>
00008 <span class="comment"> *     Most routines ripped from LZHUF written by  Haruyasu Yoshizaki</span>
00009 <span class="comment"> *</span>
00010 <span class="comment"> */</span>
00011 
00012 <span class="preprocessor">#include &lt;string.h&gt;</span>
00013 
00014 <span class="preprocessor">#include "cdata.h"</span>
00015 <span class="preprocessor">#include "tables.h"</span>
00016 <span class="preprocessor">#include "u_deep.h"</span>
00017 <span class="preprocessor">#include "getbits.h"</span>
00018 
00019 
00020 INLINE USHORT DecodeChar(<span class="keywordtype">void</span>);
00021 INLINE USHORT DecodePosition(<span class="keywordtype">void</span>);
00022 INLINE <span class="keywordtype">void</span> update(USHORT c);
00023 <span class="keyword">static</span> <span class="keywordtype">void</span> reconst(<span class="keywordtype">void</span>);
00024 
00025 
00026 USHORT deep_text_loc;
00027 <span class="keywordtype">int</span> init_deep_tabs=1;
00028 
00029 
00030 
00031 <span class="preprocessor">#define DBITMASK 0x3fff   </span><span class="comment">/*  uses 16Kb dictionary  */</span>
00032 
00033 <span class="preprocessor">#define F       60  </span><span class="comment">/* lookahead buffer size */</span>
00034 <span class="preprocessor">#define THRESHOLD   2</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#define N_CHAR      (256 - THRESHOLD + F)   </span><span class="comment">/* kinds of characters (character code = 0..N_CHAR-1) */</span>
00036 <span class="preprocessor">#define T       (N_CHAR * 2 - 1)    </span><span class="comment">/* size of table */</span>
00037 <span class="preprocessor">#define R       (T - 1)         </span><span class="comment">/* position of root */</span>
00038 <span class="preprocessor">#define MAX_FREQ    0x8000      </span><span class="comment">/* updates tree when the */</span>
00039 
00040 
00041 USHORT freq[T + 1]; <span class="comment">/* frequency table */</span>
00042 
00043 USHORT prnt[T + N_CHAR]; <span class="comment">/* pointers to parent nodes, except for the */</span>
00044                 <span class="comment">/* elements [T..T + N_CHAR - 1] which are used to get */</span>
00045                 <span class="comment">/* the positions of leaves corresponding to the codes. */</span>
00046 
00047 USHORT son[T];   <span class="comment">/* pointers to child nodes (son[], son[] + 1) */</span>
00048 
00049 
00050 
00051 <span class="keywordtype">void</span> Init_DEEP_Tabs(<span class="keywordtype">void</span>){
00052     USHORT i, j;
00053 
00054     <span class="keywordflow">for</span> (i = 0; i &lt; N_CHAR; i++) {
00055         freq[i] = 1;
00056         son[i] = (USHORT)(i + T);
00057         prnt[i + T] = i;
00058     }
00059     i = 0; j = N_CHAR;
00060     <span class="keywordflow">while</span> (j &lt;= R) {
00061         freq[j] = (USHORT) (freq[i] + freq[i + 1]);
00062         son[j] = i;
00063         prnt[i] = prnt[i + 1] = j;
00064         i += 2; j++;
00065     }
00066     freq[T] = 0xffff;
00067     prnt[R] = 0;
00068 
00069     init_deep_tabs = 0;
00070 }
00071 
00072 
00073 
00074 USHORT Unpack_DEEP(UCHAR *in, UCHAR *out, USHORT origsize){
00075     USHORT i, j, c;
00076     UCHAR *outend;
00077 
00078     initbitbuf(in);
00079 
00080     <span class="keywordflow">if</span> (init_deep_tabs) Init_DEEP_Tabs();
00081 
00082     outend = out+origsize;
00083     <span class="keywordflow">while</span> (out &lt; outend) {
00084         c = DecodeChar();
00085         <span class="keywordflow">if</span> (c &lt; 256) {
00086             *out++ = text[deep_text_loc++ &amp; DBITMASK] = (UCHAR)c;
00087         } <span class="keywordflow">else</span> {
00088             j = (USHORT) (c - 255 + THRESHOLD);
00089             i = (USHORT) (deep_text_loc - DecodePosition() - 1);
00090             <span class="keywordflow">while</span> (j--) *out++ = text[deep_text_loc++ &amp; DBITMASK] = text[i++ &amp; DBITMASK];
00091         }
00092     }
00093 
00094     deep_text_loc = (USHORT)((deep_text_loc+60) &amp; DBITMASK);
00095 
00096     <span class="keywordflow">return</span> 0;
00097 }
00098 
00099 
00100 
00101 INLINE USHORT DecodeChar(<span class="keywordtype">void</span>){
00102     USHORT c;
00103 
00104     c = son[R];
00105 
00106     <span class="comment">/* travel from root to leaf, */</span>
00107     <span class="comment">/* choosing the smaller child node (son[]) if the read bit is 0, */</span>
00108     <span class="comment">/* the bigger (son[]+1} if 1 */</span>
00109     <span class="keywordflow">while</span> (c &lt; T) {
00110         c = son[c + GETBITS(1)];
00111         DROPBITS(1);
00112     }
00113     c -= T;
00114     update(c);
00115     <span class="keywordflow">return</span> c;
00116 }
00117 
00118 
00119 
00120 INLINE USHORT DecodePosition(<span class="keywordtype">void</span>){
00121     USHORT i, j, c;
00122 
00123     i = GETBITS(8);  DROPBITS(8);
00124     c = (USHORT) (d_code[i] &lt;&lt; 8);
00125     j = d_len[i];
00126     i = (USHORT) (((i &lt;&lt; j) | GETBITS(j)) &amp; 0xff);  DROPBITS(j);
00127 
00128     <span class="keywordflow">return</span> (USHORT) (c | i) ;
00129 }
00130 
00131 
00132 
00133 <span class="comment">/* reconstruction of tree */</span>
00134 
00135 <span class="keyword">static</span> <span class="keywordtype">void</span> reconst(<span class="keywordtype">void</span>){
00136     USHORT i, j, k, f, l;
00137 
00138     <span class="comment">/* collect leaf nodes in the first half of the table */</span>
00139     <span class="comment">/* and replace the freq by (freq + 1) / 2. */</span>
00140     j = 0;
00141     <span class="keywordflow">for</span> (i = 0; i &lt; T; i++) {
00142         <span class="keywordflow">if</span> (son[i] &gt;= T) {
00143             freq[j] = (USHORT) ((freq[i] + 1) / 2);
00144             son[j] = son[i];
00145             j++;
00146         }
00147     }
00148     <span class="comment">/* begin constructing tree by connecting sons */</span>
00149     <span class="keywordflow">for</span> (i = 0, j = N_CHAR; j &lt; T; i += 2, j++) {
00150         k = (USHORT) (i + 1);
00151         f = freq[j] = (USHORT) (freq[i] + freq[k]);
00152         <span class="keywordflow">for</span> (k = (USHORT)(j - 1); f &lt; freq[k]; k--);
00153         k++;
00154         l = (USHORT)((j - k) * 2);
00155         memmove(&amp;freq[k + 1], &amp;freq[k], (size_t)l);
00156         freq[k] = f;
00157         memmove(&amp;son[k + 1], &amp;son[k], (size_t)l);
00158         son[k] = i;
00159     }
00160     <span class="comment">/* connect prnt */</span>
00161     <span class="keywordflow">for</span> (i = 0; i &lt; T; i++) {
00162         <span class="keywordflow">if</span> ((k = son[i]) &gt;= T) {
00163             prnt[k] = i;
00164         } <span class="keywordflow">else</span> {
00165             prnt[k] = prnt[k + 1] = i;
00166         }
00167     }
00168 }
00169 
00170 
00171 
00172 <span class="comment">/* increment frequency of given code by one, and update tree */</span>
00173 
00174 INLINE <span class="keywordtype">void</span> update(USHORT c){
00175     USHORT i, j, k, l;
00176 
00177     <span class="keywordflow">if</span> (freq[R] == MAX_FREQ) {
00178         reconst();
00179     }
00180     c = prnt[c + T];
00181     <span class="keywordflow">do</span> {
00182         k = ++freq[c];
00183 
00184         <span class="comment">/* if the order is disturbed, exchange nodes */</span>
00185         <span class="keywordflow">if</span> (k &gt; freq[l = (USHORT)(c + 1)]) {
00186             <span class="keywordflow">while</span> (k &gt; freq[++l]);
00187             l--;
00188             freq[c] = freq[l];
00189             freq[l] = k;
00190 
00191             i = son[c];
00192             prnt[i] = l;
00193             <span class="keywordflow">if</span> (i &lt; T) prnt[i + 1] = l;
00194 
00195             j = son[l];
00196             son[l] = i;
00197 
00198             prnt[j] = c;
00199             <span class="keywordflow">if</span> (j &lt; T) prnt[j + 1] = c;
00200             son[c] = j;
00201 
00202             c = l;
00203         }
00204     } <span class="keywordflow">while</span> ((c = prnt[c]) != 0); <span class="comment">/* repeat up to root */</span>
00205 }
00206 
00207 
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:42 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>adf_util.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>adf_util.c</h1><a href="adf__util_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  ADF Library. (C) 1997-2002 Laurent Clevy</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> */</span>
00011 <span class="preprocessor">#include&lt;stdlib.h&gt;</span>
00012 <span class="preprocessor">#include&lt;time.h&gt;</span>
00013 
00014 <span class="preprocessor">#include "adf_util.h"</span>
00015 <span class="preprocessor">#include "adf_err.h"</span>
00016 <span class="preprocessor">#include "adf_disk.h"</span>
00017 
00018 <span class="keyword">extern</span> <span class="keyword">struct </span>Env adfEnv;
00019 
00020 
00021 <span class="comment">/*</span>
00022 <span class="comment"> * swLong</span>
00023 <span class="comment"> *</span>
00024 <span class="comment"> * write an unsigned long value (val) (in) </span>
00025 <span class="comment"> * to an unsigned char* buffer (buf) (out)</span>
00026 <span class="comment"> * </span>
00027 <span class="comment"> * used in adfWrite----Block() functions</span>
00028 <span class="comment"> */</span>
00029 <span class="keywordtype">void</span> swLong(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> val)
00030 {
00031     buf[0]= (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)((val &amp; 0xff000000) &gt;&gt;24UL);
00032     buf[1]= (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)((val &amp; 0x00ff0000) &gt;&gt;16UL);
00033     buf[2]= (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)((val &amp; 0x0000ff00) &gt;&gt;8UL);
00034     buf[3]= (<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>)(val &amp; 0x000000ff);
00035 }
00036 
00037 <span class="keywordtype">void</span> swShort(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> val)
00038 {
00039     buf[0]= (val &amp; 0xff00) &gt;&gt;8UL;
00040     buf[1]= (val &amp; 0x00ff) ;
00041 }
00042 
00043 <span class="comment">/*</span>
00044 <span class="comment"> * newCell</span>
00045 <span class="comment"> *</span>
00046 <span class="comment"> * adds a cell at the end the list</span>
00047 <span class="comment"> */</span>
00048 <span class="keyword">struct </span>List* newCell(struct List* list, void* content)
00049 {
00050     <span class="keyword">struct </span>List* cell;
00051 
00052     cell=(<span class="keyword">struct </span>List*)malloc(sizeof(struct List));
00053     <span class="keywordflow">if</span> (!cell) {
00054         (*adfEnv.eFct)(<span class="stringliteral">"newCell : malloc"</span>);
00055         <span class="keywordflow">return</span> NULL;
00056     }
00057     cell-&gt;content = content;
00058     cell-&gt;next = cell-&gt;subdir = 0;
00059     <span class="keywordflow">if</span> (list!=NULL)
00060         list-&gt;next = cell;
00061 
00062     <span class="keywordflow">return</span> cell;
00063 }
00064 
00065 
00066 <span class="comment">/*</span>
00067 <span class="comment"> * freeList</span>
00068 <span class="comment"> *</span>
00069 <span class="comment"> */</span>
00070 <span class="keywordtype">void</span> freeList(<span class="keyword">struct</span> List* list)
00071 {
00072     <span class="keywordflow">if</span> (list==NULL) 
00073         <span class="keywordflow">return</span>;
00074     
00075     <span class="keywordflow">if</span> (list-&gt;next)
00076         freeList(list-&gt;next);
00077     free(list);
00078 }
00079 
00080 
00081 
00082 
00083 <span class="comment">/*</span>
00084 <span class="comment"> * Days2Date</span>
00085 <span class="comment"> *</span>
00086 <span class="comment"> * amiga disk date format (days) to normal dd/mm/yy format (out)</span>
00087 <span class="comment"> */</span>
00088 
00089 <span class="keywordtype">void</span> 
00090 adfDays2Date(<span class="keywordtype">long</span> days, <span class="keywordtype">int</span> *yy, <span class="keywordtype">int</span> *mm, <span class="keywordtype">int</span> *dd)
00091 {
00092     <span class="keywordtype">int</span> y,m;
00093     <span class="keywordtype">int</span> nd;
00094     <span class="keywordtype">int</span> jm[12]={ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
00095 
00096     <span class="comment">/* 0 = 1 Jan 1978,  6988 = 18 feb 1997 */</span>
00097 
00098     <span class="comment">/*--- year ---*/</span>
00099     y=1978;
00100     <span class="keywordflow">if</span> (adfIsLeap(y))
00101         nd=366;
00102     <span class="keywordflow">else</span>
00103         nd=365;
00104     <span class="keywordflow">while</span>( days &gt;= nd ) {
00105         days-=nd;
00106         y++;
00107         <span class="keywordflow">if</span> (adfIsLeap(y))
00108             nd=366;
00109         <span class="keywordflow">else</span>
00110             nd=365;
00111     }
00112 
00113 
00114     <span class="comment">/*--- month ---*/</span>
00115     m=1;
00116     <span class="keywordflow">if</span> (adfIsLeap(y))
00117         jm[2-1]=29;
00118     <span class="keywordflow">while</span>( days &gt;= jm[m-1] ) {
00119         days-=jm[m-1];
00120         m++;
00121     }
00122 
00123     *yy=y;
00124     *mm=m;
00125     *dd=days+1;
00126 }
00127 
00128 
00129 <span class="comment">/*</span>
00130 <span class="comment"> * IsLeap</span>
00131 <span class="comment"> *</span>
00132 <span class="comment"> * true if a year (y) is leap</span>
00133 <span class="comment"> */</span>
00134 
00135     BOOL 
00136 adfIsLeap(<span class="keywordtype">int</span> y)
00137 {
00138     <span class="keywordflow">return</span>( (BOOL) ( !(y%100) ? !(y%400) : !(y%4) ) );
00139 }
00140 
00141 
00142 <span class="comment">/*</span>
00143 <span class="comment"> * adfCurrentDateTime</span>
00144 <span class="comment"> *</span>
00145 <span class="comment"> * return the current system date and time</span>
00146 <span class="comment"> */</span>
00147     <span class="keyword">struct </span>DateTime
00148 adfGiveCurrentTime( void )
00149 {
00150     <span class="keyword">struct </span>tm *local;
00151     time_t cal;
00152     <span class="keyword">struct </span>DateTime r;
00153 
00154     time(&amp;cal);
00155     local=localtime(&amp;cal);
00156 
00157     r.year=local-&gt;tm_year;         <span class="comment">/* since 1900 */</span>
00158     r.mon=local-&gt;tm_mon+1;
00159     r.day=local-&gt;tm_mday;
00160     r.hour=local-&gt;tm_hour;
00161     r.min=local-&gt;tm_min;
00162     r.sec=local-&gt;tm_sec;
00163 
00164     <span class="keywordflow">return</span>(r);
00165 }
00166 
00167 
00168 <span class="comment">/*</span>
00169 <span class="comment"> * adfTime2AmigaTime</span>
00170 <span class="comment"> *</span>
00171 <span class="comment"> * converts date and time (dt) into Amiga format : day, min, ticks</span>
00172 <span class="comment"> */</span>
00173     <span class="keywordtype">void</span>
00174 adfTime2AmigaTime(<span class="keyword">struct</span> DateTime dt, <span class="keywordtype">long</span> *day, <span class="keywordtype">long</span> *min, <span class="keywordtype">long</span> *ticks )
00175 {
00176     <span class="keywordtype">int</span> jm[12]={ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
00177 
00178 
00179     *min= dt.hour*60 + dt.min;                <span class="comment">/* mins */</span>
00180     *ticks= dt.sec*50;                        <span class="comment">/* ticks */</span>
00181 
00182     <span class="comment">/*--- days ---*/</span>
00183 
00184     *day= dt.day-1;                         <span class="comment">/* current month days */</span>
00185 
00186     <span class="comment">/* previous months days downto january */</span>
00187     <span class="keywordflow">if</span> (dt.mon&gt;1) {                      <span class="comment">/* if previous month exists */</span>
00188         dt.mon--;
00189         <span class="keywordflow">if</span> (dt.mon&gt;2 &amp;&amp; adfIsLeap(dt.year))    <span class="comment">/* months after a leap february */</span>
00190             jm[2-1]=29;
00191         <span class="keywordflow">while</span>(dt.mon&gt;0) {
00192             *day=*day+jm[dt.mon-1];
00193             dt.mon--;
00194         }
00195     }
00196 
00197     <span class="comment">/* years days before current year downto 1978 */</span>
00198     <span class="keywordflow">if</span> (dt.year&gt;78) {
00199         dt.year--;
00200         <span class="keywordflow">while</span>(dt.year&gt;=78) {
00201             <span class="keywordflow">if</span> (adfIsLeap(dt.year))
00202                 *day=*day+366;
00203             <span class="keywordflow">else</span>
00204                 *day=*day+365;
00205             dt.year--;
00206         }
00207     }
00208 }
00209 
00210 
00211 
00212 <span class="comment">/*</span>
00213 <span class="comment"> * dumpBlock</span>
00214 <span class="comment"> *</span>
00215 <span class="comment"> * debug function : to dump a block before writing the check its contents</span>
00216 <span class="comment"> *</span>
00217 <span class="comment"> */</span>
00218 <span class="keywordtype">void</span> dumpBlock(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf)
00219 {
00220     <span class="keywordtype">int</span> i, j;
00221 
00222     <span class="keywordflow">for</span>(i=0; i&lt;32; i++) {
00223         printf(<span class="stringliteral">"%5x "</span>,i*16);
00224         <span class="keywordflow">for</span> (j=0; j&lt;4; j++) {
00225             printf(<span class="stringliteral">"%08x "</span>,Long(buf+j*4+i*16));
00226         }
00227         printf(<span class="stringliteral">"    "</span>);
00228         <span class="keywordflow">for</span> (j=0; j&lt;16; j++)
00229             <span class="keywordflow">if</span> (buf[i*16+j]&lt;32 || buf[i*16+j]&gt;127)
00230                 putchar(<span class="charliteral">'.'</span>);
00231             <span class="keywordflow">else</span>
00232                 putchar(buf[i*16+j]);
00233         putchar(<span class="charliteral">'\n'</span>);
00234     }
00235 }
00236 
00237 
00238 
00239 <span class="comment">/*################################################################################*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:38 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>adf_salv.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>adf_salv.c</h1><a href="adf__salv_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  ADF Library. (C) 1997-2002 Laurent Clevy</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> */</span>
00011 <span class="preprocessor">#include&lt;string.h&gt;</span>
00012 <span class="preprocessor">#include&lt;stdlib.h&gt;</span>
00013 
00014 <span class="preprocessor">#include "adf_salv.h"</span>
00015 <span class="preprocessor">#include "adf_bitm.h"</span>
00016 <span class="preprocessor">#include "adf_util.h"</span>
00017 <span class="preprocessor">#include "adf_disk.h"</span>
00018 <span class="preprocessor">#include "adf_dir.h"</span>
00019 <span class="preprocessor">#include "adf_file.h"</span>
00020 <span class="preprocessor">#include "adf_cache.h"</span>
00021 
00022 <span class="keyword">extern</span> <span class="keyword">struct </span>Env adfEnv;
00023 
00024 <span class="comment">/*</span>
00025 <span class="comment"> * adfFreeGenBlock</span>
00026 <span class="comment"> *</span>
00027 <span class="comment"> */</span>
00028 <span class="keywordtype">void</span> adfFreeGenBlock(<span class="keyword">struct</span> GenBlock* block)
00029 {
00030     <span class="keywordflow">if</span> (block-&gt;name!=NULL)
00031         free(block-&gt;name);
00032 }
00033 
00034 
00035 <span class="comment">/*</span>
00036 <span class="comment"> * adfFreeDelList</span>
00037 <span class="comment"> *</span>
00038 <span class="comment"> */</span>
00039 <span class="keywordtype">void</span> adfFreeDelList(<span class="keyword">struct</span> List* list)
00040 {
00041     <span class="keyword">struct </span>List *cell;
00042 
00043     cell = list;
00044     <span class="keywordflow">while</span>(cell!=NULL) {
00045         adfFreeGenBlock((<span class="keyword">struct</span> GenBlock*)cell-&gt;content);
00046         cell = cell-&gt;next;
00047     }
00048     freeList(list);
00049 }
00050 
00051 
00052 <span class="comment">/*</span>
00053 <span class="comment"> * adfGetDelEnt</span>
00054 <span class="comment"> *</span>
00055 <span class="comment"> */</span>
00056 <span class="keyword">struct </span>List* adfGetDelEnt(struct Volume *vol)
00057 {
00058     <span class="keyword">struct </span>GenBlock *block;
00059     <span class="keywordtype">long</span> i;
00060     <span class="keyword">struct </span>List *list, *head;
00061     BOOL delEnt;
00062 
00063     list = head = NULL;
00064     block = NULL;
00065     delEnt = TRUE;
00066     <span class="keywordflow">for</span>(i=vol-&gt;firstBlock; i&lt;=vol-&gt;lastBlock; i++) {
00067         <span class="keywordflow">if</span> (adfIsBlockFree(vol, i)) {
00068             <span class="keywordflow">if</span> (delEnt) {
00069                 block = (<span class="keyword">struct </span>GenBlock*)malloc(sizeof(struct GenBlock));
00070                 <span class="keywordflow">if</span> (!block) <span class="keywordflow">return</span> NULL;
00071 <span class="comment">/*printf("%p\n",block);*/</span>
00072             }
00073 
00074             adfReadGenBlock(vol, i, block);
00075 
00076             delEnt = (block-&gt;type==T_HEADER 
00077                 &amp;&amp; (block-&gt;secType==ST_DIR || block-&gt;secType==ST_FILE) );
00078 
00079             <span class="keywordflow">if</span> (delEnt) {
00080                 <span class="keywordflow">if</span> (head==NULL)
00081                     list = head = newCell(NULL, (<span class="keywordtype">void</span>*)block);
00082                 <span class="keywordflow">else</span>
00083                     list = newCell(list, (<span class="keywordtype">void</span>*)block);
00084             }
00085         }
00086     }
00087 
00088     <span class="keywordflow">if</span> (block!=NULL &amp;&amp; list!=NULL &amp;&amp; block!=list-&gt;content) {
00089         free(block);
00090 <span class="comment">/*        printf("%p\n",block);*/</span>
00091     }
00092     <span class="keywordflow">return</span> head;
00093 }
00094 
00095 
00096 <span class="comment">/*</span>
00097 <span class="comment"> * adfReadGenBlock</span>
00098 <span class="comment"> *</span>
00099 <span class="comment"> */</span>
00100 RETCODE adfReadGenBlock(<span class="keyword">struct</span> Volume *vol, SECTNUM nSect, <span class="keyword">struct</span> GenBlock *block)
00101 {
00102     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[LOGICAL_BLOCK_SIZE];
00103     <span class="keywordtype">int</span> len;
00104     <span class="keywordtype">char</span> name[MAXNAMELEN+1];
00105 
00106     <span class="keywordflow">if</span> (adfReadBlock(vol, nSect, buf)!=RC_OK)
00107         <span class="keywordflow">return</span> RC_ERROR;
00108 
00109     block-&gt;type =(int) swapLong(buf);
00110     block-&gt;secType =(int) swapLong(buf+vol-&gt;blockSize-4);
00111     block-&gt;sect = nSect;
00112     block-&gt;name = NULL;
00113 
00114     <span class="keywordflow">if</span> (block-&gt;type==T_HEADER) {
00115         <span class="keywordflow">switch</span>(block-&gt;secType) {
00116         <span class="keywordflow">case</span> ST_FILE:
00117         <span class="keywordflow">case</span> ST_DIR:
00118         <span class="keywordflow">case</span> ST_LFILE:
00119         <span class="keywordflow">case</span> ST_LDIR:
00120             len = min(MAXNAMELEN, buf[vol-&gt;blockSize-80]);
00121             strncpy(name, buf+vol-&gt;blockSize-79, len);
00122             name[len] = <span class="charliteral">'\0'</span>;
00123             block-&gt;name = strdup(name);
00124             block-&gt;parent = swapLong(buf+vol-&gt;blockSize-12);
00125             <span class="keywordflow">break</span>;
00126         <span class="keywordflow">case</span> ST_ROOT:
00127             <span class="keywordflow">break</span>;
00128         <span class="keywordflow">default</span>: 
00129             ;
00130         }
00131     }
00132     <span class="keywordflow">return</span> RC_OK;
00133 }
00134 
00135 
00136 <span class="comment">/*</span>
00137 <span class="comment"> * adfCheckParent</span>
00138 <span class="comment"> *</span>
00139 <span class="comment"> */</span>
00140 RETCODE adfCheckParent(<span class="keyword">struct</span> Volume* vol, SECTNUM pSect)
00141 {
00142     <span class="keyword">struct </span>GenBlock block;
00143 
00144     <span class="keywordflow">if</span> (adfIsBlockFree(vol, pSect)) {
00145         (*adfEnv.wFct)(<span class="stringliteral">"adfCheckParent : parent doesn't exists"</span>);
00146         <span class="keywordflow">return</span> RC_ERROR;
00147     }
00148 
00149     <span class="comment">/* verify if parent is a DIR or ROOT */</span>
00150     adfReadGenBlock(vol, pSect, &amp;block);
00151     <span class="keywordflow">if</span> ( block.type!=T_HEADER 
00152         || (block.secType!=ST_DIR &amp;&amp; block.secType!=ST_ROOT) ) {
00153         (*adfEnv.wFct)(<span class="stringliteral">"adfCheckParent : parent secType is incorrect"</span>);
00154         <span class="keywordflow">return</span> RC_ERROR;
00155     }
00156 
00157     <span class="keywordflow">return</span> RC_OK;
00158 }
00159 
00160 
00161 <span class="comment">/*</span>
00162 <span class="comment"> * adfUndelDir</span>
00163 <span class="comment"> *</span>
00164 <span class="comment"> */</span>
00165 RETCODE adfUndelDir(<span class="keyword">struct</span> Volume* vol, SECTNUM pSect, SECTNUM nSect, 
00166     <span class="keyword">struct</span> bDirBlock* entry)
00167 {
00168     RETCODE rc;
00169     <span class="keyword">struct </span>bEntryBlock parent;
00170     <span class="keywordtype">char</span> name[MAXNAMELEN+1];
00171 
00172     <span class="comment">/* check if the given parent sector pointer seems OK */</span>
00173     <span class="keywordflow">if</span> ( (rc=adfCheckParent(vol,pSect)) != RC_OK)
00174         <span class="keywordflow">return</span> rc;
00175 
00176     <span class="keywordflow">if</span> (pSect!=entry-&gt;parent) {
00177         (*adfEnv.wFct)(<span class="stringliteral">"adfUndelDir : the given parent sector isn't the entry parent"</span>);
00178         <span class="keywordflow">return</span> RC_ERROR;
00179     }
00180 
00181     <span class="keywordflow">if</span> (!adfIsBlockFree(vol, entry-&gt;headerKey))
00182         <span class="keywordflow">return</span> RC_ERROR;
00183     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType) &amp;&amp; !adfIsBlockFree(vol,entry-&gt;extension))
00184         <span class="keywordflow">return</span> RC_ERROR;
00185 
00186     <span class="keywordflow">if</span> (adfReadEntryBlock(vol, pSect, &amp;parent)!=RC_OK)
00187         <span class="keywordflow">return</span> RC_ERROR;
00188 
00189     strncpy(name, entry-&gt;dirName, entry-&gt;nameLen);
00190     name[(int)entry-&gt;nameLen] = <span class="charliteral">'\0'</span>;
00191     <span class="comment">/* insert the entry in the parent hashTable, with the headerKey sector pointer */</span>
00192     adfSetBlockUsed(vol,entry-&gt;headerKey);
00193     adfCreateEntry(vol, &amp;parent, name, entry-&gt;headerKey);
00194 
00195     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType)) {
00196         adfAddInCache(vol, &amp;parent, (<span class="keyword">struct</span> bEntryBlock *)entry);
00197         adfSetBlockUsed(vol,entry-&gt;extension);
00198     }
00199 
00200     adfUpdateBitmap(vol);
00201 
00202     <span class="keywordflow">return</span> RC_OK;
00203 }
00204 
00205 
00206 <span class="comment">/*</span>
00207 <span class="comment"> * adfUndelFile</span>
00208 <span class="comment"> *</span>
00209 <span class="comment"> */</span>
00210 RETCODE adfUndelFile(<span class="keyword">struct</span> Volume* vol, SECTNUM pSect, SECTNUM nSect, <span class="keyword">struct</span> bFileHeaderBlock* entry)
00211 {
00212     <span class="keywordtype">long</span> i;
00213     <span class="keywordtype">char</span> name[MAXNAMELEN+1];
00214     <span class="keyword">struct </span>bEntryBlock parent;
00215     RETCODE rc;
00216     <span class="keyword">struct </span>FileBlocks fileBlocks;
00217 
00218     <span class="comment">/* check if the given parent sector pointer seems OK */</span>
00219     <span class="keywordflow">if</span> ( (rc=adfCheckParent(vol,pSect)) != RC_OK)
00220         <span class="keywordflow">return</span> rc;
00221 
00222     <span class="keywordflow">if</span> (pSect!=entry-&gt;parent) {
00223         (*adfEnv.wFct)(<span class="stringliteral">"adfUndelFile : the given parent sector isn't the entry parent"</span>);
00224         <span class="keywordflow">return</span> RC_ERROR;
00225     }
00226 
00227     adfGetFileBlocks(vol, entry, &amp;fileBlocks);
00228 
00229     <span class="keywordflow">for</span>(i=0; i&lt;fileBlocks.nbData; i++)
00230         <span class="keywordflow">if</span> ( !adfIsBlockFree(vol,fileBlocks.data[i]) )
00231             <span class="keywordflow">return</span> RC_ERROR;
00232         <span class="keywordflow">else</span>
00233             adfSetBlockUsed(vol, fileBlocks.data[i]);
00234     <span class="keywordflow">for</span>(i=0; i&lt;fileBlocks.nbExtens; i++)
00235         <span class="keywordflow">if</span> ( !adfIsBlockFree(vol,fileBlocks.extens[i]) )
00236             <span class="keywordflow">return</span> RC_ERROR;
00237         <span class="keywordflow">else</span>
00238             adfSetBlockUsed(vol, fileBlocks.extens[i]);
00239 
00240     free(fileBlocks.data);
00241     free(fileBlocks.extens);
00242 
00243     <span class="keywordflow">if</span> (adfReadEntryBlock(vol, pSect, &amp;parent)!=RC_OK)
00244         <span class="keywordflow">return</span> RC_ERROR;
00245 
00246     strncpy(name, entry-&gt;fileName, entry-&gt;nameLen);
00247     name[(int)entry-&gt;nameLen] = <span class="charliteral">'\0'</span>;
00248     <span class="comment">/* insert the entry in the parent hashTable, with the headerKey sector pointer */</span>
00249     adfCreateEntry(vol, &amp;parent, name, entry-&gt;headerKey);
00250 
00251     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType))
00252         adfAddInCache(vol, &amp;parent, (<span class="keyword">struct</span> bEntryBlock *)entry);
00253 
00254     adfUpdateBitmap(vol);
00255 
00256     <span class="keywordflow">return</span> RC_OK;
00257 }
00258 
00259 
00260 <span class="comment">/*</span>
00261 <span class="comment"> * adfUndelEntry</span>
00262 <span class="comment"> *</span>
00263 <span class="comment"> */</span>
00264 RETCODE adfUndelEntry(<span class="keyword">struct</span> Volume* vol, SECTNUM parent, SECTNUM nSect)
00265 {
00266     <span class="keyword">struct </span>bEntryBlock entry;
00267 
00268     adfReadEntryBlock(vol,nSect,&amp;entry);
00269 
00270     <span class="keywordflow">switch</span>(entry.secType) {
00271     <span class="keywordflow">case</span> ST_FILE:
00272         <span class="comment">// Return error if unsuccessful - GJH 22/10/02.</span>
00273         <span class="keywordflow">if</span>(adfUndelFile(vol, parent, nSect, (<span class="keyword">struct</span> bFileHeaderBlock*)&amp;entry) == RC_ERROR)
00274             <span class="keywordflow">return</span> RC_ERROR;
00275         <span class="keywordflow">break</span>;
00276     <span class="keywordflow">case</span> ST_DIR:
00277         <span class="comment">// Return error if unsuccessful - GJH 22/10/02.</span>
00278         <span class="keywordflow">if</span>(adfUndelDir(vol, parent, nSect, (<span class="keyword">struct</span> bDirBlock*)&amp;entry) == RC_ERROR)
00279             <span class="keywordflow">return</span> RC_ERROR;
00280         <span class="keywordflow">break</span>;
00281     <span class="keywordflow">default</span>:
00282         ;
00283     }
00284 
00285     <span class="keywordflow">return</span> RC_OK;
00286 }
00287 
00288 
00289 <span class="comment">/*</span>
00290 <span class="comment"> * adfCheckFile</span>
00291 <span class="comment"> *</span>
00292 <span class="comment"> */</span>
00293 RETCODE adfCheckFile(<span class="keyword">struct</span> Volume* vol, SECTNUM nSect,
00294     <span class="keyword">struct</span> bFileHeaderBlock* file, <span class="keywordtype">int</span> level)
00295 {
00296     <span class="keyword">struct </span>bFileExtBlock extBlock;
00297     <span class="keyword">struct </span>bOFSDataBlock dataBlock;
00298     <span class="keyword">struct </span>FileBlocks fileBlocks;
00299     <span class="keywordtype">int</span> n;
00300  
00301     adfGetFileBlocks(vol,file,&amp;fileBlocks);
00302 <span class="comment">/*printf("data %ld ext %ld\n",fileBlocks.nbData,fileBlocks.nbExtens);*/</span>
00303     <span class="keywordflow">if</span> (isOFS(vol-&gt;dosType)) {
00304         <span class="comment">/* checks OFS datablocks */</span>
00305         <span class="keywordflow">for</span>(n=0; n&lt;fileBlocks.nbData; n++) {
00306 <span class="comment">/*printf("%ld\n",fileBlocks.data[n]);*/</span>
00307             adfReadDataBlock(vol,fileBlocks.data[n],&amp;dataBlock);
00308             <span class="keywordflow">if</span> (dataBlock.headerKey!=fileBlocks.header)
00309                 (*adfEnv.wFct)(<span class="stringliteral">"adfCheckFile : headerKey incorrect"</span>);
00310             <span class="keywordflow">if</span> (dataBlock.seqNum!=n+1)
00311                 (*adfEnv.wFct)(<span class="stringliteral">"adfCheckFile : seqNum incorrect"</span>);
00312             <span class="keywordflow">if</span> (n&lt;fileBlocks.nbData-1) {
00313                 <span class="keywordflow">if</span> (dataBlock.nextData!=fileBlocks.data[n+1])
00314                     (*adfEnv.wFct)(<span class="stringliteral">"adfCheckFile : nextData incorrect"</span>);
00315                 <span class="keywordflow">if</span> (dataBlock.dataSize!=vol-&gt;datablockSize)
00316                     (*adfEnv.wFct)(<span class="stringliteral">"adfCheckFile : dataSize incorrect"</span>);
00317             }
00318             <span class="keywordflow">else</span> { <span class="comment">/* last datablock */</span>
00319                 <span class="keywordflow">if</span> (dataBlock.nextData!=0)
00320                     (*adfEnv.wFct)(<span class="stringliteral">"adfCheckFile : nextData incorrect"</span>);
00321             }
00322         }
00323     }
00324     <span class="keywordflow">for</span>(n=0; n&lt;fileBlocks.nbExtens; n++) {
00325         adfReadFileExtBlock(vol,fileBlocks.extens[n],&amp;extBlock);
00326         <span class="keywordflow">if</span> (extBlock.parent!=file-&gt;headerKey)
00327             (*adfEnv.wFct)(<span class="stringliteral">"adfCheckFile : extBlock parent incorrect"</span>);
00328         <span class="keywordflow">if</span> (n&lt;fileBlocks.nbExtens-1) {
00329             <span class="keywordflow">if</span> (extBlock.extension!=fileBlocks.extens[n+1])
00330                 (*adfEnv.wFct)(<span class="stringliteral">"adfCheckFile : nextData incorrect"</span>);
00331         }
00332         <span class="keywordflow">else</span>
00333             <span class="keywordflow">if</span> (extBlock.extension!=0)
00334                 (*adfEnv.wFct)(<span class="stringliteral">"adfCheckFile : nextData incorrect"</span>);
00335     }
00336 
00337     free(fileBlocks.data);
00338     free(fileBlocks.extens);
00339 
00340     <span class="keywordflow">return</span> RC_OK;
00341 }
00342 
00343 
00344 <span class="comment">/*</span>
00345 <span class="comment"> * adfCheckDir</span>
00346 <span class="comment"> *</span>
00347 <span class="comment"> */</span>
00348 RETCODE adfCheckDir(<span class="keyword">struct</span> Volume* vol, SECTNUM nSect, <span class="keyword">struct</span> bDirBlock* dir, 
00349     <span class="keywordtype">int</span> level)
00350 {
00351 
00352 
00353 
00354 
00355     <span class="keywordflow">return</span> RC_OK;
00356 }
00357 
00358 
00359 <span class="comment">/*</span>
00360 <span class="comment"> * adfCheckEntry</span>
00361 <span class="comment"> *</span>
00362 <span class="comment"> */</span>
00363 RETCODE adfCheckEntry(<span class="keyword">struct</span> Volume* vol, SECTNUM nSect, <span class="keywordtype">int</span> level)
00364 {
00365     <span class="keyword">struct </span>bEntryBlock entry;
00366     RETCODE rc;
00367 
00368     adfReadEntryBlock(vol,nSect,&amp;entry);
00369 
00370     <span class="keywordflow">switch</span>(entry.secType) {
00371     <span class="keywordflow">case</span> ST_FILE:
00372         rc = adfCheckFile(vol, nSect, (<span class="keyword">struct</span> bFileHeaderBlock*)&amp;entry, level);
00373         <span class="keywordflow">break</span>;
00374     <span class="keywordflow">case</span> ST_DIR:
00375         rc = adfCheckDir(vol, nSect, (<span class="keyword">struct</span> bDirBlock*)&amp;entry, level);
00376         <span class="keywordflow">break</span>;
00377     <span class="keywordflow">default</span>:
00378 <span class="comment">/*        printf("adfCheckEntry : not supported\n");*/</span>                  <span class="comment">/* BV */</span>
00379         rc = RC_ERROR;
00380     }
00381 
00382     <span class="keywordflow">return</span> rc;
00383 }
00384 
00385 
00386 <span class="comment">/*#############################################################################*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:38 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>adf_raw.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>adf_raw.c</h1><a href="adf__raw_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  ADF Library. (C) 1997-2002 Laurent Clevy</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> */</span>
00010 <span class="preprocessor">#include &lt;limits.h&gt;</span>
00011 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00012 <span class="preprocessor">#include &lt;string.h&gt;</span>
00013 
00014 <span class="preprocessor">#include "adf_str.h"</span>
00015 <span class="preprocessor">#include "adf_raw.h"</span>
00016 <span class="preprocessor">#include "adf_blk.h"</span>
00017 <span class="preprocessor">#include "adf_disk.h"</span>
00018 <span class="preprocessor">#include "adf_util.h"</span>
00019 <span class="preprocessor">#include "adf_err.h"</span>
00020 <span class="preprocessor">#include "defendian.h"</span>
00021 
00022 <span class="keyword">extern</span> <span class="keyword">struct </span>Env adfEnv;
00023 
00024 <span class="keywordtype">int</span> swapTable[MAX_SWTYPE+1][15]={
00025     { 4, SW_CHAR, 2, SW_LONG, 1012, SW_CHAR, 0, 1024 },     <span class="comment">/* first bytes of boot */</span>
00026     { 108, SW_LONG, 40, SW_CHAR, 10, SW_LONG, 0, 512 },        <span class="comment">/* root */</span>
00027     { 6, SW_LONG, 488, SW_CHAR, 0, 512 },                      <span class="comment">/* data */</span>
00028                                                             <span class="comment">/* file, dir, entry */</span>
00029     { 82, SW_LONG, 92, SW_CHAR, 3, SW_LONG, 36, SW_CHAR, 11, SW_LONG, 0, 512 },
00030     { 6, SW_LONG, 0, 24 },                                       <span class="comment">/* cache */</span>
00031     { 128, SW_LONG, 0, 512 },                                <span class="comment">/* bitmap, fext */</span>
00032                                                             <span class="comment">/* link */</span>                                        
00033     { 6, SW_LONG, 64, SW_CHAR, 86, SW_LONG, 32, SW_CHAR, 12, SW_LONG, 0, 512 },
00034     { 4, SW_CHAR, 39, SW_LONG, 56, SW_CHAR, 10, SW_LONG, 0, 256 }, <span class="comment">/* RDSK */</span>
00035     { 4, SW_CHAR, 127, SW_LONG, 0, 512 },                          <span class="comment">/* BADB */</span>
00036     { 4, SW_CHAR, 8, SW_LONG, 32, SW_CHAR, 31, SW_LONG, 4, SW_CHAR, <span class="comment">/* PART */</span>
00037       15, SW_LONG, 0, 256 },
00038     { 4, SW_CHAR, 7, SW_LONG, 4, SW_CHAR, 55, SW_LONG, 0, 256 }, <span class="comment">/* FSHD */</span>
00039     { 4, SW_CHAR, 4, SW_LONG, 492, SW_CHAR, 0, 512 }             <span class="comment">/* LSEG */</span>
00040     };
00041 
00042 
00043 <span class="comment">/*</span>
00044 <span class="comment"> * swapEndian</span>
00045 <span class="comment"> *</span>
00046 <span class="comment"> * magic :-) endian swap function (big -&gt; little for read, little to big for write)</span>
00047 <span class="comment"> */</span>
00048 
00049     <span class="keywordtype">void</span>
00050 swapEndian( <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf, <span class="keywordtype">int</span> type )
00051 {
00052     <span class="keywordtype">int</span> i,j;
00053     <span class="keywordtype">int</span> p;
00054 
00055     i=0;
00056     p=0;
00057 
00058     <span class="keywordflow">if</span> (type&gt;MAX_SWTYPE || type&lt;0)
00059         adfEnv.eFct(<span class="stringliteral">"SwapEndian: type do not exist"</span>);
00060 
00061     <span class="keywordflow">while</span>( swapTable[type][i]!=0 ) {
00062         <span class="keywordflow">for</span>(j=0; j&lt;swapTable[type][i]; j++) {
00063             <span class="keywordflow">switch</span>( swapTable[type][i+1] ) {
00064             <span class="keywordflow">case</span> SW_LONG:
00065                 *(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>*)(buf+p)=Long(buf+p);
00066                 p+=4;
00067                 <span class="keywordflow">break</span>;
00068             <span class="keywordflow">case</span> SW_SHORT:
00069                 *(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*)(buf+p)=Short(buf+p);
00070                 p+=2;
00071                 <span class="keywordflow">break</span>;
00072             <span class="keywordflow">case</span> SW_CHAR:
00073                 p++;
00074                 <span class="keywordflow">break</span>;
00075             <span class="keywordflow">default</span>:
00076                 ;
00077             }
00078         }
00079     i+=2;
00080     }
00081     <span class="keywordflow">if</span> (p!=swapTable[type][i+1]) 
00082         (*adfEnv.wFct)(<span class="stringliteral">"Warning: Endian Swapping length"</span>);      <span class="comment">/* BV */</span>
00083     
00084 
00085 }
00086 
00087 
00088 
00089 
00090 
00091 <span class="comment">/*</span>
00092 <span class="comment"> * adfReadRootBlock</span>
00093 <span class="comment"> *</span>
00094 <span class="comment"> * ENDIAN DEPENDENT</span>
00095 <span class="comment"> */</span>
00096 RETCODE
00097 adfReadRootBlock(<span class="keyword">struct</span> Volume* vol, <span class="keywordtype">long</span> nSect, <span class="keyword">struct</span> bRootBlock* root)
00098 {
00099     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[LOGICAL_BLOCK_SIZE];
00100 
00101     <span class="keywordflow">if</span> (adfReadBlock(vol, nSect, buf)!=RC_OK)
00102         <span class="keywordflow">return</span> RC_ERROR;
00103 
00104     memcpy(root, buf, LOGICAL_BLOCK_SIZE);
00105 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00106 <span class="preprocessor"></span>    swapEndian((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)root, SWBL_ROOT);    
00107 <span class="preprocessor">#endif</span>
00108 <span class="preprocessor"></span>
00109     <span class="keywordflow">if</span> (root-&gt;type!=T_HEADER || root-&gt;secType!=ST_ROOT) {
00110         (*adfEnv.wFct)(<span class="stringliteral">"adfReadRootBlock : id not found"</span>);
00111         <span class="keywordflow">return</span> RC_ERROR;
00112     }
00113     <span class="keywordflow">if</span> (root-&gt;checkSum!=adfNormalSum(buf, 20, LOGICAL_BLOCK_SIZE)) {
00114         (*adfEnv.wFct)(<span class="stringliteral">"adfReadRootBlock : invalid checksum"</span>);
00115         <span class="keywordflow">return</span> RC_ERROR;
00116     }
00117         
00118     <span class="keywordflow">return</span> RC_OK;
00119 }
00120 
00121 
00122 <span class="comment">/*</span>
00123 <span class="comment"> * adfWriteRootBlock</span>
00124 <span class="comment"> *</span>
00125 <span class="comment"> * </span>
00126 <span class="comment"> */</span>
00127 RETCODE adfWriteRootBlock(<span class="keyword">struct</span> Volume* vol, <span class="keywordtype">long</span> nSect, <span class="keyword">struct</span> bRootBlock* root)
00128 {
00129     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[LOGICAL_BLOCK_SIZE];
00130     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00131 
00132 
00133     root-&gt;type = T_HEADER;
00134     root-&gt;headerKey = 0L;
00135     root-&gt;highSeq = 0L;
00136     root-&gt;hashTableSize = HT_SIZE;
00137     root-&gt;firstData = 0L;
00138     <span class="comment">/* checkSum, hashTable */</span>
00139     <span class="comment">/* bmflag */</span>
00140     <span class="comment">/* bmPages, bmExt */</span>
00141     root-&gt;nextSameHash = 0L;
00142     root-&gt;parent = 0L;
00143     root-&gt;secType = ST_ROOT;
00144 
00145     memcpy(buf, root, LOGICAL_BLOCK_SIZE);
00146 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00147 <span class="preprocessor"></span>    swapEndian(buf, SWBL_ROOT);
00148 <span class="preprocessor">#endif</span>
00149 <span class="preprocessor"></span>
00150     newSum = adfNormalSum(buf,20,LOGICAL_BLOCK_SIZE);
00151     swLong(buf+20, newSum);
00152 <span class="comment">/*  *(unsigned long*)(buf+20) = swapLong((unsigned char*)&amp;newSum);*/</span>
00153 
00154 <span class="comment">/*  dumpBlock(buf);*/</span>
00155     <span class="keywordflow">if</span> (adfWriteBlock(vol, nSect, buf)!=RC_OK)
00156         <span class="keywordflow">return</span> RC_ERROR;
00157 <span class="comment">/*printf("adfWriteRootBlock %ld\n",nSect);*/</span>
00158     <span class="keywordflow">return</span> RC_OK;
00159 }
00160 
00161 
00162 <span class="comment">/*</span>
00163 <span class="comment"> * adfReadBootBlock</span>
00164 <span class="comment"> *</span>
00165 <span class="comment"> * ENDIAN DEPENDENT</span>
00166 <span class="comment"> */</span>
00167 RETCODE
00168 adfReadBootBlock(<span class="keyword">struct</span> Volume* vol, <span class="keyword">struct</span> bBootBlock* boot)
00169 {
00170     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[1024];
00171     
00172 <span class="comment">/*puts("22");*/</span>
00173     <span class="keywordflow">if</span> (adfReadBlock(vol, 0, buf)!=RC_OK)
00174         <span class="keywordflow">return</span> RC_ERROR;
00175 <span class="comment">/*puts("11");*/</span>
00176     <span class="keywordflow">if</span> (adfReadBlock(vol, 1, buf+LOGICAL_BLOCK_SIZE)!=RC_OK)
00177         <span class="keywordflow">return</span> RC_ERROR;
00178 
00179     memcpy(boot, buf, LOGICAL_BLOCK_SIZE*2);
00180 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00181 <span class="preprocessor"></span>    swapEndian((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)boot,SWBL_BOOT);
00182 <span class="preprocessor">#endif</span>
00183 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( strncmp(<span class="stringliteral">"DOS"</span>,boot-&gt;dosType,3)!=0 ) {
00184         (*adfEnv.wFct)(<span class="stringliteral">"adfReadBootBlock : DOS id not found"</span>);
00185         <span class="keywordflow">return</span> RC_ERROR;
00186     }
00187 
00188     <span class="keywordflow">if</span> ( boot-&gt;data[0]!=0 &amp;&amp; adfBootSum(buf)!=boot-&gt;checkSum ) {
00189 <span class="comment">/*printf("compsum=%lx sum=%lx\n",   adfBootSum(buf),boot-&gt;checkSum );*/</span>     <span class="comment">/* BV */</span>
00190         (*adfEnv.wFct)(<span class="stringliteral">"adfReadBootBlock : incorrect checksum"</span>); 
00191     }
00192 
00193     <span class="keywordflow">return</span> RC_OK;
00194 }
00195 
00196 <span class="comment">/*</span>
00197 <span class="comment"> * adfWriteBootBlock</span>
00198 <span class="comment"> *</span>
00199 <span class="comment"> *</span>
00200 <span class="comment"> *     write bootcode ?</span>
00201 <span class="comment"> */</span>
00202 RETCODE
00203 adfWriteBootBlock(<span class="keyword">struct</span> Volume* vol, <span class="keyword">struct</span> bBootBlock* boot)
00204 {
00205     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[LOGICAL_BLOCK_SIZE*2];
00206     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00207 
00208     boot-&gt;dosType[0] = <span class="charliteral">'D'</span>;
00209     boot-&gt;dosType[1] = <span class="charliteral">'O'</span>;
00210     boot-&gt;dosType[2] = <span class="charliteral">'S'</span>;
00211     memcpy(buf, boot, LOGICAL_BLOCK_SIZE*2);
00212 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00213 <span class="preprocessor"></span>    swapEndian(buf, SWBL_BOOT);
00214 <span class="preprocessor">#endif</span>
00215 <span class="preprocessor"></span>
00216     <span class="keywordflow">if</span> (boot-&gt;rootBlock==880 || boot-&gt;data[0]!=0) {
00217         newSum = adfBootSum(buf);
00218 <span class="comment">/*fprintf(stderr,"sum %x %x\n",newSum,adfBootSum2(buf));*/</span>
00219         swLong(buf+4,newSum);
00220 <span class="comment">/*        *(unsigned long*)(buf+4) = swapLong((unsigned char*)&amp;newSum);*/</span>
00221     }
00222 
00223 <span class="comment">/*  dumpBlock(buf);</span>
00224 <span class="comment">    dumpBlock(buf+512);</span>
00225 <span class="comment">*/</span>  
00226     <span class="keywordflow">if</span> (adfWriteBlock(vol, 0, buf)!=RC_OK)
00227         <span class="keywordflow">return</span> RC_ERROR;
00228     <span class="keywordflow">if</span> (adfWriteBlock(vol, 1,  buf+512)!=RC_OK)
00229         <span class="keywordflow">return</span> RC_ERROR;
00230 <span class="comment">/*puts("adfWriteBootBlock");*/</span>
00231     <span class="keywordflow">return</span> RC_OK;
00232 }
00233 
00234 
00235 <span class="comment">/*</span>
00236 <span class="comment"> * NormalSum</span>
00237 <span class="comment"> *</span>
00238 <span class="comment"> * buf = where the block is stored</span>
00239 <span class="comment"> * offset = checksum place (in bytes)</span>
00240 <span class="comment"> * bufLen = buffer length (in bytes)</span>
00241 <span class="comment"> */</span>
00242     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>
00243 adfNormalSum( UCHAR* buf, <span class="keywordtype">int</span> offset, <span class="keywordtype">int</span> bufLen )
00244 {
00245     <span class="keywordtype">long</span> newsum;
00246     <span class="keywordtype">int</span> i;
00247 
00248     newsum=0L;
00249     <span class="keywordflow">for</span>(i=0; i &lt; (bufLen/4); i++)
00250         <span class="keywordflow">if</span> ( i != (offset/4) )       <span class="comment">/* old chksum */</span>
00251             newsum+=Long(buf+i*4);
00252     newsum=(-newsum);   <span class="comment">/* WARNING */</span>
00253 
00254     <span class="keywordflow">return</span>(newsum);
00255 }
00256 
00257 <span class="comment">/*</span>
00258 <span class="comment"> * adfBitmapSum</span>
00259 <span class="comment"> *</span>
00260 <span class="comment"> */</span>
00261     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> 
00262 adfBitmapSum(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf)
00263 {
00264     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00265     <span class="keywordtype">int</span> i;
00266     
00267     newSum = 0L;
00268     <span class="keywordflow">for</span>(i=1; i&lt;128; i++)
00269         newSum-=Long(buf+i*4);
00270     <span class="keywordflow">return</span>(newSum);
00271 }
00272 
00273 
00274 <span class="comment">/*</span>
00275 <span class="comment"> * adfBootSum</span>
00276 <span class="comment"> *</span>
00277 <span class="comment"> */</span>
00278     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> 
00279 adfBootSum(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf)
00280 {
00281     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> d, newSum;
00282     <span class="keywordtype">int</span> i;
00283     
00284     newSum=0L;
00285     <span class="keywordflow">for</span>(i=0; i&lt;256; i++) {
00286         <span class="keywordflow">if</span> (i!=1) {
00287             d = Long(buf+i*4);
00288             <span class="keywordflow">if</span> ( (ULONG_MAX-newSum)&lt;d )
00289                 newSum++;
00290             newSum+=d;
00291         }
00292     }
00293     newSum = ~newSum;   <span class="comment">/* not */</span>
00294 
00295     <span class="keywordflow">return</span>(newSum);
00296 }
00297 
00298     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> 
00299 adfBootSum2(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf)
00300 {
00301     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> prevsum, newSum;
00302     <span class="keywordtype">int</span> i;
00303 
00304     prevsum = newSum=0L;
00305     <span class="keywordflow">for</span>(i=0; i&lt;1024/<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>); i++) {
00306         <span class="keywordflow">if</span> (i!=1) {
00307             prevsum = newSum;
00308             newSum += Long(buf+i*4);
00309             <span class="keywordflow">if</span> (newSum &lt; prevsum)
00310                 newSum++;
00311         }
00312     }
00313     newSum = ~newSum;   <span class="comment">/* not */</span>
00314 
00315     <span class="keywordflow">return</span>(newSum);
00316 }
00317 
00318 
00319 <span class="comment">/*#######################################################################################*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:38 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

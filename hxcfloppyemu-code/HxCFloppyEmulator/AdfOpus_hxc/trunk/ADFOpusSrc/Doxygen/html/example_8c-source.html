<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>example.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>example.c</h1><div class="fragment"><pre>00001 <span class="comment">/* example.c -- usage example of the zlib compression library</span>
00002 <span class="comment"> * Copyright (C) 1995-2002 Jean-loup Gailly.</span>
00003 <span class="comment"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
00004 <span class="comment"> */</span>
00005 
00006 <span class="comment">/* @(#) $Id: example_8c-source.html,v 1.1 2002/11/14 01:50:01 garyjharris Exp $ */</span>
00007 
00008 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00009 <span class="preprocessor">#include "zlib.h"</span>
00010 
00011 <span class="preprocessor">#ifdef STDC</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#  include &lt;string.h&gt;</span>
00013 <span class="preprocessor">#  include &lt;stdlib.h&gt;</span>
00014 <span class="preprocessor">#else</span>
00015 <span class="preprocessor"></span>   <span class="keyword">extern</span> <span class="keywordtype">void</span> exit  OF((<span class="keywordtype">int</span>));
00016 <span class="preprocessor">#endif</span>
00017 <span class="preprocessor"></span>
00018 <span class="preprocessor">#if defined(VMS) || defined(RISCOS)</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#  define TESTFILE "foo-gz"</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#  define TESTFILE "foo.gz"</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00023 <span class="preprocessor"></span>
00024 <span class="preprocessor">#define CHECK_ERR(err, msg) { \</span>
00025 <span class="preprocessor">    if (err != Z_OK) { \</span>
00026 <span class="preprocessor">        fprintf(stderr, "%s error: %d\n", msg, err); \</span>
00027 <span class="preprocessor">        exit(1); \</span>
00028 <span class="preprocessor">    } \</span>
00029 <span class="preprocessor">}</span>
00030 <span class="preprocessor"></span>
00031 <span class="keyword">const</span> <span class="keywordtype">char</span> hello[] = <span class="stringliteral">"hello, hello!"</span>;
00032 <span class="comment">/* "hello world" would be more standard, but the repeated "hello"</span>
00033 <span class="comment"> * stresses the compression code better, sorry...</span>
00034 <span class="comment"> */</span>
00035 
00036 <span class="keyword">const</span> <span class="keywordtype">char</span> dictionary[] = <span class="stringliteral">"hello"</span>;
00037 uLong dictId; <span class="comment">/* Adler32 value of the dictionary */</span>
00038 
00039 <span class="keywordtype">void</span> test_compress      OF((Byte *compr, uLong comprLen,
00040                     Byte *uncompr, uLong uncomprLen));
00041 <span class="keywordtype">void</span> test_gzio          OF((<span class="keyword">const</span> <span class="keywordtype">char</span> *out, <span class="keyword">const</span> <span class="keywordtype">char</span> *in, 
00042                     Byte *uncompr, <span class="keywordtype">int</span> uncomprLen));
00043 <span class="keywordtype">void</span> test_deflate       OF((Byte *compr, uLong comprLen));
00044 <span class="keywordtype">void</span> test_inflate       OF((Byte *compr, uLong comprLen,
00045                     Byte *uncompr, uLong uncomprLen));
00046 <span class="keywordtype">void</span> test_large_deflate OF((Byte *compr, uLong comprLen,
00047                     Byte *uncompr, uLong uncomprLen));
00048 <span class="keywordtype">void</span> test_large_inflate OF((Byte *compr, uLong comprLen,
00049                     Byte *uncompr, uLong uncomprLen));
00050 <span class="keywordtype">void</span> test_flush         OF((Byte *compr, uLong *comprLen));
00051 <span class="keywordtype">void</span> test_sync          OF((Byte *compr, uLong comprLen,
00052                     Byte *uncompr, uLong uncomprLen));
00053 <span class="keywordtype">void</span> test_dict_deflate  OF((Byte *compr, uLong comprLen));
00054 <span class="keywordtype">void</span> test_dict_inflate  OF((Byte *compr, uLong comprLen,
00055                     Byte *uncompr, uLong uncomprLen));
00056 <span class="keywordtype">int</span>  main               OF((<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]));
00057 
00058 <span class="comment">/* ===========================================================================</span>
00059 <span class="comment"> * Test compress() and uncompress()</span>
00060 <span class="comment"> */</span>
00061 <span class="keywordtype">void</span> test_compress(compr, comprLen, uncompr, uncomprLen)
00062     Byte *compr, *uncompr;
00063     uLong comprLen, uncomprLen;
00064 {
00065     <span class="keywordtype">int</span> err;
00066     uLong len = strlen(hello)+1;
00067 
00068     err = compress(compr, &amp;comprLen, (<span class="keyword">const</span> Bytef*)hello, len);
00069     CHECK_ERR(err, <span class="stringliteral">"compress"</span>);
00070 
00071     strcpy((<span class="keywordtype">char</span>*)uncompr, <span class="stringliteral">"garbage"</span>);
00072 
00073     err = uncompress(uncompr, &amp;uncomprLen, compr, comprLen);
00074     CHECK_ERR(err, <span class="stringliteral">"uncompress"</span>);
00075 
00076     <span class="keywordflow">if</span> (strcmp((<span class="keywordtype">char</span>*)uncompr, hello)) {
00077         fprintf(stderr, <span class="stringliteral">"bad uncompress\n"</span>);
00078     exit(1);
00079     } <span class="keywordflow">else</span> {
00080         printf(<span class="stringliteral">"uncompress(): %s\n"</span>, (<span class="keywordtype">char</span> *)uncompr);
00081     }
00082 }
00083 
00084 <span class="comment">/* ===========================================================================</span>
00085 <span class="comment"> * Test read/write of .gz files</span>
00086 <span class="comment"> */</span>
00087 <span class="keywordtype">void</span> test_gzio(out, in, uncompr, uncomprLen)
00088     <span class="keyword">const</span> <span class="keywordtype">char</span> *out; <span class="comment">/* compressed output file */</span>
00089     <span class="keyword">const</span> <span class="keywordtype">char</span> *in;  <span class="comment">/* compressed input file */</span>
00090     Byte *uncompr;
00091     <span class="keywordtype">int</span>  uncomprLen;
00092 {
00093     <span class="keywordtype">int</span> err;
00094     <span class="keywordtype">int</span> len = strlen(hello)+1;
00095     gzFile file;
00096     z_off_t pos;
00097 
00098     file = gzopen(out, <span class="stringliteral">"wb"</span>);
00099     <span class="keywordflow">if</span> (file == NULL) {
00100         fprintf(stderr, <span class="stringliteral">"gzopen error\n"</span>);
00101         exit(1);
00102     }
00103     gzputc(file, <span class="charliteral">'h'</span>);
00104     <span class="keywordflow">if</span> (gzputs(file, <span class="stringliteral">"ello"</span>) != 4) {
00105         fprintf(stderr, <span class="stringliteral">"gzputs err: %s\n"</span>, gzerror(file, &amp;err));
00106     exit(1);
00107     }
00108     <span class="keywordflow">if</span> (gzprintf(file, <span class="stringliteral">", %s!"</span>, <span class="stringliteral">"hello"</span>) != 8) {
00109         fprintf(stderr, <span class="stringliteral">"gzprintf err: %s\n"</span>, gzerror(file, &amp;err));
00110     exit(1);
00111     }
00112     gzseek(file, 1L, SEEK_CUR); <span class="comment">/* add one zero byte */</span>
00113     gzclose(file);
00114 
00115     file = gzopen(in, <span class="stringliteral">"rb"</span>);
00116     <span class="keywordflow">if</span> (file == NULL) {
00117         fprintf(stderr, <span class="stringliteral">"gzopen error\n"</span>);
00118     }
00119     strcpy((<span class="keywordtype">char</span>*)uncompr, <span class="stringliteral">"garbage"</span>);
00120 
00121     uncomprLen = gzread(file, uncompr, (<span class="keywordtype">unsigned</span>)uncomprLen);
00122     <span class="keywordflow">if</span> (uncomprLen != len) {
00123         fprintf(stderr, <span class="stringliteral">"gzread err: %s\n"</span>, gzerror(file, &amp;err));
00124     exit(1);
00125     }
00126     <span class="keywordflow">if</span> (strcmp((<span class="keywordtype">char</span>*)uncompr, hello)) {
00127         fprintf(stderr, <span class="stringliteral">"bad gzread: %s\n"</span>, (<span class="keywordtype">char</span>*)uncompr);
00128     exit(1);
00129     } <span class="keywordflow">else</span> {
00130         printf(<span class="stringliteral">"gzread(): %s\n"</span>, (<span class="keywordtype">char</span> *)uncompr);
00131     }
00132 
00133     pos = gzseek(file, -8L, SEEK_CUR);
00134     <span class="keywordflow">if</span> (pos != 6 || gztell(file) != pos) {
00135     fprintf(stderr, <span class="stringliteral">"gzseek error, pos=%ld, gztell=%ld\n"</span>,
00136         (<span class="keywordtype">long</span>)pos, (<span class="keywordtype">long</span>)gztell(file));
00137     exit(1);
00138     }
00139 
00140     <span class="keywordflow">if</span> (gzgetc(file) != <span class="charliteral">' '</span>) {
00141     fprintf(stderr, <span class="stringliteral">"gzgetc error\n"</span>);
00142     exit(1);
00143     }
00144 
00145     gzgets(file, (<span class="keywordtype">char</span>*)uncompr, uncomprLen);
00146     uncomprLen = strlen((<span class="keywordtype">char</span>*)uncompr);
00147     <span class="keywordflow">if</span> (uncomprLen != 6) { <span class="comment">/* "hello!" */</span>
00148         fprintf(stderr, <span class="stringliteral">"gzgets err after gzseek: %s\n"</span>, gzerror(file, &amp;err));
00149     exit(1);
00150     }
00151     <span class="keywordflow">if</span> (strcmp((<span class="keywordtype">char</span>*)uncompr, hello+7)) {
00152         fprintf(stderr, <span class="stringliteral">"bad gzgets after gzseek\n"</span>);
00153     exit(1);
00154     } <span class="keywordflow">else</span> {
00155         printf(<span class="stringliteral">"gzgets() after gzseek: %s\n"</span>, (<span class="keywordtype">char</span> *)uncompr);
00156     }
00157 
00158     gzclose(file);
00159 }
00160 
00161 <span class="comment">/* ===========================================================================</span>
00162 <span class="comment"> * Test deflate() with small buffers</span>
00163 <span class="comment"> */</span>
00164 <span class="keywordtype">void</span> test_deflate(compr, comprLen)
00165     Byte *compr;
00166     uLong comprLen;
00167 {
00168     z_stream c_stream; <span class="comment">/* compression stream */</span>
00169     <span class="keywordtype">int</span> err;
00170     <span class="keywordtype">int</span> len = strlen(hello)+1;
00171 
00172     c_stream.zalloc = (alloc_func)0;
00173     c_stream.zfree = (free_func)0;
00174     c_stream.opaque = (voidpf)0;
00175 
00176     err = deflateInit(&amp;c_stream, Z_DEFAULT_COMPRESSION);
00177     CHECK_ERR(err, <span class="stringliteral">"deflateInit"</span>);
00178 
00179     c_stream.next_in  = (Bytef*)hello;
00180     c_stream.next_out = compr;
00181 
00182     <span class="keywordflow">while</span> (c_stream.total_in != (uLong)len &amp;&amp; c_stream.total_out &lt; comprLen) {
00183         c_stream.avail_in = c_stream.avail_out = 1; <span class="comment">/* force small buffers */</span>
00184         err = deflate(&amp;c_stream, Z_NO_FLUSH);
00185         CHECK_ERR(err, <span class="stringliteral">"deflate"</span>);
00186     }
00187     <span class="comment">/* Finish the stream, still forcing small buffers: */</span>
00188     <span class="keywordflow">for</span> (;;) {
00189         c_stream.avail_out = 1;
00190         err = deflate(&amp;c_stream, Z_FINISH);
00191         <span class="keywordflow">if</span> (err == Z_STREAM_END) <span class="keywordflow">break</span>;
00192         CHECK_ERR(err, <span class="stringliteral">"deflate"</span>);
00193     }
00194 
00195     err = deflateEnd(&amp;c_stream);
00196     CHECK_ERR(err, <span class="stringliteral">"deflateEnd"</span>);
00197 }
00198 
00199 <span class="comment">/* ===========================================================================</span>
00200 <span class="comment"> * Test inflate() with small buffers</span>
00201 <span class="comment"> */</span>
00202 <span class="keywordtype">void</span> test_inflate(compr, comprLen, uncompr, uncomprLen)
00203     Byte *compr, *uncompr;
00204     uLong comprLen, uncomprLen;
00205 {
00206     <span class="keywordtype">int</span> err;
00207     z_stream d_stream; <span class="comment">/* decompression stream */</span>
00208 
00209     strcpy((<span class="keywordtype">char</span>*)uncompr, <span class="stringliteral">"garbage"</span>);
00210 
00211     d_stream.zalloc = (alloc_func)0;
00212     d_stream.zfree = (free_func)0;
00213     d_stream.opaque = (voidpf)0;
00214 
00215     d_stream.next_in  = compr;
00216     d_stream.avail_in = 0;
00217     d_stream.next_out = uncompr;
00218 
00219     err = inflateInit(&amp;d_stream);
00220     CHECK_ERR(err, <span class="stringliteral">"inflateInit"</span>);
00221 
00222     <span class="keywordflow">while</span> (d_stream.total_out &lt; uncomprLen &amp;&amp; d_stream.total_in &lt; comprLen) {
00223         d_stream.avail_in = d_stream.avail_out = 1; <span class="comment">/* force small buffers */</span>
00224         err = inflate(&amp;d_stream, Z_NO_FLUSH);
00225         <span class="keywordflow">if</span> (err == Z_STREAM_END) <span class="keywordflow">break</span>;
00226         CHECK_ERR(err, <span class="stringliteral">"inflate"</span>);
00227     }
00228 
00229     err = inflateEnd(&amp;d_stream);
00230     CHECK_ERR(err, <span class="stringliteral">"inflateEnd"</span>);
00231 
00232     <span class="keywordflow">if</span> (strcmp((<span class="keywordtype">char</span>*)uncompr, hello)) {
00233         fprintf(stderr, <span class="stringliteral">"bad inflate\n"</span>);
00234     exit(1);
00235     } <span class="keywordflow">else</span> {
00236         printf(<span class="stringliteral">"inflate(): %s\n"</span>, (<span class="keywordtype">char</span> *)uncompr);
00237     }
00238 }
00239 
00240 <span class="comment">/* ===========================================================================</span>
00241 <span class="comment"> * Test deflate() with large buffers and dynamic change of compression level</span>
00242 <span class="comment"> */</span>
00243 <span class="keywordtype">void</span> test_large_deflate(compr, comprLen, uncompr, uncomprLen)
00244     Byte *compr, *uncompr;
00245     uLong comprLen, uncomprLen;
00246 {
00247     z_stream c_stream; <span class="comment">/* compression stream */</span>
00248     <span class="keywordtype">int</span> err;
00249 
00250     c_stream.zalloc = (alloc_func)0;
00251     c_stream.zfree = (free_func)0;
00252     c_stream.opaque = (voidpf)0;
00253 
00254     err = deflateInit(&amp;c_stream, Z_BEST_SPEED);
00255     CHECK_ERR(err, <span class="stringliteral">"deflateInit"</span>);
00256 
00257     c_stream.next_out = compr;
00258     c_stream.avail_out = (uInt)comprLen;
00259 
00260     <span class="comment">/* At this point, uncompr is still mostly zeroes, so it should compress</span>
00261 <span class="comment">     * very well:</span>
00262 <span class="comment">     */</span>
00263     c_stream.next_in = uncompr;
00264     c_stream.avail_in = (uInt)uncomprLen;
00265     err = deflate(&amp;c_stream, Z_NO_FLUSH);
00266     CHECK_ERR(err, <span class="stringliteral">"deflate"</span>);
00267     <span class="keywordflow">if</span> (c_stream.avail_in != 0) {
00268         fprintf(stderr, <span class="stringliteral">"deflate not greedy\n"</span>);
00269     exit(1);
00270     }
00271 
00272     <span class="comment">/* Feed in already compressed data and switch to no compression: */</span>
00273     deflateParams(&amp;c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
00274     c_stream.next_in = compr;
00275     c_stream.avail_in = (uInt)comprLen/2;
00276     err = deflate(&amp;c_stream, Z_NO_FLUSH);
00277     CHECK_ERR(err, <span class="stringliteral">"deflate"</span>);
00278 
00279     <span class="comment">/* Switch back to compressing mode: */</span>
00280     deflateParams(&amp;c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
00281     c_stream.next_in = uncompr;
00282     c_stream.avail_in = (uInt)uncomprLen;
00283     err = deflate(&amp;c_stream, Z_NO_FLUSH);
00284     CHECK_ERR(err, <span class="stringliteral">"deflate"</span>);
00285 
00286     err = deflate(&amp;c_stream, Z_FINISH);
00287     <span class="keywordflow">if</span> (err != Z_STREAM_END) {
00288         fprintf(stderr, <span class="stringliteral">"deflate should report Z_STREAM_END\n"</span>);
00289     exit(1);
00290     }
00291     err = deflateEnd(&amp;c_stream);
00292     CHECK_ERR(err, <span class="stringliteral">"deflateEnd"</span>);
00293 }
00294 
00295 <span class="comment">/* ===========================================================================</span>
00296 <span class="comment"> * Test inflate() with large buffers</span>
00297 <span class="comment"> */</span>
00298 <span class="keywordtype">void</span> test_large_inflate(compr, comprLen, uncompr, uncomprLen)
00299     Byte *compr, *uncompr;
00300     uLong comprLen, uncomprLen;
00301 {
00302     <span class="keywordtype">int</span> err;
00303     z_stream d_stream; <span class="comment">/* decompression stream */</span>
00304 
00305     strcpy((<span class="keywordtype">char</span>*)uncompr, <span class="stringliteral">"garbage"</span>);
00306 
00307     d_stream.zalloc = (alloc_func)0;
00308     d_stream.zfree = (free_func)0;
00309     d_stream.opaque = (voidpf)0;
00310 
00311     d_stream.next_in  = compr;
00312     d_stream.avail_in = (uInt)comprLen;
00313 
00314     err = inflateInit(&amp;d_stream);
00315     CHECK_ERR(err, <span class="stringliteral">"inflateInit"</span>);
00316 
00317     <span class="keywordflow">for</span> (;;) {
00318         d_stream.next_out = uncompr;            <span class="comment">/* discard the output */</span>
00319     d_stream.avail_out = (uInt)uncomprLen;
00320         err = inflate(&amp;d_stream, Z_NO_FLUSH);
00321         <span class="keywordflow">if</span> (err == Z_STREAM_END) <span class="keywordflow">break</span>;
00322         CHECK_ERR(err, <span class="stringliteral">"large inflate"</span>);
00323     }
00324 
00325     err = inflateEnd(&amp;d_stream);
00326     CHECK_ERR(err, <span class="stringliteral">"inflateEnd"</span>);
00327 
00328     <span class="keywordflow">if</span> (d_stream.total_out != 2*uncomprLen + comprLen/2) {
00329         fprintf(stderr, <span class="stringliteral">"bad large inflate: %ld\n"</span>, d_stream.total_out);
00330     exit(1);
00331     } <span class="keywordflow">else</span> {
00332         printf(<span class="stringliteral">"large_inflate(): OK\n"</span>);
00333     }
00334 }
00335 
00336 <span class="comment">/* ===========================================================================</span>
00337 <span class="comment"> * Test deflate() with full flush</span>
00338 <span class="comment"> */</span>
00339 <span class="keywordtype">void</span> test_flush(compr, comprLen)
00340     Byte *compr;
00341     uLong *comprLen;
00342 {
00343     z_stream c_stream; <span class="comment">/* compression stream */</span>
00344     <span class="keywordtype">int</span> err;
00345     <span class="keywordtype">int</span> len = strlen(hello)+1;
00346 
00347     c_stream.zalloc = (alloc_func)0;
00348     c_stream.zfree = (free_func)0;
00349     c_stream.opaque = (voidpf)0;
00350 
00351     err = deflateInit(&amp;c_stream, Z_DEFAULT_COMPRESSION);
00352     CHECK_ERR(err, <span class="stringliteral">"deflateInit"</span>);
00353 
00354     c_stream.next_in  = (Bytef*)hello;
00355     c_stream.next_out = compr;
00356     c_stream.avail_in = 3;
00357     c_stream.avail_out = (uInt)*comprLen;
00358     err = deflate(&amp;c_stream, Z_FULL_FLUSH);
00359     CHECK_ERR(err, <span class="stringliteral">"deflate"</span>);
00360 
00361     compr[3]++; <span class="comment">/* force an error in first compressed block */</span>
00362     c_stream.avail_in = len - 3;
00363 
00364     err = deflate(&amp;c_stream, Z_FINISH);
00365     <span class="keywordflow">if</span> (err != Z_STREAM_END) {
00366         CHECK_ERR(err, <span class="stringliteral">"deflate"</span>);
00367     }
00368     err = deflateEnd(&amp;c_stream);
00369     CHECK_ERR(err, <span class="stringliteral">"deflateEnd"</span>);
00370 
00371     *comprLen = c_stream.total_out;
00372 }
00373 
00374 <span class="comment">/* ===========================================================================</span>
00375 <span class="comment"> * Test inflateSync()</span>
00376 <span class="comment"> */</span>
00377 <span class="keywordtype">void</span> test_sync(compr, comprLen, uncompr, uncomprLen)
00378     Byte *compr, *uncompr;
00379     uLong comprLen, uncomprLen;
00380 {
00381     <span class="keywordtype">int</span> err;
00382     z_stream d_stream; <span class="comment">/* decompression stream */</span>
00383 
00384     strcpy((<span class="keywordtype">char</span>*)uncompr, <span class="stringliteral">"garbage"</span>);
00385 
00386     d_stream.zalloc = (alloc_func)0;
00387     d_stream.zfree = (free_func)0;
00388     d_stream.opaque = (voidpf)0;
00389 
00390     d_stream.next_in  = compr;
00391     d_stream.avail_in = 2; <span class="comment">/* just read the zlib header */</span>
00392 
00393     err = inflateInit(&amp;d_stream);
00394     CHECK_ERR(err, <span class="stringliteral">"inflateInit"</span>);
00395 
00396     d_stream.next_out = uncompr;
00397     d_stream.avail_out = (uInt)uncomprLen;
00398 
00399     inflate(&amp;d_stream, Z_NO_FLUSH);
00400     CHECK_ERR(err, <span class="stringliteral">"inflate"</span>);
00401 
00402     d_stream.avail_in = (uInt)comprLen-2;   <span class="comment">/* read all compressed data */</span>
00403     err = inflateSync(&amp;d_stream);           <span class="comment">/* but skip the damaged part */</span>
00404     CHECK_ERR(err, <span class="stringliteral">"inflateSync"</span>);
00405 
00406     err = inflate(&amp;d_stream, Z_FINISH);
00407     <span class="keywordflow">if</span> (err != Z_DATA_ERROR) {
00408         fprintf(stderr, <span class="stringliteral">"inflate should report DATA_ERROR\n"</span>);
00409         <span class="comment">/* Because of incorrect adler32 */</span>
00410     exit(1);
00411     }
00412     err = inflateEnd(&amp;d_stream);
00413     CHECK_ERR(err, <span class="stringliteral">"inflateEnd"</span>);
00414 
00415     printf(<span class="stringliteral">"after inflateSync(): hel%s\n"</span>, (<span class="keywordtype">char</span> *)uncompr);
00416 }
00417 
00418 <span class="comment">/* ===========================================================================</span>
00419 <span class="comment"> * Test deflate() with preset dictionary</span>
00420 <span class="comment"> */</span>
00421 <span class="keywordtype">void</span> test_dict_deflate(compr, comprLen)
00422     Byte *compr;
00423     uLong comprLen;
00424 {
00425     z_stream c_stream; <span class="comment">/* compression stream */</span>
00426     <span class="keywordtype">int</span> err;
00427 
00428     c_stream.zalloc = (alloc_func)0;
00429     c_stream.zfree = (free_func)0;
00430     c_stream.opaque = (voidpf)0;
00431 
00432     err = deflateInit(&amp;c_stream, Z_BEST_COMPRESSION);
00433     CHECK_ERR(err, <span class="stringliteral">"deflateInit"</span>);
00434 
00435     err = deflateSetDictionary(&amp;c_stream,
00436                    (<span class="keyword">const</span> Bytef*)dictionary, <span class="keyword">sizeof</span>(dictionary));
00437     CHECK_ERR(err, <span class="stringliteral">"deflateSetDictionary"</span>);
00438 
00439     dictId = c_stream.adler;
00440     c_stream.next_out = compr;
00441     c_stream.avail_out = (uInt)comprLen;
00442 
00443     c_stream.next_in = (Bytef*)hello;
00444     c_stream.avail_in = (uInt)strlen(hello)+1;
00445 
00446     err = deflate(&amp;c_stream, Z_FINISH);
00447     <span class="keywordflow">if</span> (err != Z_STREAM_END) {
00448         fprintf(stderr, <span class="stringliteral">"deflate should report Z_STREAM_END\n"</span>);
00449     exit(1);
00450     }
00451     err = deflateEnd(&amp;c_stream);
00452     CHECK_ERR(err, <span class="stringliteral">"deflateEnd"</span>);
00453 }
00454 
00455 <span class="comment">/* ===========================================================================</span>
00456 <span class="comment"> * Test inflate() with a preset dictionary</span>
00457 <span class="comment"> */</span>
00458 <span class="keywordtype">void</span> test_dict_inflate(compr, comprLen, uncompr, uncomprLen)
00459     Byte *compr, *uncompr;
00460     uLong comprLen, uncomprLen;
00461 {
00462     <span class="keywordtype">int</span> err;
00463     z_stream d_stream; <span class="comment">/* decompression stream */</span>
00464 
00465     strcpy((<span class="keywordtype">char</span>*)uncompr, <span class="stringliteral">"garbage"</span>);
00466 
00467     d_stream.zalloc = (alloc_func)0;
00468     d_stream.zfree = (free_func)0;
00469     d_stream.opaque = (voidpf)0;
00470 
00471     d_stream.next_in  = compr;
00472     d_stream.avail_in = (uInt)comprLen;
00473 
00474     err = inflateInit(&amp;d_stream);
00475     CHECK_ERR(err, <span class="stringliteral">"inflateInit"</span>);
00476 
00477     d_stream.next_out = uncompr;
00478     d_stream.avail_out = (uInt)uncomprLen;
00479 
00480     <span class="keywordflow">for</span> (;;) {
00481         err = inflate(&amp;d_stream, Z_NO_FLUSH);
00482         <span class="keywordflow">if</span> (err == Z_STREAM_END) <span class="keywordflow">break</span>;
00483     <span class="keywordflow">if</span> (err == Z_NEED_DICT) {
00484         <span class="keywordflow">if</span> (d_stream.adler != dictId) {
00485         fprintf(stderr, <span class="stringliteral">"unexpected dictionary"</span>);
00486         exit(1);
00487         }
00488         err = inflateSetDictionary(&amp;d_stream, (<span class="keyword">const</span> Bytef*)dictionary,
00489                        <span class="keyword">sizeof</span>(dictionary));
00490     }
00491         CHECK_ERR(err, <span class="stringliteral">"inflate with dict"</span>);
00492     }
00493 
00494     err = inflateEnd(&amp;d_stream);
00495     CHECK_ERR(err, <span class="stringliteral">"inflateEnd"</span>);
00496 
00497     <span class="keywordflow">if</span> (strcmp((<span class="keywordtype">char</span>*)uncompr, hello)) {
00498         fprintf(stderr, <span class="stringliteral">"bad inflate with dict\n"</span>);
00499     exit(1);
00500     } <span class="keywordflow">else</span> {
00501         printf(<span class="stringliteral">"inflate with dictionary: %s\n"</span>, (<span class="keywordtype">char</span> *)uncompr);
00502     }
00503 }
00504 
00505 <span class="comment">/* ===========================================================================</span>
00506 <span class="comment"> * Usage:  example [output.gz  [input.gz]]</span>
00507 <span class="comment"> */</span>
00508 
00509 <span class="keywordtype">int</span> main(argc, argv)
00510     <span class="keywordtype">int</span> argc;
00511     <span class="keywordtype">char</span> *argv[];
00512 {
00513     Byte *compr, *uncompr;
00514     uLong comprLen = 10000*<span class="keyword">sizeof</span>(int); <span class="comment">/* don't overflow on MSDOS */</span>
00515     uLong uncomprLen = comprLen;
00516     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* myVersion = ZLIB_VERSION;
00517 
00518     <span class="keywordflow">if</span> (zlibVersion()[0] != myVersion[0]) {
00519         fprintf(stderr, <span class="stringliteral">"incompatible zlib version\n"</span>);
00520         exit(1);
00521 
00522     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {
00523         fprintf(stderr, <span class="stringliteral">"warning: different zlib version\n"</span>);
00524     }
00525 
00526     compr    = (Byte*)calloc((uInt)comprLen, 1);
00527     uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
00528     <span class="comment">/* compr and uncompr are cleared to avoid reading uninitialized</span>
00529 <span class="comment">     * data and to ensure that uncompr compresses well.</span>
00530 <span class="comment">     */</span>
00531     <span class="keywordflow">if</span> (compr == Z_NULL || uncompr == Z_NULL) {
00532         printf(<span class="stringliteral">"out of memory\n"</span>);
00533     exit(1);
00534     }
00535     test_compress(compr, comprLen, uncompr, uncomprLen);
00536 
00537     test_gzio((argc &gt; 1 ? argv[1] : TESTFILE),
00538               (argc &gt; 2 ? argv[2] : TESTFILE),
00539           uncompr, (<span class="keywordtype">int</span>)uncomprLen);
00540 
00541     test_deflate(compr, comprLen);
00542     test_inflate(compr, comprLen, uncompr, uncomprLen);
00543 
00544     test_large_deflate(compr, comprLen, uncompr, uncomprLen);
00545     test_large_inflate(compr, comprLen, uncompr, uncomprLen);
00546 
00547     test_flush(compr, &amp;comprLen);
00548     test_sync(compr, comprLen, uncompr, uncomprLen);
00549     comprLen = uncomprLen;
00550 
00551     test_dict_deflate(compr, comprLen);
00552     test_dict_inflate(compr, comprLen, uncompr, uncomprLen);
00553 
00554     exit(0);
00555     <span class="keywordflow">return</span> 0; <span class="comment">/* to avoid warning */</span>
00556 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:40 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

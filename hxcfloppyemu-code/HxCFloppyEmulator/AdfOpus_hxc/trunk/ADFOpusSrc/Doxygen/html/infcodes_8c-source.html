<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>infcodes.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>infcodes.c</h1><div class="fragment"><pre>00001 <span class="comment">/* infcodes.c -- process literals and length/distance pairs</span>
00002 <span class="comment"> * Copyright (C) 1995-2002 Mark Adler</span>
00003 <span class="comment"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
00004 <span class="comment"> */</span>
00005 
00006 <span class="preprocessor">#include "zutil.h"</span>
00007 <span class="preprocessor">#include "inftrees.h"</span>
00008 <span class="preprocessor">#include "infblock.h"</span>
00009 <span class="preprocessor">#include "infcodes.h"</span>
00010 <span class="preprocessor">#include "infutil.h"</span>
00011 <span class="preprocessor">#include "inffast.h"</span>
00012 
00013 <span class="comment">/* simplify the use of the inflate_huft type with some defines */</span>
00014 <span class="preprocessor">#define exop word.what.Exop</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#define bits word.what.Bits</span>
00016 <span class="preprocessor"></span>
00017 <span class="keyword">typedef</span> <span class="keyword">enum</span> {        <span class="comment">/* waiting for "i:"=input, "o:"=output, "x:"=nothing */</span>
00018       START,    <span class="comment">/* x: set up for LEN */</span>
00019       LEN,      <span class="comment">/* i: get length/literal/eob next */</span>
00020       LENEXT,   <span class="comment">/* i: getting length extra (have base) */</span>
00021       DIST,     <span class="comment">/* i: get distance next */</span>
00022       DISTEXT,  <span class="comment">/* i: getting distance extra */</span>
00023       COPY,     <span class="comment">/* o: copying bytes in window, waiting for space */</span>
00024       LIT,      <span class="comment">/* o: got literal, waiting for output space */</span>
00025       WASH,     <span class="comment">/* o: got eob, possibly still output waiting */</span>
00026       END,      <span class="comment">/* x: got eob and all data flushed */</span>
00027       BADCODE}  <span class="comment">/* x: got error */</span>
00028 inflate_codes_mode;
00029 
00030 <span class="comment">/* inflate codes private state */</span>
00031 <span class="keyword">struct </span>inflate_codes_state {
00032 
00033   <span class="comment">/* mode */</span>
00034   inflate_codes_mode mode;      <span class="comment">/* current inflate_codes mode */</span>
00035 
00036   <span class="comment">/* mode dependent information */</span>
00037   uInt len;
00038   <span class="keyword">union </span>{
00039     <span class="keyword">struct </span>{
00040       inflate_huft *tree;       <span class="comment">/* pointer into tree */</span>
00041       uInt need;                <span class="comment">/* bits needed */</span>
00042     } code;             <span class="comment">/* if LEN or DIST, where in tree */</span>
00043     uInt lit;           <span class="comment">/* if LIT, literal */</span>
00044     <span class="keyword">struct </span>{
00045       uInt get;                 <span class="comment">/* bits to get for extra */</span>
00046       uInt dist;                <span class="comment">/* distance back to copy from */</span>
00047     } copy;             <span class="comment">/* if EXT or COPY, where and how much */</span>
00048   } sub;                <span class="comment">/* submode */</span>
00049 
00050   <span class="comment">/* mode independent information */</span>
00051   Byte lbits;           <span class="comment">/* ltree bits decoded per branch */</span>
00052   Byte dbits;           <span class="comment">/* dtree bits decoder per branch */</span>
00053   inflate_huft *ltree;          <span class="comment">/* literal/length/eob tree */</span>
00054   inflate_huft *dtree;          <span class="comment">/* distance tree */</span>
00055 
00056 };
00057 
00058 
00059 inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
00060 uInt bl, bd;
00061 inflate_huft *tl;
00062 inflate_huft *td; <span class="comment">/* need separate declaration for Borland C++ */</span>
00063 z_streamp z;
00064 {
00065   inflate_codes_statef *c;
00066 
00067   <span class="keywordflow">if</span> ((c = (inflate_codes_statef *)
00068        ZALLOC(z,1,<span class="keyword">sizeof</span>(<span class="keyword">struct</span> inflate_codes_state))) != Z_NULL)
00069   {
00070     c-&gt;mode = START;
00071     c-&gt;lbits = (Byte)bl;
00072     c-&gt;dbits = (Byte)bd;
00073     c-&gt;ltree = tl;
00074     c-&gt;dtree = td;
00075     Tracev((stderr, <span class="stringliteral">"inflate:       codes new\n"</span>));
00076   }
00077   <span class="keywordflow">return</span> c;
00078 }
00079 
00080 
00081 <span class="keywordtype">int</span> inflate_codes(s, z, r)
00082 inflate_blocks_statef *s;
00083 z_streamp z;
00084 <span class="keywordtype">int</span> r;
00085 {
00086   uInt j;               <span class="comment">/* temporary storage */</span>
00087   inflate_huft *t;      <span class="comment">/* temporary pointer */</span>
00088   uInt e;               <span class="comment">/* extra bits or operation */</span>
00089   uLong b;              <span class="comment">/* bit buffer */</span>
00090   uInt k;               <span class="comment">/* bits in bit buffer */</span>
00091   Bytef *p;             <span class="comment">/* input data pointer */</span>
00092   uInt n;               <span class="comment">/* bytes available there */</span>
00093   Bytef *q;             <span class="comment">/* output window write pointer */</span>
00094   uInt m;               <span class="comment">/* bytes to end of window or read pointer */</span>
00095   Bytef *f;             <span class="comment">/* pointer to copy strings from */</span>
00096   inflate_codes_statef *c = s-&gt;sub.decode.codes;  <span class="comment">/* codes state */</span>
00097 
00098   <span class="comment">/* copy input/output information to locals (UPDATE macro restores) */</span>
00099   LOAD
00100 
00101   <span class="comment">/* process input and output based on current state */</span>
00102   <span class="keywordflow">while</span> (1) <span class="keywordflow">switch</span> (c-&gt;mode)
00103   {             <span class="comment">/* waiting for "i:"=input, "o:"=output, "x:"=nothing */</span>
00104     <span class="keywordflow">case</span> START:         <span class="comment">/* x: set up for LEN */</span>
00105 <span class="preprocessor">#ifndef SLOW</span>
00106 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (m &gt;= 258 &amp;&amp; n &gt;= 10)
00107       {
00108         UPDATE
00109         r = inflate_fast(c-&gt;lbits, c-&gt;dbits, c-&gt;ltree, c-&gt;dtree, s, z);
00110         LOAD
00111         <span class="keywordflow">if</span> (r != Z_OK)
00112         {
00113           c-&gt;mode = r == Z_STREAM_END ? WASH : BADCODE;
00114           <span class="keywordflow">break</span>;
00115         }
00116       }
00117 <span class="preprocessor">#endif </span><span class="comment">/* !SLOW */</span>
00118       c-&gt;sub.code.need = c-&gt;lbits;
00119       c-&gt;sub.code.tree = c-&gt;ltree;
00120       c-&gt;mode = LEN;
00121     <span class="keywordflow">case</span> LEN:           <span class="comment">/* i: get length/literal/eob next */</span>
00122       j = c-&gt;sub.code.need;
00123       NEEDBITS(j)
00124       t = c-&gt;sub.code.tree + ((uInt)b &amp; inflate_mask[j]);
00125       DUMPBITS(t-&gt;bits)
00126       e = (uInt)(t-&gt;exop);
00127       <span class="keywordflow">if</span> (e == 0)               <span class="comment">/* literal */</span>
00128       {
00129         c-&gt;sub.lit = t-&gt;base;
00130         Tracevv((stderr, t-&gt;base &gt;= 0x20 &amp;&amp; t-&gt;base &lt; 0x7f ?
00131                  <span class="stringliteral">"inflate:         literal '%c'\n"</span> :
00132                  <span class="stringliteral">"inflate:         literal 0x%02x\n"</span>, t-&gt;base));
00133         c-&gt;mode = LIT;
00134         <span class="keywordflow">break</span>;
00135       }
00136       <span class="keywordflow">if</span> (e &amp; 16)               <span class="comment">/* length */</span>
00137       {
00138         c-&gt;sub.copy.get = e &amp; 15;
00139         c-&gt;len = t-&gt;base;
00140         c-&gt;mode = LENEXT;
00141         <span class="keywordflow">break</span>;
00142       }
00143       <span class="keywordflow">if</span> ((e &amp; 64) == 0)        <span class="comment">/* next table */</span>
00144       {
00145         c-&gt;sub.code.need = e;
00146         c-&gt;sub.code.tree = t + t-&gt;base;
00147         <span class="keywordflow">break</span>;
00148       }
00149       <span class="keywordflow">if</span> (e &amp; 32)               <span class="comment">/* end of block */</span>
00150       {
00151         Tracevv((stderr, <span class="stringliteral">"inflate:         end of block\n"</span>));
00152         c-&gt;mode = WASH;
00153         <span class="keywordflow">break</span>;
00154       }
00155       c-&gt;mode = BADCODE;        <span class="comment">/* invalid code */</span>
00156       z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"invalid literal/length code"</span>;
00157       r = Z_DATA_ERROR;
00158       LEAVE
00159     <span class="keywordflow">case</span> LENEXT:        <span class="comment">/* i: getting length extra (have base) */</span>
00160       j = c-&gt;sub.copy.get;
00161       NEEDBITS(j)
00162       c-&gt;len += (uInt)b &amp; inflate_mask[j];
00163       DUMPBITS(j)
00164       c-&gt;sub.code.need = c-&gt;dbits;
00165       c-&gt;sub.code.tree = c-&gt;dtree;
00166       Tracevv((stderr, <span class="stringliteral">"inflate:         length %u\n"</span>, c-&gt;len));
00167       c-&gt;mode = DIST;
00168     <span class="keywordflow">case</span> DIST:          <span class="comment">/* i: get distance next */</span>
00169       j = c-&gt;sub.code.need;
00170       NEEDBITS(j)
00171       t = c-&gt;sub.code.tree + ((uInt)b &amp; inflate_mask[j]);
00172       DUMPBITS(t-&gt;bits)
00173       e = (uInt)(t-&gt;exop);
00174       <span class="keywordflow">if</span> (e &amp; 16)               <span class="comment">/* distance */</span>
00175       {
00176         c-&gt;sub.copy.get = e &amp; 15;
00177         c-&gt;sub.copy.dist = t-&gt;base;
00178         c-&gt;mode = DISTEXT;
00179         <span class="keywordflow">break</span>;
00180       }
00181       <span class="keywordflow">if</span> ((e &amp; 64) == 0)        <span class="comment">/* next table */</span>
00182       {
00183         c-&gt;sub.code.need = e;
00184         c-&gt;sub.code.tree = t + t-&gt;base;
00185         <span class="keywordflow">break</span>;
00186       }
00187       c-&gt;mode = BADCODE;        <span class="comment">/* invalid code */</span>
00188       z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"invalid distance code"</span>;
00189       r = Z_DATA_ERROR;
00190       LEAVE
00191     <span class="keywordflow">case</span> DISTEXT:       <span class="comment">/* i: getting distance extra */</span>
00192       j = c-&gt;sub.copy.get;
00193       NEEDBITS(j)
00194       c-&gt;sub.copy.dist += (uInt)b &amp; inflate_mask[j];
00195       DUMPBITS(j)
00196       Tracevv((stderr, <span class="stringliteral">"inflate:         distance %u\n"</span>, c-&gt;sub.copy.dist));
00197       c-&gt;mode = COPY;
00198     <span class="keywordflow">case</span> COPY:          <span class="comment">/* o: copying bytes in window, waiting for space */</span>
00199       f = q - c-&gt;sub.copy.dist;
00200       <span class="keywordflow">while</span> (f &lt; s-&gt;window)             <span class="comment">/* modulo window size-"while" instead */</span>
00201         f += s-&gt;end - s-&gt;window;        <span class="comment">/* of "if" handles invalid distances */</span>
00202       <span class="keywordflow">while</span> (c-&gt;len)
00203       {
00204         NEEDOUT
00205         OUTBYTE(*f++)
00206         <span class="keywordflow">if</span> (f == s-&gt;end)
00207           f = s-&gt;window;
00208         c-&gt;len--;
00209       }
00210       c-&gt;mode = START;
00211       <span class="keywordflow">break</span>;
00212     <span class="keywordflow">case</span> LIT:           <span class="comment">/* o: got literal, waiting for output space */</span>
00213       NEEDOUT
00214       OUTBYTE(c-&gt;sub.lit)
00215       c-&gt;mode = START;
00216       <span class="keywordflow">break</span>;
00217     <span class="keywordflow">case</span> WASH:          <span class="comment">/* o: got eob, possibly more output */</span>
00218       <span class="keywordflow">if</span> (k &gt; 7)        <span class="comment">/* return unused byte, if any */</span>
00219       {
00220         Assert(k &lt; 16, <span class="stringliteral">"inflate_codes grabbed too many bytes"</span>)
00221         k -= 8;
00222         n++;
00223         p--;            <span class="comment">/* can always return one */</span>
00224       }
00225       FLUSH
00226       <span class="keywordflow">if</span> (s-&gt;read != s-&gt;write)
00227         LEAVE
00228       c-&gt;mode = END;
00229     <span class="keywordflow">case</span> END:
00230       r = Z_STREAM_END;
00231       LEAVE
00232     <span class="keywordflow">case</span> BADCODE:       <span class="comment">/* x: got error */</span>
00233       r = Z_DATA_ERROR;
00234       LEAVE
00235     <span class="keywordflow">default</span>:
00236       r = Z_STREAM_ERROR;
00237       LEAVE
00238   }
00239 <span class="preprocessor">#ifdef NEED_DUMMY_RETURN</span>
00240 <span class="preprocessor"></span>  <span class="keywordflow">return</span> Z_STREAM_ERROR;  <span class="comment">/* Some dumb compilers complain without this */</span>
00241 <span class="preprocessor">#endif</span>
00242 <span class="preprocessor"></span>}
00243 
00244 
00245 <span class="keywordtype">void</span> inflate_codes_free(c, z)
00246 inflate_codes_statef *c;
00247 z_streamp z;
00248 {
00249   ZFREE(z, c);
00250   Tracev((stderr, <span class="stringliteral">"inflate:       codes free\n"</span>));
00251 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:41 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>trees.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>trees.c</h1><div class="fragment"><pre>00001 <span class="comment">/* trees.c -- output deflated data using Huffman coding</span>
00002 <span class="comment"> * Copyright (C) 1995-2002 Jean-loup Gailly</span>
00003 <span class="comment"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
00004 <span class="comment"> */</span>
00005 
00006 <span class="comment">/*</span>
00007 <span class="comment"> *  ALGORITHM</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *      The "deflation" process uses several Huffman trees. The more</span>
00010 <span class="comment"> *      common source values are represented by shorter bit sequences.</span>
00011 <span class="comment"> *</span>
00012 <span class="comment"> *      Each code tree is stored in a compressed form which is itself</span>
00013 <span class="comment"> * a Huffman encoding of the lengths of all the code strings (in</span>
00014 <span class="comment"> * ascending order by source values).  The actual code strings are</span>
00015 <span class="comment"> * reconstructed from the lengths in the inflate process, as described</span>
00016 <span class="comment"> * in the deflate specification.</span>
00017 <span class="comment"> *</span>
00018 <span class="comment"> *  REFERENCES</span>
00019 <span class="comment"> *</span>
00020 <span class="comment"> *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".</span>
00021 <span class="comment"> *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc</span>
00022 <span class="comment"> *</span>
00023 <span class="comment"> *      Storer, James A.</span>
00024 <span class="comment"> *          Data Compression:  Methods and Theory, pp. 49-50.</span>
00025 <span class="comment"> *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.</span>
00026 <span class="comment"> *</span>
00027 <span class="comment"> *      Sedgewick, R.</span>
00028 <span class="comment"> *          Algorithms, p290.</span>
00029 <span class="comment"> *          Addison-Wesley, 1983. ISBN 0-201-06672-6.</span>
00030 <span class="comment"> */</span>
00031 
00032 <span class="comment">/* @(#) $Id: trees_8c-source.html,v 1.1 2002/11/14 01:50:04 garyjharris Exp $ */</span>
00033 
00034 <span class="comment">/* #define GEN_TREES_H */</span>
00035 
00036 <span class="preprocessor">#include "deflate.h"</span>
00037 
00038 <span class="preprocessor">#ifdef DEBUG</span>
00039 <span class="preprocessor"></span><span class="preprocessor">#  include &lt;ctype.h&gt;</span>
00040 <span class="preprocessor">#endif</span>
00041 <span class="preprocessor"></span>
00042 <span class="comment">/* ===========================================================================</span>
00043 <span class="comment"> * Constants</span>
00044 <span class="comment"> */</span>
00045 
00046 <span class="preprocessor">#define MAX_BL_BITS 7</span>
00047 <span class="preprocessor"></span><span class="comment">/* Bit length codes must not exceed MAX_BL_BITS bits */</span>
00048 
00049 <span class="preprocessor">#define END_BLOCK 256</span>
00050 <span class="preprocessor"></span><span class="comment">/* end of block literal code */</span>
00051 
00052 <span class="preprocessor">#define REP_3_6      16</span>
00053 <span class="preprocessor"></span><span class="comment">/* repeat previous bit length 3-6 times (2 bits of repeat count) */</span>
00054 
00055 <span class="preprocessor">#define REPZ_3_10    17</span>
00056 <span class="preprocessor"></span><span class="comment">/* repeat a zero length 3-10 times  (3 bits of repeat count) */</span>
00057 
00058 <span class="preprocessor">#define REPZ_11_138  18</span>
00059 <span class="preprocessor"></span><span class="comment">/* repeat a zero length 11-138 times  (7 bits of repeat count) */</span>
00060 
00061 local <span class="keyword">const</span> <span class="keywordtype">int</span> extra_lbits[LENGTH_CODES] <span class="comment">/* extra bits for each length code */</span>
00062    = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};
00063 
00064 local <span class="keyword">const</span> <span class="keywordtype">int</span> extra_dbits[D_CODES] <span class="comment">/* extra bits for each distance code */</span>
00065    = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};
00066 
00067 local <span class="keyword">const</span> <span class="keywordtype">int</span> extra_blbits[BL_CODES]<span class="comment">/* extra bits for each bit length code */</span>
00068    = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};
00069 
00070 local <span class="keyword">const</span> uch bl_order[BL_CODES]
00071    = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
00072 <span class="comment">/* The lengths of the bit length codes are sent in order of decreasing</span>
00073 <span class="comment"> * probability, to avoid transmitting the lengths for unused bit length codes.</span>
00074 <span class="comment"> */</span>
00075 
00076 <span class="preprocessor">#define Buf_size (8 * 2*sizeof(char))</span>
00077 <span class="preprocessor"></span><span class="comment">/* Number of bits used within bi_buf. (bi_buf might be implemented on</span>
00078 <span class="comment"> * more than 16 bits on some systems.)</span>
00079 <span class="comment"> */</span>
00080 
00081 <span class="comment">/* ===========================================================================</span>
00082 <span class="comment"> * Local data. These are initialized only once.</span>
00083 <span class="comment"> */</span>
00084 
00085 <span class="preprocessor">#define DIST_CODE_LEN  512 </span><span class="comment">/* see definition of array dist_code below */</span>
00086 
00087 <span class="preprocessor">#if defined(GEN_TREES_H) || !defined(STDC)</span>
00088 <span class="preprocessor"></span><span class="comment">/* non ANSI compilers may not accept trees.h */</span>
00089 
00090 local ct_data static_ltree[L_CODES+2];
00091 <span class="comment">/* The static literal tree. Since the bit lengths are imposed, there is no</span>
00092 <span class="comment"> * need for the L_CODES extra codes used during heap construction. However</span>
00093 <span class="comment"> * The codes 286 and 287 are needed to build a canonical tree (see _tr_init</span>
00094 <span class="comment"> * below).</span>
00095 <span class="comment"> */</span>
00096 
00097 local ct_data static_dtree[D_CODES];
00098 <span class="comment">/* The static distance tree. (Actually a trivial tree since all codes use</span>
00099 <span class="comment"> * 5 bits.)</span>
00100 <span class="comment"> */</span>
00101 
00102 uch _dist_code[DIST_CODE_LEN];
00103 <span class="comment">/* Distance codes. The first 256 values correspond to the distances</span>
00104 <span class="comment"> * 3 .. 258, the last 256 values correspond to the top 8 bits of</span>
00105 <span class="comment"> * the 15 bit distances.</span>
00106 <span class="comment"> */</span>
00107 
00108 uch _length_code[MAX_MATCH-MIN_MATCH+1];
00109 <span class="comment">/* length code for each normalized match length (0 == MIN_MATCH) */</span>
00110 
00111 local <span class="keywordtype">int</span> base_length[LENGTH_CODES];
00112 <span class="comment">/* First normalized length for each code (0 = MIN_MATCH) */</span>
00113 
00114 local <span class="keywordtype">int</span> base_dist[D_CODES];
00115 <span class="comment">/* First normalized distance for each code (0 = distance of 1) */</span>
00116 
00117 <span class="preprocessor">#else</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#  include "trees.h"</span>
00119 <span class="preprocessor">#endif </span><span class="comment">/* GEN_TREES_H */</span>
00120 
00121 <span class="keyword">struct </span>static_tree_desc_s {
00122     <span class="keyword">const</span> ct_data *static_tree;  <span class="comment">/* static tree or NULL */</span>
00123     <span class="keyword">const</span> intf *extra_bits;      <span class="comment">/* extra bits for each code or NULL */</span>
00124     <span class="keywordtype">int</span>     extra_base;          <span class="comment">/* base index for extra_bits */</span>
00125     <span class="keywordtype">int</span>     elems;               <span class="comment">/* max number of elements in the tree */</span>
00126     <span class="keywordtype">int</span>     max_length;          <span class="comment">/* max bit length for the codes */</span>
00127 };
00128 
00129 local static_tree_desc  static_l_desc =
00130 {static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};
00131 
00132 local static_tree_desc  static_d_desc =
00133 {static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};
00134 
00135 local static_tree_desc  static_bl_desc =
00136 {(<span class="keyword">const</span> ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};
00137 
00138 <span class="comment">/* ===========================================================================</span>
00139 <span class="comment"> * Local (static) routines in this file.</span>
00140 <span class="comment"> */</span>
00141 
00142 local <span class="keywordtype">void</span> tr_static_init OF((<span class="keywordtype">void</span>));
00143 local <span class="keywordtype">void</span> init_block     OF((deflate_state *s));
00144 local <span class="keywordtype">void</span> pqdownheap     OF((deflate_state *s, ct_data *tree, <span class="keywordtype">int</span> k));
00145 local <span class="keywordtype">void</span> gen_bitlen     OF((deflate_state *s, tree_desc *desc));
00146 local <span class="keywordtype">void</span> gen_codes      OF((ct_data *tree, <span class="keywordtype">int</span> max_code, ushf *bl_count));
00147 local <span class="keywordtype">void</span> build_tree     OF((deflate_state *s, tree_desc *desc));
00148 local <span class="keywordtype">void</span> scan_tree      OF((deflate_state *s, ct_data *tree, <span class="keywordtype">int</span> max_code));
00149 local <span class="keywordtype">void</span> send_tree      OF((deflate_state *s, ct_data *tree, <span class="keywordtype">int</span> max_code));
00150 local <span class="keywordtype">int</span>  build_bl_tree  OF((deflate_state *s));
00151 local <span class="keywordtype">void</span> send_all_trees OF((deflate_state *s, <span class="keywordtype">int</span> lcodes, <span class="keywordtype">int</span> dcodes,
00152                               <span class="keywordtype">int</span> blcodes));
00153 local <span class="keywordtype">void</span> compress_block OF((deflate_state *s, ct_data *ltree,
00154                               ct_data *dtree));
00155 local <span class="keywordtype">void</span> set_data_type  OF((deflate_state *s));
00156 local <span class="keywordtype">unsigned</span> bi_reverse OF((<span class="keywordtype">unsigned</span> value, <span class="keywordtype">int</span> length));
00157 local <span class="keywordtype">void</span> bi_windup      OF((deflate_state *s));
00158 local <span class="keywordtype">void</span> bi_flush       OF((deflate_state *s));
00159 local <span class="keywordtype">void</span> copy_block     OF((deflate_state *s, charf *buf, <span class="keywordtype">unsigned</span> len,
00160                               <span class="keywordtype">int</span> header));
00161 
00162 <span class="preprocessor">#ifdef GEN_TREES_H</span>
00163 <span class="preprocessor"></span>local <span class="keywordtype">void</span> gen_trees_header OF((<span class="keywordtype">void</span>));
00164 <span class="preprocessor">#endif</span>
00165 <span class="preprocessor"></span>
00166 <span class="preprocessor">#ifndef DEBUG</span>
00167 <span class="preprocessor"></span><span class="preprocessor">#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)</span>
00168 <span class="preprocessor"></span>   <span class="comment">/* Send a code of the given tree. c and tree must not have side effects */</span>
00169 
00170 <span class="preprocessor">#else </span><span class="comment">/* DEBUG */</span>
00171 <span class="preprocessor">#  define send_code(s, c, tree) \</span>
00172 <span class="preprocessor">     { if (z_verbose&gt;2) fprintf(stderr,"\ncd %3d ",(c)); \</span>
00173 <span class="preprocessor">       send_bits(s, tree[c].Code, tree[c].Len); }</span>
00174 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00175 <span class="preprocessor"></span>
00176 <span class="comment">/* ===========================================================================</span>
00177 <span class="comment"> * Output a short LSB first on the stream.</span>
00178 <span class="comment"> * IN assertion: there is enough room in pendingBuf.</span>
00179 <span class="comment"> */</span>
00180 <span class="preprocessor">#define put_short(s, w) { \</span>
00181 <span class="preprocessor">    put_byte(s, (uch)((w) &amp; 0xff)); \</span>
00182 <span class="preprocessor">    put_byte(s, (uch)((ush)(w) &gt;&gt; 8)); \</span>
00183 <span class="preprocessor">}</span>
00184 <span class="preprocessor"></span>
00185 <span class="comment">/* ===========================================================================</span>
00186 <span class="comment"> * Send a value on a given number of bits.</span>
00187 <span class="comment"> * IN assertion: length &lt;= 16 and value fits in length bits.</span>
00188 <span class="comment"> */</span>
00189 <span class="preprocessor">#ifdef DEBUG</span>
00190 <span class="preprocessor"></span>local <span class="keywordtype">void</span> send_bits      OF((deflate_state *s, <span class="keywordtype">int</span> value, <span class="keywordtype">int</span> length));
00191 
00192 local <span class="keywordtype">void</span> send_bits(s, value, length)
00193     deflate_state *s;
00194     <span class="keywordtype">int</span> value;  <span class="comment">/* value to send */</span>
00195     <span class="keywordtype">int</span> length; <span class="comment">/* number of bits */</span>
00196 {
00197     Tracevv((stderr,<span class="stringliteral">" l %2d v %4x "</span>, length, value));
00198     Assert(length &gt; 0 &amp;&amp; length &lt;= 15, <span class="stringliteral">"invalid length"</span>);
00199     s-&gt;bits_sent += (ulg)length;
00200 
00201     <span class="comment">/* If not enough room in bi_buf, use (valid) bits from bi_buf and</span>
00202 <span class="comment">     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))</span>
00203 <span class="comment">     * unused bits in value.</span>
00204 <span class="comment">     */</span>
00205     <span class="keywordflow">if</span> (s-&gt;bi_valid &gt; (int)Buf_size - length) {
00206         s-&gt;bi_buf |= (value &lt;&lt; s-&gt;bi_valid);
00207         put_short(s, s-&gt;bi_buf);
00208         s-&gt;bi_buf = (ush)value &gt;&gt; (Buf_size - s-&gt;bi_valid);
00209         s-&gt;bi_valid += length - Buf_size;
00210     } <span class="keywordflow">else</span> {
00211         s-&gt;bi_buf |= value &lt;&lt; s-&gt;bi_valid;
00212         s-&gt;bi_valid += length;
00213     }
00214 }
00215 <span class="preprocessor">#else </span><span class="comment">/* !DEBUG */</span>
00216 
00217 <span class="preprocessor">#define send_bits(s, value, length) \</span>
00218 <span class="preprocessor">{ int len = length;\</span>
00219 <span class="preprocessor">  if (s-&gt;bi_valid &gt; (int)Buf_size - len) {\</span>
00220 <span class="preprocessor">    int val = value;\</span>
00221 <span class="preprocessor">    s-&gt;bi_buf |= (val &lt;&lt; s-&gt;bi_valid);\</span>
00222 <span class="preprocessor">    put_short(s, s-&gt;bi_buf);\</span>
00223 <span class="preprocessor">    s-&gt;bi_buf = (ush)val &gt;&gt; (Buf_size - s-&gt;bi_valid);\</span>
00224 <span class="preprocessor">    s-&gt;bi_valid += len - Buf_size;\</span>
00225 <span class="preprocessor">  } else {\</span>
00226 <span class="preprocessor">    s-&gt;bi_buf |= (value) &lt;&lt; s-&gt;bi_valid;\</span>
00227 <span class="preprocessor">    s-&gt;bi_valid += len;\</span>
00228 <span class="preprocessor">  }\</span>
00229 <span class="preprocessor">}</span>
00230 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* DEBUG */</span>
00231 
00232 
00233 <span class="preprocessor">#define MAX(a,b) (a &gt;= b ? a : b)</span>
00234 <span class="preprocessor"></span><span class="comment">/* the arguments must not have side effects */</span>
00235 
00236 <span class="comment">/* ===========================================================================</span>
00237 <span class="comment"> * Initialize the various 'constant' tables.</span>
00238 <span class="comment"> */</span>
00239 local <span class="keywordtype">void</span> tr_static_init()
00240 {
00241 <span class="preprocessor">#if defined(GEN_TREES_H) || !defined(STDC)</span>
00242 <span class="preprocessor"></span>    <span class="keyword">static</span> <span class="keywordtype">int</span> static_init_done = 0;
00243     <span class="keywordtype">int</span> n;        <span class="comment">/* iterates over tree elements */</span>
00244     <span class="keywordtype">int</span> bits;     <span class="comment">/* bit counter */</span>
00245     <span class="keywordtype">int</span> length;   <span class="comment">/* length value */</span>
00246     <span class="keywordtype">int</span> code;     <span class="comment">/* code value */</span>
00247     <span class="keywordtype">int</span> dist;     <span class="comment">/* distance index */</span>
00248     ush bl_count[MAX_BITS+1];
00249     <span class="comment">/* number of codes at each bit length for an optimal tree */</span>
00250 
00251     <span class="keywordflow">if</span> (static_init_done) <span class="keywordflow">return</span>;
00252 
00253     <span class="comment">/* For some embedded targets, global variables are not initialized: */</span>
00254     static_l_desc.static_tree = static_ltree;
00255     static_l_desc.extra_bits = extra_lbits;
00256     static_d_desc.static_tree = static_dtree;
00257     static_d_desc.extra_bits = extra_dbits;
00258     static_bl_desc.extra_bits = extra_blbits;
00259 
00260     <span class="comment">/* Initialize the mapping length (0..255) -&gt; length code (0..28) */</span>
00261     length = 0;
00262     <span class="keywordflow">for</span> (code = 0; code &lt; LENGTH_CODES-1; code++) {
00263         base_length[code] = length;
00264         <span class="keywordflow">for</span> (n = 0; n &lt; (1&lt;&lt;extra_lbits[code]); n++) {
00265             _length_code[length++] = (uch)code;
00266         }
00267     }
00268     Assert (length == 256, <span class="stringliteral">"tr_static_init: length != 256"</span>);
00269     <span class="comment">/* Note that the length 255 (match length 258) can be represented</span>
00270 <span class="comment">     * in two different ways: code 284 + 5 bits or code 285, so we</span>
00271 <span class="comment">     * overwrite length_code[255] to use the best encoding:</span>
00272 <span class="comment">     */</span>
00273     _length_code[length-1] = (uch)code;
00274 
00275     <span class="comment">/* Initialize the mapping dist (0..32K) -&gt; dist code (0..29) */</span>
00276     dist = 0;
00277     <span class="keywordflow">for</span> (code = 0 ; code &lt; 16; code++) {
00278         base_dist[code] = dist;
00279         <span class="keywordflow">for</span> (n = 0; n &lt; (1&lt;&lt;extra_dbits[code]); n++) {
00280             _dist_code[dist++] = (uch)code;
00281         }
00282     }
00283     Assert (dist == 256, <span class="stringliteral">"tr_static_init: dist != 256"</span>);
00284     dist &gt;&gt;= 7; <span class="comment">/* from now on, all distances are divided by 128 */</span>
00285     <span class="keywordflow">for</span> ( ; code &lt; D_CODES; code++) {
00286         base_dist[code] = dist &lt;&lt; 7;
00287         <span class="keywordflow">for</span> (n = 0; n &lt; (1&lt;&lt;(extra_dbits[code]-7)); n++) {
00288             _dist_code[256 + dist++] = (uch)code;
00289         }
00290     }
00291     Assert (dist == 256, <span class="stringliteral">"tr_static_init: 256+dist != 512"</span>);
00292 
00293     <span class="comment">/* Construct the codes of the static literal tree */</span>
00294     <span class="keywordflow">for</span> (bits = 0; bits &lt;= MAX_BITS; bits++) bl_count[bits] = 0;
00295     n = 0;
00296     <span class="keywordflow">while</span> (n &lt;= 143) static_ltree[n++].Len = 8, bl_count[8]++;
00297     <span class="keywordflow">while</span> (n &lt;= 255) static_ltree[n++].Len = 9, bl_count[9]++;
00298     <span class="keywordflow">while</span> (n &lt;= 279) static_ltree[n++].Len = 7, bl_count[7]++;
00299     <span class="keywordflow">while</span> (n &lt;= 287) static_ltree[n++].Len = 8, bl_count[8]++;
00300     <span class="comment">/* Codes 286 and 287 do not exist, but we must include them in the</span>
00301 <span class="comment">     * tree construction to get a canonical Huffman tree (longest code</span>
00302 <span class="comment">     * all ones)</span>
00303 <span class="comment">     */</span>
00304     gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);
00305 
00306     <span class="comment">/* The static distance tree is trivial: */</span>
00307     <span class="keywordflow">for</span> (n = 0; n &lt; D_CODES; n++) {
00308         static_dtree[n].Len = 5;
00309         static_dtree[n].Code = bi_reverse((<span class="keywordtype">unsigned</span>)n, 5);
00310     }
00311     static_init_done = 1;
00312 
00313 <span class="preprocessor">#  ifdef GEN_TREES_H</span>
00314 <span class="preprocessor"></span>    gen_trees_header();
00315 <span class="preprocessor">#  endif</span>
00316 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* defined(GEN_TREES_H) || !defined(STDC) */</span>
00317 }
00318 
00319 <span class="comment">/* ===========================================================================</span>
00320 <span class="comment"> * Genererate the file trees.h describing the static trees.</span>
00321 <span class="comment"> */</span>
00322 <span class="preprocessor">#ifdef GEN_TREES_H</span>
00323 <span class="preprocessor"></span><span class="preprocessor">#  ifndef DEBUG</span>
00324 <span class="preprocessor"></span><span class="preprocessor">#    include &lt;stdio.h&gt;</span>
00325 <span class="preprocessor">#  endif</span>
00326 <span class="preprocessor"></span>
00327 <span class="preprocessor">#  define SEPARATOR(i, last, width) \</span>
00328 <span class="preprocessor">      ((i) == (last)? "\n};\n\n" :    \</span>
00329 <span class="preprocessor">       ((i) % (width) == (width)-1 ? ",\n" : ", "))</span>
00330 <span class="preprocessor"></span>
00331 <span class="keywordtype">void</span> gen_trees_header()
00332 {
00333     FILE *header = fopen(<span class="stringliteral">"trees.h"</span>, <span class="stringliteral">"w"</span>);
00334     <span class="keywordtype">int</span> i;
00335 
00336     Assert (header != NULL, <span class="stringliteral">"Can't open trees.h"</span>);
00337     fprintf(header,
00338         <span class="stringliteral">"/* header created automatically with -DGEN_TREES_H */\n\n"</span>);
00339 
00340     fprintf(header, <span class="stringliteral">"local const ct_data static_ltree[L_CODES+2] = {\n"</span>);
00341     <span class="keywordflow">for</span> (i = 0; i &lt; L_CODES+2; i++) {
00342     fprintf(header, <span class="stringliteral">"{{%3u},{%3u}}%s"</span>, static_ltree[i].Code,
00343         static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
00344     }
00345 
00346     fprintf(header, <span class="stringliteral">"local const ct_data static_dtree[D_CODES] = {\n"</span>);
00347     <span class="keywordflow">for</span> (i = 0; i &lt; D_CODES; i++) {
00348     fprintf(header, <span class="stringliteral">"{{%2u},{%2u}}%s"</span>, static_dtree[i].Code,
00349         static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
00350     }
00351 
00352     fprintf(header, <span class="stringliteral">"const uch _dist_code[DIST_CODE_LEN] = {\n"</span>);
00353     <span class="keywordflow">for</span> (i = 0; i &lt; DIST_CODE_LEN; i++) {
00354     fprintf(header, <span class="stringliteral">"%2u%s"</span>, _dist_code[i],
00355         SEPARATOR(i, DIST_CODE_LEN-1, 20));
00356     }
00357 
00358     fprintf(header, <span class="stringliteral">"const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n"</span>);
00359     <span class="keywordflow">for</span> (i = 0; i &lt; MAX_MATCH-MIN_MATCH+1; i++) {
00360     fprintf(header, <span class="stringliteral">"%2u%s"</span>, _length_code[i],
00361         SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
00362     }
00363 
00364     fprintf(header, <span class="stringliteral">"local const int base_length[LENGTH_CODES] = {\n"</span>);
00365     <span class="keywordflow">for</span> (i = 0; i &lt; LENGTH_CODES; i++) {
00366     fprintf(header, <span class="stringliteral">"%1u%s"</span>, base_length[i],
00367         SEPARATOR(i, LENGTH_CODES-1, 20));
00368     }
00369 
00370     fprintf(header, <span class="stringliteral">"local const int base_dist[D_CODES] = {\n"</span>);
00371     <span class="keywordflow">for</span> (i = 0; i &lt; D_CODES; i++) {
00372     fprintf(header, <span class="stringliteral">"%5u%s"</span>, base_dist[i],
00373         SEPARATOR(i, D_CODES-1, 10));
00374     }
00375 
00376     fclose(header);
00377 }
00378 <span class="preprocessor">#endif </span><span class="comment">/* GEN_TREES_H */</span>
00379 
00380 <span class="comment">/* ===========================================================================</span>
00381 <span class="comment"> * Initialize the tree data structures for a new zlib stream.</span>
00382 <span class="comment"> */</span>
00383 <span class="keywordtype">void</span> _tr_init(s)
00384     deflate_state *s;
00385 {
00386     tr_static_init();
00387 
00388     s-&gt;l_desc.dyn_tree = s-&gt;dyn_ltree;
00389     s-&gt;l_desc.stat_desc = &amp;static_l_desc;
00390 
00391     s-&gt;d_desc.dyn_tree = s-&gt;dyn_dtree;
00392     s-&gt;d_desc.stat_desc = &amp;static_d_desc;
00393 
00394     s-&gt;bl_desc.dyn_tree = s-&gt;bl_tree;
00395     s-&gt;bl_desc.stat_desc = &amp;static_bl_desc;
00396 
00397     s-&gt;bi_buf = 0;
00398     s-&gt;bi_valid = 0;
00399     s-&gt;last_eob_len = 8; <span class="comment">/* enough lookahead for inflate */</span>
00400 <span class="preprocessor">#ifdef DEBUG</span>
00401 <span class="preprocessor"></span>    s-&gt;compressed_len = 0L;
00402     s-&gt;bits_sent = 0L;
00403 <span class="preprocessor">#endif</span>
00404 <span class="preprocessor"></span>
00405     <span class="comment">/* Initialize the first block of the first file: */</span>
00406     init_block(s);
00407 }
00408 
00409 <span class="comment">/* ===========================================================================</span>
00410 <span class="comment"> * Initialize a new block.</span>
00411 <span class="comment"> */</span>
00412 local <span class="keywordtype">void</span> init_block(s)
00413     deflate_state *s;
00414 {
00415     <span class="keywordtype">int</span> n; <span class="comment">/* iterates over tree elements */</span>
00416 
00417     <span class="comment">/* Initialize the trees. */</span>
00418     <span class="keywordflow">for</span> (n = 0; n &lt; L_CODES;  n++) s-&gt;dyn_ltree[n].Freq = 0;
00419     <span class="keywordflow">for</span> (n = 0; n &lt; D_CODES;  n++) s-&gt;dyn_dtree[n].Freq = 0;
00420     <span class="keywordflow">for</span> (n = 0; n &lt; BL_CODES; n++) s-&gt;bl_tree[n].Freq = 0;
00421 
00422     s-&gt;dyn_ltree[END_BLOCK].Freq = 1;
00423     s-&gt;opt_len = s-&gt;static_len = 0L;
00424     s-&gt;last_lit = s-&gt;matches = 0;
00425 }
00426 
00427 <span class="preprocessor">#define SMALLEST 1</span>
00428 <span class="preprocessor"></span><span class="comment">/* Index within the heap array of least frequent node in the Huffman tree */</span>
00429 
00430 
00431 <span class="comment">/* ===========================================================================</span>
00432 <span class="comment"> * Remove the smallest element from the heap and recreate the heap with</span>
00433 <span class="comment"> * one less element. Updates heap and heap_len.</span>
00434 <span class="comment"> */</span>
00435 <span class="preprocessor">#define pqremove(s, tree, top) \</span>
00436 <span class="preprocessor">{\</span>
00437 <span class="preprocessor">    top = s-&gt;heap[SMALLEST]; \</span>
00438 <span class="preprocessor">    s-&gt;heap[SMALLEST] = s-&gt;heap[s-&gt;heap_len--]; \</span>
00439 <span class="preprocessor">    pqdownheap(s, tree, SMALLEST); \</span>
00440 <span class="preprocessor">}</span>
00441 <span class="preprocessor"></span>
00442 <span class="comment">/* ===========================================================================</span>
00443 <span class="comment"> * Compares to subtrees, using the tree depth as tie breaker when</span>
00444 <span class="comment"> * the subtrees have equal frequency. This minimizes the worst case length.</span>
00445 <span class="comment"> */</span>
00446 <span class="preprocessor">#define smaller(tree, n, m, depth) \</span>
00447 <span class="preprocessor">   (tree[n].Freq &lt; tree[m].Freq || \</span>
00448 <span class="preprocessor">   (tree[n].Freq == tree[m].Freq &amp;&amp; depth[n] &lt;= depth[m]))</span>
00449 <span class="preprocessor"></span>
00450 <span class="comment">/* ===========================================================================</span>
00451 <span class="comment"> * Restore the heap property by moving down the tree starting at node k,</span>
00452 <span class="comment"> * exchanging a node with the smallest of its two sons if necessary, stopping</span>
00453 <span class="comment"> * when the heap property is re-established (each father smaller than its</span>
00454 <span class="comment"> * two sons).</span>
00455 <span class="comment"> */</span>
00456 local <span class="keywordtype">void</span> pqdownheap(s, tree, k)
00457     deflate_state *s;
00458     ct_data *tree;  <span class="comment">/* the tree to restore */</span>
00459     <span class="keywordtype">int</span> k;               <span class="comment">/* node to move down */</span>
00460 {
00461     <span class="keywordtype">int</span> v = s-&gt;heap[k];
00462     <span class="keywordtype">int</span> j = k &lt;&lt; 1;  <span class="comment">/* left son of k */</span>
00463     <span class="keywordflow">while</span> (j &lt;= s-&gt;heap_len) {
00464         <span class="comment">/* Set j to the smallest of the two sons: */</span>
00465         <span class="keywordflow">if</span> (j &lt; s-&gt;heap_len &amp;&amp;
00466             smaller(tree, s-&gt;heap[j+1], s-&gt;heap[j], s-&gt;depth)) {
00467             j++;
00468         }
00469         <span class="comment">/* Exit if v is smaller than both sons */</span>
00470         <span class="keywordflow">if</span> (smaller(tree, v, s-&gt;heap[j], s-&gt;depth)) <span class="keywordflow">break</span>;
00471 
00472         <span class="comment">/* Exchange v with the smallest son */</span>
00473         s-&gt;heap[k] = s-&gt;heap[j];  k = j;
00474 
00475         <span class="comment">/* And continue down the tree, setting j to the left son of k */</span>
00476         j &lt;&lt;= 1;
00477     }
00478     s-&gt;heap[k] = v;
00479 }
00480 
00481 <span class="comment">/* ===========================================================================</span>
00482 <span class="comment"> * Compute the optimal bit lengths for a tree and update the total bit length</span>
00483 <span class="comment"> * for the current block.</span>
00484 <span class="comment"> * IN assertion: the fields freq and dad are set, heap[heap_max] and</span>
00485 <span class="comment"> *    above are the tree nodes sorted by increasing frequency.</span>
00486 <span class="comment"> * OUT assertions: the field len is set to the optimal bit length, the</span>
00487 <span class="comment"> *     array bl_count contains the frequencies for each bit length.</span>
00488 <span class="comment"> *     The length opt_len is updated; static_len is also updated if stree is</span>
00489 <span class="comment"> *     not null.</span>
00490 <span class="comment"> */</span>
00491 local <span class="keywordtype">void</span> gen_bitlen(s, desc)
00492     deflate_state *s;
00493     tree_desc *desc;    <span class="comment">/* the tree descriptor */</span>
00494 {
00495     ct_data *tree        = desc-&gt;dyn_tree;
00496     <span class="keywordtype">int</span> max_code         = desc-&gt;max_code;
00497     <span class="keyword">const</span> ct_data *stree = desc-&gt;stat_desc-&gt;static_tree;
00498     <span class="keyword">const</span> intf *extra    = desc-&gt;stat_desc-&gt;extra_bits;
00499     <span class="keywordtype">int</span> base             = desc-&gt;stat_desc-&gt;extra_base;
00500     <span class="keywordtype">int</span> max_length       = desc-&gt;stat_desc-&gt;max_length;
00501     <span class="keywordtype">int</span> h;              <span class="comment">/* heap index */</span>
00502     <span class="keywordtype">int</span> n, m;           <span class="comment">/* iterate over the tree elements */</span>
00503     <span class="keywordtype">int</span> bits;           <span class="comment">/* bit length */</span>
00504     <span class="keywordtype">int</span> xbits;          <span class="comment">/* extra bits */</span>
00505     ush f;              <span class="comment">/* frequency */</span>
00506     <span class="keywordtype">int</span> overflow = 0;   <span class="comment">/* number of elements with bit length too large */</span>
00507 
00508     <span class="keywordflow">for</span> (bits = 0; bits &lt;= MAX_BITS; bits++) s-&gt;bl_count[bits] = 0;
00509 
00510     <span class="comment">/* In a first pass, compute the optimal bit lengths (which may</span>
00511 <span class="comment">     * overflow in the case of the bit length tree).</span>
00512 <span class="comment">     */</span>
00513     tree[s-&gt;heap[s-&gt;heap_max]].Len = 0; <span class="comment">/* root of the heap */</span>
00514 
00515     <span class="keywordflow">for</span> (h = s-&gt;heap_max+1; h &lt; HEAP_SIZE; h++) {
00516         n = s-&gt;heap[h];
00517         bits = tree[tree[n].Dad].Len + 1;
00518         <span class="keywordflow">if</span> (bits &gt; max_length) bits = max_length, overflow++;
00519         tree[n].Len = (ush)bits;
00520         <span class="comment">/* We overwrite tree[n].Dad which is no longer needed */</span>
00521 
00522         <span class="keywordflow">if</span> (n &gt; max_code) <span class="keywordflow">continue</span>; <span class="comment">/* not a leaf node */</span>
00523 
00524         s-&gt;bl_count[bits]++;
00525         xbits = 0;
00526         <span class="keywordflow">if</span> (n &gt;= base) xbits = extra[n-base];
00527         f = tree[n].Freq;
00528         s-&gt;opt_len += (ulg)f * (bits + xbits);
00529         <span class="keywordflow">if</span> (stree) s-&gt;static_len += (ulg)f * (stree[n].Len + xbits);
00530     }
00531     <span class="keywordflow">if</span> (overflow == 0) <span class="keywordflow">return</span>;
00532 
00533     Trace((stderr,<span class="stringliteral">"\nbit length overflow\n"</span>));
00534     <span class="comment">/* This happens for example on obj2 and pic of the Calgary corpus */</span>
00535 
00536     <span class="comment">/* Find the first bit length which could increase: */</span>
00537     <span class="keywordflow">do</span> {
00538         bits = max_length-1;
00539         <span class="keywordflow">while</span> (s-&gt;bl_count[bits] == 0) bits--;
00540         s-&gt;bl_count[bits]--;      <span class="comment">/* move one leaf down the tree */</span>
00541         s-&gt;bl_count[bits+1] += 2; <span class="comment">/* move one overflow item as its brother */</span>
00542         s-&gt;bl_count[max_length]--;
00543         <span class="comment">/* The brother of the overflow item also moves one step up,</span>
00544 <span class="comment">         * but this does not affect bl_count[max_length]</span>
00545 <span class="comment">         */</span>
00546         overflow -= 2;
00547     } <span class="keywordflow">while</span> (overflow &gt; 0);
00548 
00549     <span class="comment">/* Now recompute all bit lengths, scanning in increasing frequency.</span>
00550 <span class="comment">     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all</span>
00551 <span class="comment">     * lengths instead of fixing only the wrong ones. This idea is taken</span>
00552 <span class="comment">     * from 'ar' written by Haruhiko Okumura.)</span>
00553 <span class="comment">     */</span>
00554     <span class="keywordflow">for</span> (bits = max_length; bits != 0; bits--) {
00555         n = s-&gt;bl_count[bits];
00556         <span class="keywordflow">while</span> (n != 0) {
00557             m = s-&gt;heap[--h];
00558             <span class="keywordflow">if</span> (m &gt; max_code) <span class="keywordflow">continue</span>;
00559             <span class="keywordflow">if</span> (tree[m].Len != (unsigned) bits) {
00560                 Trace((stderr,<span class="stringliteral">"code %d bits %d-&gt;%d\n"</span>, m, tree[m].Len, bits));
00561                 s-&gt;opt_len += ((long)bits - (long)tree[m].Len)
00562                               *(long)tree[m].Freq;
00563                 tree[m].Len = (ush)bits;
00564             }
00565             n--;
00566         }
00567     }
00568 }
00569 
00570 <span class="comment">/* ===========================================================================</span>
00571 <span class="comment"> * Generate the codes for a given tree and bit counts (which need not be</span>
00572 <span class="comment"> * optimal).</span>
00573 <span class="comment"> * IN assertion: the array bl_count contains the bit length statistics for</span>
00574 <span class="comment"> * the given tree and the field len is set for all tree elements.</span>
00575 <span class="comment"> * OUT assertion: the field code is set for all tree elements of non</span>
00576 <span class="comment"> *     zero code length.</span>
00577 <span class="comment"> */</span>
00578 local <span class="keywordtype">void</span> gen_codes (tree, max_code, bl_count)
00579     ct_data *tree;             <span class="comment">/* the tree to decorate */</span>
00580     <span class="keywordtype">int</span> max_code;              <span class="comment">/* largest code with non zero frequency */</span>
00581     ushf *bl_count;            <span class="comment">/* number of codes at each bit length */</span>
00582 {
00583     ush next_code[MAX_BITS+1]; <span class="comment">/* next code value for each bit length */</span>
00584     ush code = 0;              <span class="comment">/* running code value */</span>
00585     <span class="keywordtype">int</span> bits;                  <span class="comment">/* bit index */</span>
00586     <span class="keywordtype">int</span> n;                     <span class="comment">/* code index */</span>
00587 
00588     <span class="comment">/* The distribution counts are first used to generate the code values</span>
00589 <span class="comment">     * without bit reversal.</span>
00590 <span class="comment">     */</span>
00591     <span class="keywordflow">for</span> (bits = 1; bits &lt;= MAX_BITS; bits++) {
00592         next_code[bits] = code = (code + bl_count[bits-1]) &lt;&lt; 1;
00593     }
00594     <span class="comment">/* Check that the bit counts in bl_count are consistent. The last code</span>
00595 <span class="comment">     * must be all ones.</span>
00596 <span class="comment">     */</span>
00597     Assert (code + bl_count[MAX_BITS]-1 == (1&lt;&lt;MAX_BITS)-1,
00598             <span class="stringliteral">"inconsistent bit counts"</span>);
00599     Tracev((stderr,<span class="stringliteral">"\ngen_codes: max_code %d "</span>, max_code));
00600 
00601     <span class="keywordflow">for</span> (n = 0;  n &lt;= max_code; n++) {
00602         <span class="keywordtype">int</span> len = tree[n].Len;
00603         <span class="keywordflow">if</span> (len == 0) <span class="keywordflow">continue</span>;
00604         <span class="comment">/* Now reverse the bits */</span>
00605         tree[n].Code = bi_reverse(next_code[len]++, len);
00606 
00607         Tracecv(tree != static_ltree, (stderr,<span class="stringliteral">"\nn %3d %c l %2d c %4x (%x) "</span>,
00608              n, (isgraph(n) ? n : <span class="charliteral">' '</span>), len, tree[n].Code, next_code[len]-1));
00609     }
00610 }
00611 
00612 <span class="comment">/* ===========================================================================</span>
00613 <span class="comment"> * Construct one Huffman tree and assigns the code bit strings and lengths.</span>
00614 <span class="comment"> * Update the total bit length for the current block.</span>
00615 <span class="comment"> * IN assertion: the field freq is set for all tree elements.</span>
00616 <span class="comment"> * OUT assertions: the fields len and code are set to the optimal bit length</span>
00617 <span class="comment"> *     and corresponding code. The length opt_len is updated; static_len is</span>
00618 <span class="comment"> *     also updated if stree is not null. The field max_code is set.</span>
00619 <span class="comment"> */</span>
00620 local <span class="keywordtype">void</span> build_tree(s, desc)
00621     deflate_state *s;
00622     tree_desc *desc; <span class="comment">/* the tree descriptor */</span>
00623 {
00624     ct_data *tree         = desc-&gt;dyn_tree;
00625     <span class="keyword">const</span> ct_data *stree  = desc-&gt;stat_desc-&gt;static_tree;
00626     <span class="keywordtype">int</span> elems             = desc-&gt;stat_desc-&gt;elems;
00627     <span class="keywordtype">int</span> n, m;          <span class="comment">/* iterate over heap elements */</span>
00628     <span class="keywordtype">int</span> max_code = -1; <span class="comment">/* largest code with non zero frequency */</span>
00629     <span class="keywordtype">int</span> node;          <span class="comment">/* new node being created */</span>
00630 
00631     <span class="comment">/* Construct the initial heap, with least frequent element in</span>
00632 <span class="comment">     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].</span>
00633 <span class="comment">     * heap[0] is not used.</span>
00634 <span class="comment">     */</span>
00635     s-&gt;heap_len = 0, s-&gt;heap_max = HEAP_SIZE;
00636 
00637     <span class="keywordflow">for</span> (n = 0; n &lt; elems; n++) {
00638         <span class="keywordflow">if</span> (tree[n].Freq != 0) {
00639             s-&gt;heap[++(s-&gt;heap_len)] = max_code = n;
00640             s-&gt;depth[n] = 0;
00641         } <span class="keywordflow">else</span> {
00642             tree[n].Len = 0;
00643         }
00644     }
00645 
00646     <span class="comment">/* The pkzip format requires that at least one distance code exists,</span>
00647 <span class="comment">     * and that at least one bit should be sent even if there is only one</span>
00648 <span class="comment">     * possible code. So to avoid special checks later on we force at least</span>
00649 <span class="comment">     * two codes of non zero frequency.</span>
00650 <span class="comment">     */</span>
00651     <span class="keywordflow">while</span> (s-&gt;heap_len &lt; 2) {
00652         node = s-&gt;heap[++(s-&gt;heap_len)] = (max_code &lt; 2 ? ++max_code : 0);
00653         tree[node].Freq = 1;
00654         s-&gt;depth[node] = 0;
00655         s-&gt;opt_len--; <span class="keywordflow">if</span> (stree) s-&gt;static_len -= stree[node].Len;
00656         <span class="comment">/* node is 0 or 1 so it does not have extra bits */</span>
00657     }
00658     desc-&gt;max_code = max_code;
00659 
00660     <span class="comment">/* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,</span>
00661 <span class="comment">     * establish sub-heaps of increasing lengths:</span>
00662 <span class="comment">     */</span>
00663     <span class="keywordflow">for</span> (n = s-&gt;heap_len/2; n &gt;= 1; n--) pqdownheap(s, tree, n);
00664 
00665     <span class="comment">/* Construct the Huffman tree by repeatedly combining the least two</span>
00666 <span class="comment">     * frequent nodes.</span>
00667 <span class="comment">     */</span>
00668     node = elems;              <span class="comment">/* next internal node of the tree */</span>
00669     <span class="keywordflow">do</span> {
00670         pqremove(s, tree, n);  <span class="comment">/* n = node of least frequency */</span>
00671         m = s-&gt;heap[SMALLEST]; <span class="comment">/* m = node of next least frequency */</span>
00672 
00673         s-&gt;heap[--(s-&gt;heap_max)] = n; <span class="comment">/* keep the nodes sorted by frequency */</span>
00674         s-&gt;heap[--(s-&gt;heap_max)] = m;
00675 
00676         <span class="comment">/* Create a new node father of n and m */</span>
00677         tree[node].Freq = tree[n].Freq + tree[m].Freq;
00678         s-&gt;depth[node] = (uch) (MAX(s-&gt;depth[n], s-&gt;depth[m]) + 1);
00679         tree[n].Dad = tree[m].Dad = (ush)node;
00680 <span class="preprocessor">#ifdef DUMP_BL_TREE</span>
00681 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (tree == s-&gt;bl_tree) {
00682             fprintf(stderr,<span class="stringliteral">"\nnode %d(%d), sons %d(%d) %d(%d)"</span>,
00683                     node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
00684         }
00685 <span class="preprocessor">#endif</span>
00686 <span class="preprocessor"></span>        <span class="comment">/* and insert the new node in the heap */</span>
00687         s-&gt;heap[SMALLEST] = node++;
00688         pqdownheap(s, tree, SMALLEST);
00689 
00690     } <span class="keywordflow">while</span> (s-&gt;heap_len &gt;= 2);
00691 
00692     s-&gt;heap[--(s-&gt;heap_max)] = s-&gt;heap[SMALLEST];
00693 
00694     <span class="comment">/* At this point, the fields freq and dad are set. We can now</span>
00695 <span class="comment">     * generate the bit lengths.</span>
00696 <span class="comment">     */</span>
00697     gen_bitlen(s, (tree_desc *)desc);
00698 
00699     <span class="comment">/* The field len is now set, we can generate the bit codes */</span>
00700     gen_codes ((ct_data *)tree, max_code, s-&gt;bl_count);
00701 }
00702 
00703 <span class="comment">/* ===========================================================================</span>
00704 <span class="comment"> * Scan a literal or distance tree to determine the frequencies of the codes</span>
00705 <span class="comment"> * in the bit length tree.</span>
00706 <span class="comment"> */</span>
00707 local <span class="keywordtype">void</span> scan_tree (s, tree, max_code)
00708     deflate_state *s;
00709     ct_data *tree;   <span class="comment">/* the tree to be scanned */</span>
00710     <span class="keywordtype">int</span> max_code;    <span class="comment">/* and its largest code of non zero frequency */</span>
00711 {
00712     <span class="keywordtype">int</span> n;                     <span class="comment">/* iterates over all tree elements */</span>
00713     <span class="keywordtype">int</span> prevlen = -1;          <span class="comment">/* last emitted length */</span>
00714     <span class="keywordtype">int</span> curlen;                <span class="comment">/* length of current code */</span>
00715     <span class="keywordtype">int</span> nextlen = tree[0].Len; <span class="comment">/* length of next code */</span>
00716     <span class="keywordtype">int</span> count = 0;             <span class="comment">/* repeat count of the current code */</span>
00717     <span class="keywordtype">int</span> max_count = 7;         <span class="comment">/* max repeat count */</span>
00718     <span class="keywordtype">int</span> min_count = 4;         <span class="comment">/* min repeat count */</span>
00719 
00720     <span class="keywordflow">if</span> (nextlen == 0) max_count = 138, min_count = 3;
00721     tree[max_code+1].Len = (ush)0xffff; <span class="comment">/* guard */</span>
00722 
00723     <span class="keywordflow">for</span> (n = 0; n &lt;= max_code; n++) {
00724         curlen = nextlen; nextlen = tree[n+1].Len;
00725         <span class="keywordflow">if</span> (++count &lt; max_count &amp;&amp; curlen == nextlen) {
00726             <span class="keywordflow">continue</span>;
00727         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count &lt; min_count) {
00728             s-&gt;bl_tree[curlen].Freq += count;
00729         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (curlen != 0) {
00730             <span class="keywordflow">if</span> (curlen != prevlen) s-&gt;bl_tree[curlen].Freq++;
00731             s-&gt;bl_tree[REP_3_6].Freq++;
00732         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count &lt;= 10) {
00733             s-&gt;bl_tree[REPZ_3_10].Freq++;
00734         } <span class="keywordflow">else</span> {
00735             s-&gt;bl_tree[REPZ_11_138].Freq++;
00736         }
00737         count = 0; prevlen = curlen;
00738         <span class="keywordflow">if</span> (nextlen == 0) {
00739             max_count = 138, min_count = 3;
00740         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (curlen == nextlen) {
00741             max_count = 6, min_count = 3;
00742         } <span class="keywordflow">else</span> {
00743             max_count = 7, min_count = 4;
00744         }
00745     }
00746 }
00747 
00748 <span class="comment">/* ===========================================================================</span>
00749 <span class="comment"> * Send a literal or distance tree in compressed form, using the codes in</span>
00750 <span class="comment"> * bl_tree.</span>
00751 <span class="comment"> */</span>
00752 local <span class="keywordtype">void</span> send_tree (s, tree, max_code)
00753     deflate_state *s;
00754     ct_data *tree; <span class="comment">/* the tree to be scanned */</span>
00755     <span class="keywordtype">int</span> max_code;       <span class="comment">/* and its largest code of non zero frequency */</span>
00756 {
00757     <span class="keywordtype">int</span> n;                     <span class="comment">/* iterates over all tree elements */</span>
00758     <span class="keywordtype">int</span> prevlen = -1;          <span class="comment">/* last emitted length */</span>
00759     <span class="keywordtype">int</span> curlen;                <span class="comment">/* length of current code */</span>
00760     <span class="keywordtype">int</span> nextlen = tree[0].Len; <span class="comment">/* length of next code */</span>
00761     <span class="keywordtype">int</span> count = 0;             <span class="comment">/* repeat count of the current code */</span>
00762     <span class="keywordtype">int</span> max_count = 7;         <span class="comment">/* max repeat count */</span>
00763     <span class="keywordtype">int</span> min_count = 4;         <span class="comment">/* min repeat count */</span>
00764 
00765     <span class="comment">/* tree[max_code+1].Len = -1; */</span>  <span class="comment">/* guard already set */</span>
00766     <span class="keywordflow">if</span> (nextlen == 0) max_count = 138, min_count = 3;
00767 
00768     <span class="keywordflow">for</span> (n = 0; n &lt;= max_code; n++) {
00769         curlen = nextlen; nextlen = tree[n+1].Len;
00770         <span class="keywordflow">if</span> (++count &lt; max_count &amp;&amp; curlen == nextlen) {
00771             <span class="keywordflow">continue</span>;
00772         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count &lt; min_count) {
00773             <span class="keywordflow">do</span> { send_code(s, curlen, s-&gt;bl_tree); } <span class="keywordflow">while</span> (--count != 0);
00774 
00775         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (curlen != 0) {
00776             <span class="keywordflow">if</span> (curlen != prevlen) {
00777                 send_code(s, curlen, s-&gt;bl_tree); count--;
00778             }
00779             Assert(count &gt;= 3 &amp;&amp; count &lt;= 6, <span class="stringliteral">" 3_6?"</span>);
00780             send_code(s, REP_3_6, s-&gt;bl_tree); send_bits(s, count-3, 2);
00781 
00782         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (count &lt;= 10) {
00783             send_code(s, REPZ_3_10, s-&gt;bl_tree); send_bits(s, count-3, 3);
00784 
00785         } <span class="keywordflow">else</span> {
00786             send_code(s, REPZ_11_138, s-&gt;bl_tree); send_bits(s, count-11, 7);
00787         }
00788         count = 0; prevlen = curlen;
00789         <span class="keywordflow">if</span> (nextlen == 0) {
00790             max_count = 138, min_count = 3;
00791         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (curlen == nextlen) {
00792             max_count = 6, min_count = 3;
00793         } <span class="keywordflow">else</span> {
00794             max_count = 7, min_count = 4;
00795         }
00796     }
00797 }
00798 
00799 <span class="comment">/* ===========================================================================</span>
00800 <span class="comment"> * Construct the Huffman tree for the bit lengths and return the index in</span>
00801 <span class="comment"> * bl_order of the last bit length code to send.</span>
00802 <span class="comment"> */</span>
00803 local <span class="keywordtype">int</span> build_bl_tree(s)
00804     deflate_state *s;
00805 {
00806     <span class="keywordtype">int</span> max_blindex;  <span class="comment">/* index of last bit length code of non zero freq */</span>
00807 
00808     <span class="comment">/* Determine the bit length frequencies for literal and distance trees */</span>
00809     scan_tree(s, (ct_data *)s-&gt;dyn_ltree, s-&gt;l_desc.max_code);
00810     scan_tree(s, (ct_data *)s-&gt;dyn_dtree, s-&gt;d_desc.max_code);
00811 
00812     <span class="comment">/* Build the bit length tree: */</span>
00813     build_tree(s, (tree_desc *)(&amp;(s-&gt;bl_desc)));
00814     <span class="comment">/* opt_len now includes the length of the tree representations, except</span>
00815 <span class="comment">     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.</span>
00816 <span class="comment">     */</span>
00817 
00818     <span class="comment">/* Determine the number of bit length codes to send. The pkzip format</span>
00819 <span class="comment">     * requires that at least 4 bit length codes be sent. (appnote.txt says</span>
00820 <span class="comment">     * 3 but the actual value used is 4.)</span>
00821 <span class="comment">     */</span>
00822     <span class="keywordflow">for</span> (max_blindex = BL_CODES-1; max_blindex &gt;= 3; max_blindex--) {
00823         <span class="keywordflow">if</span> (s-&gt;bl_tree[bl_order[max_blindex]].Len != 0) <span class="keywordflow">break</span>;
00824     }
00825     <span class="comment">/* Update opt_len to include the bit length tree and counts */</span>
00826     s-&gt;opt_len += 3*(max_blindex+1) + 5+5+4;
00827     Tracev((stderr, <span class="stringliteral">"\ndyn trees: dyn %ld, stat %ld"</span>,
00828             s-&gt;opt_len, s-&gt;static_len));
00829 
00830     <span class="keywordflow">return</span> max_blindex;
00831 }
00832 
00833 <span class="comment">/* ===========================================================================</span>
00834 <span class="comment"> * Send the header for a block using dynamic Huffman trees: the counts, the</span>
00835 <span class="comment"> * lengths of the bit length codes, the literal tree and the distance tree.</span>
00836 <span class="comment"> * IN assertion: lcodes &gt;= 257, dcodes &gt;= 1, blcodes &gt;= 4.</span>
00837 <span class="comment"> */</span>
00838 local <span class="keywordtype">void</span> send_all_trees(s, lcodes, dcodes, blcodes)
00839     deflate_state *s;
00840     <span class="keywordtype">int</span> lcodes, dcodes, blcodes; <span class="comment">/* number of codes for each tree */</span>
00841 {
00842     <span class="keywordtype">int</span> rank;                    <span class="comment">/* index in bl_order */</span>
00843 
00844     Assert (lcodes &gt;= 257 &amp;&amp; dcodes &gt;= 1 &amp;&amp; blcodes &gt;= 4, <span class="stringliteral">"not enough codes"</span>);
00845     Assert (lcodes &lt;= L_CODES &amp;&amp; dcodes &lt;= D_CODES &amp;&amp; blcodes &lt;= BL_CODES,
00846             <span class="stringliteral">"too many codes"</span>);
00847     Tracev((stderr, <span class="stringliteral">"\nbl counts: "</span>));
00848     send_bits(s, lcodes-257, 5); <span class="comment">/* not +255 as stated in appnote.txt */</span>
00849     send_bits(s, dcodes-1,   5);
00850     send_bits(s, blcodes-4,  4); <span class="comment">/* not -3 as stated in appnote.txt */</span>
00851     <span class="keywordflow">for</span> (rank = 0; rank &lt; blcodes; rank++) {
00852         Tracev((stderr, <span class="stringliteral">"\nbl code %2d "</span>, bl_order[rank]));
00853         send_bits(s, s-&gt;bl_tree[bl_order[rank]].Len, 3);
00854     }
00855     Tracev((stderr, <span class="stringliteral">"\nbl tree: sent %ld"</span>, s-&gt;bits_sent));
00856 
00857     send_tree(s, (ct_data *)s-&gt;dyn_ltree, lcodes-1); <span class="comment">/* literal tree */</span>
00858     Tracev((stderr, <span class="stringliteral">"\nlit tree: sent %ld"</span>, s-&gt;bits_sent));
00859 
00860     send_tree(s, (ct_data *)s-&gt;dyn_dtree, dcodes-1); <span class="comment">/* distance tree */</span>
00861     Tracev((stderr, <span class="stringliteral">"\ndist tree: sent %ld"</span>, s-&gt;bits_sent));
00862 }
00863 
00864 <span class="comment">/* ===========================================================================</span>
00865 <span class="comment"> * Send a stored block</span>
00866 <span class="comment"> */</span>
00867 <span class="keywordtype">void</span> _tr_stored_block(s, buf, stored_len, eof)
00868     deflate_state *s;
00869     charf *buf;       <span class="comment">/* input block */</span>
00870     ulg stored_len;   <span class="comment">/* length of input block */</span>
00871     <span class="keywordtype">int</span> eof;          <span class="comment">/* true if this is the last block for a file */</span>
00872 {
00873     send_bits(s, (STORED_BLOCK&lt;&lt;1)+eof, 3);  <span class="comment">/* send block type */</span>
00874 <span class="preprocessor">#ifdef DEBUG</span>
00875 <span class="preprocessor"></span>    s-&gt;compressed_len = (s-&gt;compressed_len + 3 + 7) &amp; (ulg)~7L;
00876     s-&gt;compressed_len += (stored_len + 4) &lt;&lt; 3;
00877 <span class="preprocessor">#endif</span>
00878 <span class="preprocessor"></span>    copy_block(s, buf, (<span class="keywordtype">unsigned</span>)stored_len, 1); <span class="comment">/* with header */</span>
00879 }
00880 
00881 <span class="comment">/* ===========================================================================</span>
00882 <span class="comment"> * Send one empty static block to give enough lookahead for inflate.</span>
00883 <span class="comment"> * This takes 10 bits, of which 7 may remain in the bit buffer.</span>
00884 <span class="comment"> * The current inflate code requires 9 bits of lookahead. If the</span>
00885 <span class="comment"> * last two codes for the previous block (real code plus EOB) were coded</span>
00886 <span class="comment"> * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode</span>
00887 <span class="comment"> * the last real code. In this case we send two empty static blocks instead</span>
00888 <span class="comment"> * of one. (There are no problems if the previous block is stored or fixed.)</span>
00889 <span class="comment"> * To simplify the code, we assume the worst case of last real code encoded</span>
00890 <span class="comment"> * on one bit only.</span>
00891 <span class="comment"> */</span>
00892 <span class="keywordtype">void</span> _tr_align(s)
00893     deflate_state *s;
00894 {
00895     send_bits(s, STATIC_TREES&lt;&lt;1, 3);
00896     send_code(s, END_BLOCK, static_ltree);
00897 <span class="preprocessor">#ifdef DEBUG</span>
00898 <span class="preprocessor"></span>    s-&gt;compressed_len += 10L; <span class="comment">/* 3 for block type, 7 for EOB */</span>
00899 <span class="preprocessor">#endif</span>
00900 <span class="preprocessor"></span>    bi_flush(s);
00901     <span class="comment">/* Of the 10 bits for the empty block, we have already sent</span>
00902 <span class="comment">     * (10 - bi_valid) bits. The lookahead for the last real code (before</span>
00903 <span class="comment">     * the EOB of the previous block) was thus at least one plus the length</span>
00904 <span class="comment">     * of the EOB plus what we have just sent of the empty static block.</span>
00905 <span class="comment">     */</span>
00906     <span class="keywordflow">if</span> (1 + s-&gt;last_eob_len + 10 - s-&gt;bi_valid &lt; 9) {
00907         send_bits(s, STATIC_TREES&lt;&lt;1, 3);
00908         send_code(s, END_BLOCK, static_ltree);
00909 <span class="preprocessor">#ifdef DEBUG</span>
00910 <span class="preprocessor"></span>        s-&gt;compressed_len += 10L;
00911 <span class="preprocessor">#endif</span>
00912 <span class="preprocessor"></span>        bi_flush(s);
00913     }
00914     s-&gt;last_eob_len = 7;
00915 }
00916 
00917 <span class="comment">/* ===========================================================================</span>
00918 <span class="comment"> * Determine the best encoding for the current block: dynamic trees, static</span>
00919 <span class="comment"> * trees or store, and output the encoded block to the zip file.</span>
00920 <span class="comment"> */</span>
00921 <span class="keywordtype">void</span> _tr_flush_block(s, buf, stored_len, eof)
00922     deflate_state *s;
00923     charf *buf;       <span class="comment">/* input block, or NULL if too old */</span>
00924     ulg stored_len;   <span class="comment">/* length of input block */</span>
00925     <span class="keywordtype">int</span> eof;          <span class="comment">/* true if this is the last block for a file */</span>
00926 {
00927     ulg opt_lenb, static_lenb; <span class="comment">/* opt_len and static_len in bytes */</span>
00928     <span class="keywordtype">int</span> max_blindex = 0;  <span class="comment">/* index of last bit length code of non zero freq */</span>
00929 
00930     <span class="comment">/* Build the Huffman trees unless a stored block is forced */</span>
00931     <span class="keywordflow">if</span> (s-&gt;level &gt; 0) {
00932 
00933      <span class="comment">/* Check if the file is ascii or binary */</span>
00934     <span class="keywordflow">if</span> (s-&gt;data_type == Z_UNKNOWN) set_data_type(s);
00935 
00936     <span class="comment">/* Construct the literal and distance trees */</span>
00937     build_tree(s, (tree_desc *)(&amp;(s-&gt;l_desc)));
00938     Tracev((stderr, <span class="stringliteral">"\nlit data: dyn %ld, stat %ld"</span>, s-&gt;opt_len,
00939         s-&gt;static_len));
00940 
00941     build_tree(s, (tree_desc *)(&amp;(s-&gt;d_desc)));
00942     Tracev((stderr, <span class="stringliteral">"\ndist data: dyn %ld, stat %ld"</span>, s-&gt;opt_len,
00943         s-&gt;static_len));
00944     <span class="comment">/* At this point, opt_len and static_len are the total bit lengths of</span>
00945 <span class="comment">     * the compressed block data, excluding the tree representations.</span>
00946 <span class="comment">     */</span>
00947 
00948     <span class="comment">/* Build the bit length tree for the above two trees, and get the index</span>
00949 <span class="comment">     * in bl_order of the last bit length code to send.</span>
00950 <span class="comment">     */</span>
00951     max_blindex = build_bl_tree(s);
00952 
00953     <span class="comment">/* Determine the best encoding. Compute first the block length in bytes*/</span>
00954     opt_lenb = (s-&gt;opt_len+3+7)&gt;&gt;3;
00955     static_lenb = (s-&gt;static_len+3+7)&gt;&gt;3;
00956 
00957     Tracev((stderr, <span class="stringliteral">"\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u "</span>,
00958         opt_lenb, s-&gt;opt_len, static_lenb, s-&gt;static_len, stored_len,
00959         s-&gt;last_lit));
00960 
00961     <span class="keywordflow">if</span> (static_lenb &lt;= opt_lenb) opt_lenb = static_lenb;
00962 
00963     } <span class="keywordflow">else</span> {
00964         Assert(buf != (<span class="keywordtype">char</span>*)0, <span class="stringliteral">"lost buf"</span>);
00965     opt_lenb = static_lenb = stored_len + 5; <span class="comment">/* force a stored block */</span>
00966     }
00967 
00968 <span class="preprocessor">#ifdef FORCE_STORED</span>
00969 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (buf != (<span class="keywordtype">char</span>*)0) { <span class="comment">/* force stored block */</span>
00970 <span class="preprocessor">#else</span>
00971 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (stored_len+4 &lt;= opt_lenb &amp;&amp; buf != (<span class="keywordtype">char</span>*)0) {
00972                        <span class="comment">/* 4: two words for the lengths */</span>
00973 <span class="preprocessor">#endif</span>
00974 <span class="preprocessor"></span>        <span class="comment">/* The test buf != NULL is only necessary if LIT_BUFSIZE &gt; WSIZE.</span>
00975 <span class="comment">         * Otherwise we can't have processed more than WSIZE input bytes since</span>
00976 <span class="comment">         * the last block flush, because compression would have been</span>
00977 <span class="comment">         * successful. If LIT_BUFSIZE &lt;= WSIZE, it is never too late to</span>
00978 <span class="comment">         * transform a block into a stored block.</span>
00979 <span class="comment">         */</span>
00980         _tr_stored_block(s, buf, stored_len, eof);
00981 
00982 <span class="preprocessor">#ifdef FORCE_STATIC</span>
00983 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (static_lenb &gt;= 0) { <span class="comment">/* force static trees */</span>
00984 <span class="preprocessor">#else</span>
00985 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (static_lenb == opt_lenb) {
00986 <span class="preprocessor">#endif</span>
00987 <span class="preprocessor"></span>        send_bits(s, (STATIC_TREES&lt;&lt;1)+eof, 3);
00988         compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
00989 <span class="preprocessor">#ifdef DEBUG</span>
00990 <span class="preprocessor"></span>        s-&gt;compressed_len += 3 + s-&gt;static_len;
00991 <span class="preprocessor">#endif</span>
00992 <span class="preprocessor"></span>    } <span class="keywordflow">else</span> {
00993         send_bits(s, (DYN_TREES&lt;&lt;1)+eof, 3);
00994         send_all_trees(s, s-&gt;l_desc.max_code+1, s-&gt;d_desc.max_code+1,
00995                        max_blindex+1);
00996         compress_block(s, (ct_data *)s-&gt;dyn_ltree, (ct_data *)s-&gt;dyn_dtree);
00997 <span class="preprocessor">#ifdef DEBUG</span>
00998 <span class="preprocessor"></span>        s-&gt;compressed_len += 3 + s-&gt;opt_len;
00999 <span class="preprocessor">#endif</span>
01000 <span class="preprocessor"></span>    }
01001     Assert (s-&gt;compressed_len == s-&gt;bits_sent, <span class="stringliteral">"bad compressed size"</span>);
01002     <span class="comment">/* The above check is made mod 2^32, for files larger than 512 MB</span>
01003 <span class="comment">     * and uLong implemented on 32 bits.</span>
01004 <span class="comment">     */</span>
01005     init_block(s);
01006 
01007     <span class="keywordflow">if</span> (eof) {
01008         bi_windup(s);
01009 <span class="preprocessor">#ifdef DEBUG</span>
01010 <span class="preprocessor"></span>        s-&gt;compressed_len += 7;  <span class="comment">/* align on byte boundary */</span>
01011 <span class="preprocessor">#endif</span>
01012 <span class="preprocessor"></span>    }
01013     Tracev((stderr,<span class="stringliteral">"\ncomprlen %lu(%lu) "</span>, s-&gt;compressed_len&gt;&gt;3,
01014            s-&gt;compressed_len-7*eof));
01015 }
01016 
01017 <span class="comment">/* ===========================================================================</span>
01018 <span class="comment"> * Save the match info and tally the frequency counts. Return true if</span>
01019 <span class="comment"> * the current block must be flushed.</span>
01020 <span class="comment"> */</span>
01021 <span class="keywordtype">int</span> _tr_tally (s, dist, lc)
01022     deflate_state *s;
01023     <span class="keywordtype">unsigned</span> dist;  <span class="comment">/* distance of matched string */</span>
01024     <span class="keywordtype">unsigned</span> lc;    <span class="comment">/* match length-MIN_MATCH or unmatched char (if dist==0) */</span>
01025 {
01026     s-&gt;d_buf[s-&gt;last_lit] = (ush)dist;
01027     s-&gt;l_buf[s-&gt;last_lit++] = (uch)lc;
01028     <span class="keywordflow">if</span> (dist == 0) {
01029         <span class="comment">/* lc is the unmatched char */</span>
01030         s-&gt;dyn_ltree[lc].Freq++;
01031     } <span class="keywordflow">else</span> {
01032         s-&gt;matches++;
01033         <span class="comment">/* Here, lc is the match length - MIN_MATCH */</span>
01034         dist--;             <span class="comment">/* dist = match distance - 1 */</span>
01035         Assert((ush)dist &lt; (ush)MAX_DIST(s) &amp;&amp;
01036                (ush)lc &lt;= (ush)(MAX_MATCH-MIN_MATCH) &amp;&amp;
01037                (ush)d_code(dist) &lt; (ush)D_CODES,  <span class="stringliteral">"_tr_tally: bad match"</span>);
01038 
01039         s-&gt;dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
01040         s-&gt;dyn_dtree[d_code(dist)].Freq++;
01041     }
01042 
01043 <span class="preprocessor">#ifdef TRUNCATE_BLOCK</span>
01044 <span class="preprocessor"></span>    <span class="comment">/* Try to guess if it is profitable to stop the current block here */</span>
01045     <span class="keywordflow">if</span> ((s-&gt;last_lit &amp; 0x1fff) == 0 &amp;&amp; s-&gt;level &gt; 2) {
01046         <span class="comment">/* Compute an upper bound for the compressed length */</span>
01047         ulg out_length = (ulg)s-&gt;last_lit*8L;
01048         ulg in_length = (ulg)((long)s-&gt;strstart - s-&gt;block_start);
01049         <span class="keywordtype">int</span> dcode;
01050         <span class="keywordflow">for</span> (dcode = 0; dcode &lt; D_CODES; dcode++) {
01051             out_length += (ulg)s-&gt;dyn_dtree[dcode].Freq *
01052                 (5L+extra_dbits[dcode]);
01053         }
01054         out_length &gt;&gt;= 3;
01055         Tracev((stderr,<span class="stringliteral">"\nlast_lit %u, in %ld, out ~%ld(%ld%%) "</span>,
01056                s-&gt;last_lit, in_length, out_length,
01057                100L - out_length*100L/in_length));
01058         <span class="keywordflow">if</span> (s-&gt;matches &lt; s-&gt;last_lit/2 &amp;&amp; out_length &lt; in_length/2) <span class="keywordflow">return</span> 1;
01059     }
01060 <span class="preprocessor">#endif</span>
01061 <span class="preprocessor"></span>    <span class="keywordflow">return</span> (s-&gt;last_lit == s-&gt;lit_bufsize-1);
01062     <span class="comment">/* We avoid equality with lit_bufsize because of wraparound at 64K</span>
01063 <span class="comment">     * on 16 bit machines and because stored blocks are restricted to</span>
01064 <span class="comment">     * 64K-1 bytes.</span>
01065 <span class="comment">     */</span>
01066 }
01067 
01068 <span class="comment">/* ===========================================================================</span>
01069 <span class="comment"> * Send the block data compressed using the given Huffman trees</span>
01070 <span class="comment"> */</span>
01071 local <span class="keywordtype">void</span> compress_block(s, ltree, dtree)
01072     deflate_state *s;
01073     ct_data *ltree; <span class="comment">/* literal tree */</span>
01074     ct_data *dtree; <span class="comment">/* distance tree */</span>
01075 {
01076     <span class="keywordtype">unsigned</span> dist;      <span class="comment">/* distance of matched string */</span>
01077     <span class="keywordtype">int</span> lc;             <span class="comment">/* match length or unmatched char (if dist == 0) */</span>
01078     <span class="keywordtype">unsigned</span> lx = 0;    <span class="comment">/* running index in l_buf */</span>
01079     <span class="keywordtype">unsigned</span> code;      <span class="comment">/* the code to send */</span>
01080     <span class="keywordtype">int</span> extra;          <span class="comment">/* number of extra bits to send */</span>
01081 
01082     <span class="keywordflow">if</span> (s-&gt;last_lit != 0) <span class="keywordflow">do</span> {
01083         dist = s-&gt;d_buf[lx];
01084         lc = s-&gt;l_buf[lx++];
01085         <span class="keywordflow">if</span> (dist == 0) {
01086             send_code(s, lc, ltree); <span class="comment">/* send a literal byte */</span>
01087             Tracecv(isgraph(lc), (stderr,<span class="stringliteral">" '%c' "</span>, lc));
01088         } <span class="keywordflow">else</span> {
01089             <span class="comment">/* Here, lc is the match length - MIN_MATCH */</span>
01090             code = _length_code[lc];
01091             send_code(s, code+LITERALS+1, ltree); <span class="comment">/* send the length code */</span>
01092             extra = extra_lbits[code];
01093             <span class="keywordflow">if</span> (extra != 0) {
01094                 lc -= base_length[code];
01095                 send_bits(s, lc, extra);       <span class="comment">/* send the extra length bits */</span>
01096             }
01097             dist--; <span class="comment">/* dist is now the match distance - 1 */</span>
01098             code = d_code(dist);
01099             Assert (code &lt; D_CODES, <span class="stringliteral">"bad d_code"</span>);
01100 
01101             send_code(s, code, dtree);       <span class="comment">/* send the distance code */</span>
01102             extra = extra_dbits[code];
01103             <span class="keywordflow">if</span> (extra != 0) {
01104                 dist -= base_dist[code];
01105                 send_bits(s, dist, extra);   <span class="comment">/* send the extra distance bits */</span>
01106             }
01107         } <span class="comment">/* literal or match pair ? */</span>
01108 
01109         <span class="comment">/* Check that the overlay between pending_buf and d_buf+l_buf is ok: */</span>
01110         Assert(s-&gt;pending &lt; s-&gt;lit_bufsize + 2*lx, <span class="stringliteral">"pendingBuf overflow"</span>);
01111 
01112     } <span class="keywordflow">while</span> (lx &lt; s-&gt;last_lit);
01113 
01114     send_code(s, END_BLOCK, ltree);
01115     s-&gt;last_eob_len = ltree[END_BLOCK].Len;
01116 }
01117 
01118 <span class="comment">/* ===========================================================================</span>
01119 <span class="comment"> * Set the data type to ASCII or BINARY, using a crude approximation:</span>
01120 <span class="comment"> * binary if more than 20% of the bytes are &lt;= 6 or &gt;= 128, ascii otherwise.</span>
01121 <span class="comment"> * IN assertion: the fields freq of dyn_ltree are set and the total of all</span>
01122 <span class="comment"> * frequencies does not exceed 64K (to fit in an int on 16 bit machines).</span>
01123 <span class="comment"> */</span>
01124 local <span class="keywordtype">void</span> set_data_type(s)
01125     deflate_state *s;
01126 {
01127     <span class="keywordtype">int</span> n = 0;
01128     <span class="keywordtype">unsigned</span> ascii_freq = 0;
01129     <span class="keywordtype">unsigned</span> bin_freq = 0;
01130     <span class="keywordflow">while</span> (n &lt; 7)        bin_freq += s-&gt;dyn_ltree[n++].Freq;
01131     <span class="keywordflow">while</span> (n &lt; 128)    ascii_freq += s-&gt;dyn_ltree[n++].Freq;
01132     <span class="keywordflow">while</span> (n &lt; LITERALS) bin_freq += s-&gt;dyn_ltree[n++].Freq;
01133     s-&gt;data_type = (Byte)(bin_freq &gt; (ascii_freq &gt;&gt; 2) ? Z_BINARY : Z_ASCII);
01134 }
01135 
01136 <span class="comment">/* ===========================================================================</span>
01137 <span class="comment"> * Reverse the first len bits of a code, using straightforward code (a faster</span>
01138 <span class="comment"> * method would use a table)</span>
01139 <span class="comment"> * IN assertion: 1 &lt;= len &lt;= 15</span>
01140 <span class="comment"> */</span>
01141 local <span class="keywordtype">unsigned</span> bi_reverse(code, len)
01142     <span class="keywordtype">unsigned</span> code; <span class="comment">/* the value to invert */</span>
01143     <span class="keywordtype">int</span> len;       <span class="comment">/* its bit length */</span>
01144 {
01145     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> res = 0;
01146     <span class="keywordflow">do</span> {
01147         res |= code &amp; 1;
01148         code &gt;&gt;= 1, res &lt;&lt;= 1;
01149     } <span class="keywordflow">while</span> (--len &gt; 0);
01150     <span class="keywordflow">return</span> res &gt;&gt; 1;
01151 }
01152 
01153 <span class="comment">/* ===========================================================================</span>
01154 <span class="comment"> * Flush the bit buffer, keeping at most 7 bits in it.</span>
01155 <span class="comment"> */</span>
01156 local <span class="keywordtype">void</span> bi_flush(s)
01157     deflate_state *s;
01158 {
01159     <span class="keywordflow">if</span> (s-&gt;bi_valid == 16) {
01160         put_short(s, s-&gt;bi_buf);
01161         s-&gt;bi_buf = 0;
01162         s-&gt;bi_valid = 0;
01163     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s-&gt;bi_valid &gt;= 8) {
01164         put_byte(s, (Byte)s-&gt;bi_buf);
01165         s-&gt;bi_buf &gt;&gt;= 8;
01166         s-&gt;bi_valid -= 8;
01167     }
01168 }
01169 
01170 <span class="comment">/* ===========================================================================</span>
01171 <span class="comment"> * Flush the bit buffer and align the output on a byte boundary</span>
01172 <span class="comment"> */</span>
01173 local <span class="keywordtype">void</span> bi_windup(s)
01174     deflate_state *s;
01175 {
01176     <span class="keywordflow">if</span> (s-&gt;bi_valid &gt; 8) {
01177         put_short(s, s-&gt;bi_buf);
01178     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s-&gt;bi_valid &gt; 0) {
01179         put_byte(s, (Byte)s-&gt;bi_buf);
01180     }
01181     s-&gt;bi_buf = 0;
01182     s-&gt;bi_valid = 0;
01183 <span class="preprocessor">#ifdef DEBUG</span>
01184 <span class="preprocessor"></span>    s-&gt;bits_sent = (s-&gt;bits_sent+7) &amp; ~7;
01185 <span class="preprocessor">#endif</span>
01186 <span class="preprocessor"></span>}
01187 
01188 <span class="comment">/* ===========================================================================</span>
01189 <span class="comment"> * Copy a stored block, storing first the length and its</span>
01190 <span class="comment"> * one's complement if requested.</span>
01191 <span class="comment"> */</span>
01192 local <span class="keywordtype">void</span> copy_block(s, buf, len, header)
01193     deflate_state *s;
01194     charf    *buf;    <span class="comment">/* the input data */</span>
01195     <span class="keywordtype">unsigned</span> len;     <span class="comment">/* its length */</span>
01196     <span class="keywordtype">int</span>      header;  <span class="comment">/* true if block header must be written */</span>
01197 {
01198     bi_windup(s);        <span class="comment">/* align on byte boundary */</span>
01199     s-&gt;last_eob_len = 8; <span class="comment">/* enough lookahead for inflate */</span>
01200 
01201     <span class="keywordflow">if</span> (header) {
01202         put_short(s, (ush)len);   
01203         put_short(s, (ush)~len);
01204 <span class="preprocessor">#ifdef DEBUG</span>
01205 <span class="preprocessor"></span>        s-&gt;bits_sent += 2*16;
01206 <span class="preprocessor">#endif</span>
01207 <span class="preprocessor"></span>    }
01208 <span class="preprocessor">#ifdef DEBUG</span>
01209 <span class="preprocessor"></span>    s-&gt;bits_sent += (ulg)len&lt;&lt;3;
01210 <span class="preprocessor">#endif</span>
01211 <span class="preprocessor"></span>    <span class="keywordflow">while</span> (len--) {
01212         put_byte(s, *buf++);
01213     }
01214 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:42 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

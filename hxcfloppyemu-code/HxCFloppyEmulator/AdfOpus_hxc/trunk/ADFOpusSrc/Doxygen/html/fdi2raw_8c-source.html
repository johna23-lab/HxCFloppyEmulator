<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>fdi2raw.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>fdi2raw.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"></span>
00003 <span class="comment">  FDI to raw bit stream converter</span>
00004 <span class="comment">  Copyright (c) 2001 by Toni Wilen &lt;twilen@arabuusimiehet.com&gt;</span>
00005 <span class="comment"></span>
00006 <span class="comment">  FDI format created by Vincent "ApH" Joguin</span>
00007 <span class="comment"></span>
00008 <span class="comment">  Tiny changes - function type fixes, multiple drives, addition of</span>
00009 <span class="comment">  get_last_head and C++ callability - by Thomas Harte, 2001,</span>
00010 <span class="comment">  T.Harte@excite.co.uk</span>
00011 <span class="comment"></span>
00012 <span class="comment"></span>
00013 <span class="comment">  This program is free software; you can redistribute it and/or modify it</span>
00014 <span class="comment">  under the terms of the GNU General Public License as published by the Free</span>
00015 <span class="comment">  Software Foundation; either version 2 of the License, or (at your option)</span>
00016 <span class="comment">  any later version.</span>
00017 <span class="comment"></span>
00018 <span class="comment">  This program is distributed in the hope that it will be useful, but WITHOUT</span>
00019 <span class="comment">  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or</span>
00020 <span class="comment">  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for</span>
00021 <span class="comment">  more details.</span>
00022 <span class="comment"></span>
00023 <span class="comment">  You should have received a copy of the GNU General Public License along</span>
00024 <span class="comment">  with this program; if not, write to the Free Software Foundation, Inc.,</span>
00025 <span class="comment">  59 Temple Place - Suite 330, Boston, MA  02111-1307, USA</span>
00026 <span class="comment"></span>
00027 <span class="comment">*/</span>
00028 
00029 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00030 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00031 <span class="preprocessor">#include &lt;string.h&gt;</span>
00032 
00033 <span class="preprocessor">#include "types.h"</span> <span class="comment">/* remove if merged with UAE */</span>
00034 <span class="preprocessor">#include "fdi2raw.h"</span>
00035 
00036 <span class="comment">//#define DEBUG</span>
00037 <span class="comment">//#define VERBOSE</span>
00038 
00039 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00040 
00041 <span class="preprocessor">#ifdef DEBUG</span>
00042 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">char</span> *datalog(uae_u8 *src, <span class="keywordtype">int</span> len)
00043 {
00044     <span class="keyword">static</span> <span class="keywordtype">char</span> buf[1000];
00045     <span class="keyword">static</span> <span class="keywordtype">int</span> offset;
00046     <span class="keywordtype">int</span> i = 0, offset2;
00047 
00048     offset2 = offset;
00049     buf[offset++]=<span class="charliteral">'\''</span>;
00050     <span class="keywordflow">while</span>(len--) {
00051         sprintf (buf + offset, <span class="stringliteral">"%02.2X"</span>, src[i]);
00052         offset += 2;
00053         i++;
00054         <span class="keywordflow">if</span> (i &gt; 10) <span class="keywordflow">break</span>;
00055     }
00056     buf[offset++]=<span class="charliteral">'\''</span>;
00057     buf[offset++] = 0;
00058     <span class="keywordflow">if</span> (offset &gt;= 900) offset = 0;
00059     <span class="keywordflow">return</span> buf + offset2;
00060 }
00061 <span class="preprocessor">#else</span>
00062 <span class="preprocessor"></span><span class="keyword">static</span> <span class="keywordtype">char</span> *datalog(uae_u8 *src, <span class="keywordtype">int</span> len) { <span class="keywordflow">return</span> <span class="stringliteral">""</span>; }
00063 <span class="preprocessor">#endif</span>
00064 <span class="preprocessor"></span>
00065 <span class="preprocessor">#ifdef DEBUG</span>
00066 <span class="preprocessor"></span><span class="preprocessor">#define debuglog printf</span>
00067 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00068 <span class="preprocessor"></span><span class="preprocessor">#define debuglog</span>
00069 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#ifdef VERBOSE</span>
00071 <span class="preprocessor"></span><span class="preprocessor">#define outlog printf</span>
00072 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00073 <span class="preprocessor"></span><span class="preprocessor">#define outlog</span>
00074 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00075 <span class="preprocessor"></span>
00076 <span class="preprocessor">#define MAX_SRC_BUFFER 20000</span>
00077 <span class="preprocessor"></span><span class="preprocessor">#define MAX_DST_BUFFER 40000</span>
00078 <span class="preprocessor"></span><span class="preprocessor">#define MAX_MFM_SYNC_BUFFER 60000</span>
00079 <span class="preprocessor"></span>
00080 <span class="keyword">struct </span>fdi {
00081     uae_u8 *track_src_buffer;
00082     uae_u8 *track_src;
00083     <span class="keywordtype">int</span> track_src_len;
00084     uae_u8 *track_dst_buffer;
00085     uae_u8 *track_dst;
00086     uae_u8 track_len;
00087     uae_u8 track_type;
00088     <span class="keywordtype">int</span> current_track;
00089     <span class="keywordtype">int</span> last_track;
00090     <span class="keywordtype">int</span> last_head;
00091     <span class="keywordtype">int</span> rotation_speed;
00092     <span class="keywordtype">int</span> bit_rate;
00093     <span class="keywordtype">int</span> disk_type;
00094     <span class="keywordtype">int</span> write_protect;
00095     <span class="keywordtype">int</span> err;
00096     uae_u8 header[512];
00097     <span class="keywordtype">int</span> track_offsets[181];
00098     FILE *file;
00099     <span class="keywordtype">int</span> out;
00100     <span class="keywordtype">int</span> mfmsync_offset;
00101     <span class="keywordtype">int</span> *mfmsync_buffer;
00102     <span class="comment">/* sector described only */</span>
00103     <span class="keywordtype">int</span> index_offset;
00104     <span class="keywordtype">int</span> encoding_type;
00105     <span class="comment">/* bit handling */</span>
00106     <span class="keywordtype">int</span> nextdrop;
00107 };
00108 
00109 <span class="preprocessor">#define get_u32(x) ((((x)[0])&lt;&lt;24)|(((x)[1])&lt;&lt;16)|(((x)[2])&lt;&lt;8)|((x)[3]))</span>
00110 <span class="preprocessor"></span>
00111 <span class="keyword">static</span> <span class="keywordtype">int</span> decode_raw_track (FDI *fdi)
00112 {
00113     <span class="keywordtype">int</span> size = get_u32(fdi-&gt;track_src);
00114     memcpy (fdi-&gt;track_dst, fdi-&gt;track_src, (size + 7) &gt;&gt; 3);
00115     fdi-&gt;track_src += (size + 7) &gt;&gt; 3;
00116     <span class="keywordflow">return</span> size;
00117 }
00118 
00119 <span class="comment">/* unknown track */</span>
00120 <span class="keyword">static</span> <span class="keywordtype">void</span> zxx (FDI *fdi)
00121 {
00122     outlog (<span class="stringliteral">"track %d: unknown track type 0x%02.2X\n"</span>, fdi-&gt;current_track, fdi-&gt;track_type);
00123 <span class="comment">//  return -1;</span>
00124 }
00125 <span class="comment">/* unsupported track */</span>
00126 <span class="keyword">static</span> <span class="keywordtype">void</span> zyy (FDI *fdi)
00127 {
00128     outlog (<span class="stringliteral">"track %d: unsupported track type 0x%02.2X\n"</span>, fdi-&gt;current_track, fdi-&gt;track_type);
00129 <span class="comment">//  return -1;</span>
00130 }
00131 <span class="comment">/* empty track */</span>
00132 <span class="keyword">static</span> <span class="keywordtype">void</span> track_empty (FDI *fdi)
00133 {
00134 <span class="comment">//  return 0;</span>
00135 }
00136 
00137 <span class="comment">/* unknown sector described type */</span>
00138 <span class="keyword">static</span> <span class="keywordtype">void</span> dxx (FDI *fdi)
00139 {
00140     outlog (<span class="stringliteral">"\ntrack %d: unknown sector described type 0x%02.2X\n"</span>, fdi-&gt;current_track, fdi-&gt;track_type);
00141     fdi-&gt;err = 1;
00142 }
00143 <span class="comment">/* unsupported sector described type */</span>
00144 <span class="keyword">static</span> <span class="keywordtype">void</span> dyy (FDI *fdi)
00145 {
00146     outlog (<span class="stringliteral">"\ntrack %d: unsupported sector described 0x%02.2X\n"</span>, fdi-&gt;current_track, fdi-&gt;track_type);
00147     fdi-&gt;err = 1;
00148 }
00149 <span class="comment">/* add position of mfm sync bit */</span>
00150 <span class="keyword">static</span> <span class="keywordtype">void</span> add_mfm_sync_bit (FDI *fdi)
00151 {
00152     <span class="keywordflow">if</span> (fdi-&gt;nextdrop) {
00153         fdi-&gt;nextdrop = 0;
00154         <span class="keywordflow">return</span>;
00155     }
00156     fdi-&gt;mfmsync_buffer[fdi-&gt;mfmsync_offset++] = fdi-&gt;out;
00157     <span class="keywordflow">if</span> (fdi-&gt;out == 0) {
00158         outlog (<span class="stringliteral">"illegal position for mfm sync bit, offset=%d\n"</span>,fdi-&gt;out);
00159         fdi-&gt;err = 1;
00160     }
00161     <span class="keywordflow">if</span> (fdi-&gt;mfmsync_offset &gt;= MAX_MFM_SYNC_BUFFER) {
00162         fdi-&gt;mfmsync_offset = 0;
00163         outlog (<span class="stringliteral">"mfmsync buffer overflow\n"</span>);
00164         fdi-&gt;err = 1;
00165     }
00166     fdi-&gt;out++;
00167 }
00168 
00169 <span class="preprocessor">#define BIT_BYTEOFFSET ((fdi-&gt;out) &gt;&gt; 3)</span>
00170 <span class="preprocessor"></span><span class="preprocessor">#define BIT_BITOFFSET (7-((fdi-&gt;out)&amp;7))</span>
00171 <span class="preprocessor"></span>
00172 <span class="comment">/* add one bit */</span>
00173 <span class="keyword">static</span> <span class="keywordtype">void</span> bit_add (FDI *fdi, <span class="keywordtype">int</span> bit)
00174 {
00175     <span class="keywordflow">if</span> (fdi-&gt;nextdrop) {
00176         fdi-&gt;nextdrop = 0;
00177         <span class="keywordflow">return</span>;
00178     }
00179     fdi-&gt;track_dst[BIT_BYTEOFFSET] &amp;= ~(1 &lt;&lt; BIT_BITOFFSET);
00180     <span class="keywordflow">if</span> (bit) 
00181         fdi-&gt;track_dst[BIT_BYTEOFFSET] |= (1 &lt;&lt; BIT_BITOFFSET);
00182     fdi-&gt;out++;
00183     <span class="keywordflow">if</span> (fdi-&gt;out &gt;= MAX_DST_BUFFER * 8) {
00184         outlog (<span class="stringliteral">"destination buffer overflow\n"</span>);
00185         fdi-&gt;err = 1;
00186         fdi-&gt;out = 1;
00187     }
00188 }
00189 <span class="comment">/* add bit and mfm sync bit */</span>
00190 <span class="keyword">static</span> <span class="keywordtype">void</span> bit_mfm_add (FDI *fdi, <span class="keywordtype">int</span> bit)
00191 {
00192     add_mfm_sync_bit (fdi);
00193     bit_add (fdi, bit);
00194 }
00195 <span class="comment">/* remove following bit */</span>
00196 <span class="keyword">static</span> <span class="keywordtype">void</span> bit_drop_next (FDI *fdi)
00197 {
00198     <span class="keywordflow">if</span> (fdi-&gt;nextdrop &gt; 0) {
00199         outlog(<span class="stringliteral">"multiple bit_drop_next() called"</span>);
00200     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fdi-&gt;nextdrop &lt; 0) {
00201         fdi-&gt;nextdrop = 0;
00202         debuglog(<span class="stringliteral">":DNN:"</span>);
00203         <span class="keywordflow">return</span>;
00204     }
00205     debuglog(<span class="stringliteral">":DN:"</span>);
00206     fdi-&gt;nextdrop = 1;
00207 }
00208 
00209 <span class="comment">/* ignore next bit_drop_next() */</span>
00210 <span class="keyword">static</span> <span class="keywordtype">void</span> bit_dedrop (FDI *fdi)
00211 {
00212     <span class="keywordflow">if</span> (fdi-&gt;nextdrop) {
00213         outlog(<span class="stringliteral">"bit_drop_next called before bit_dedrop"</span>);
00214     }
00215     fdi-&gt;nextdrop = -1;
00216     debuglog(<span class="stringliteral">":BDD:"</span>);
00217 }
00218 
00219 <span class="comment">/* add one byte */</span>
00220 <span class="keyword">static</span> <span class="keywordtype">void</span> byte_add (FDI *fdi, uae_u8 v)
00221 {
00222     <span class="keywordtype">int</span> i;
00223     <span class="keywordflow">for</span> (i = 7; i &gt;= 0; i--)
00224         bit_add (fdi, v &amp; (1 &lt;&lt; i));
00225 }
00226 <span class="comment">/* add one word */</span>
00227 <span class="keyword">static</span> <span class="keywordtype">void</span> word_add (FDI *fdi, uae_u16 v)
00228 {
00229     byte_add (fdi, (uae_u8)(v &gt;&gt; 8));
00230     byte_add (fdi, (uae_u8)v);
00231 }
00232 <span class="comment">/* add one byte and mfm encode it */</span>
00233 <span class="keyword">static</span> <span class="keywordtype">void</span> byte_mfm_add (FDI *fdi, uae_u8 v)
00234 {
00235     <span class="keywordtype">int</span> i;
00236     <span class="keywordflow">for</span> (i = 7; i &gt;= 0; i--)
00237         bit_mfm_add (fdi, v &amp; (1 &lt;&lt; i));
00238 }
00239 <span class="comment">/* add multiple bytes and mfm encode them */</span>
00240 <span class="keyword">static</span> <span class="keywordtype">void</span> bytes_mfm_add (FDI *fdi, uae_u8 v, <span class="keywordtype">int</span> len)
00241 {
00242     <span class="keywordtype">int</span> i;
00243     <span class="keywordflow">for</span> (i = 0; i &lt; len; i++) byte_mfm_add (fdi, v);
00244 }
00245 <span class="comment">/* add one mfm encoded word and re-mfm encode it */</span>
00246 <span class="keyword">static</span> <span class="keywordtype">void</span> word_post_mfm_add (FDI *fdi, uae_u16 v)
00247 {
00248     <span class="keywordtype">int</span> i;
00249     <span class="keywordflow">for</span> (i = 14; i &gt;= 0; i -= 2)
00250         bit_mfm_add (fdi, v &amp; (1 &lt;&lt; i));
00251 }
00252 
00253 <span class="comment">/* bit 0 */</span>
00254 <span class="keyword">static</span> <span class="keywordtype">void</span> s00(FDI *fdi) { bit_add (fdi, 0); }
00255 <span class="comment">/* bit 1*/</span>
00256 <span class="keyword">static</span> <span class="keywordtype">void</span> s01(FDI *fdi) { bit_add (fdi, 1); }
00257 <span class="comment">/* 4489 */</span>
00258 <span class="keyword">static</span> <span class="keywordtype">void</span> s02(FDI *fdi) { word_add (fdi, 0x4489); }
00259 <span class="comment">/* 5224 */</span>
00260 <span class="keyword">static</span> <span class="keywordtype">void</span> s03(FDI *fdi) { word_add (fdi, 0x5224); }
00261 <span class="comment">/* mfm sync bit */</span>
00262 <span class="keyword">static</span> <span class="keywordtype">void</span> s04(FDI *fdi) { add_mfm_sync_bit (fdi); }
00263 <span class="comment">/* RLE MFM-encoded data */</span>
00264 <span class="keyword">static</span> <span class="keywordtype">void</span> s08(FDI *fdi)
00265 {
00266     <span class="keywordtype">int</span> bytes = *fdi-&gt;track_src++;
00267     uae_u8 byte = *fdi-&gt;track_src++;
00268     <span class="keywordflow">if</span> (bytes == 0) bytes = 256;
00269     debuglog (<span class="stringliteral">"s08:len=%d,data=%02.2X"</span>,bytes,byte);
00270     <span class="keywordflow">while</span>(bytes--) byte_add (fdi, byte);
00271 }
00272 <span class="comment">/* RLE MFM-decoded data */</span>
00273 <span class="keyword">static</span> <span class="keywordtype">void</span> s09(FDI *fdi)
00274 {
00275     <span class="keywordtype">int</span> bytes = *fdi-&gt;track_src++;
00276     uae_u8 byte = *fdi-&gt;track_src++;
00277     <span class="keywordflow">if</span> (bytes == 0) bytes = 256;
00278     bit_drop_next (fdi);
00279     debuglog (<span class="stringliteral">"s09:len=%d,data=%02.2X"</span>,bytes,byte);
00280     <span class="keywordflow">while</span>(bytes--) byte_mfm_add (fdi, byte);
00281 }
00282 <span class="comment">/* MFM-encoded data */</span>
00283 <span class="keyword">static</span> <span class="keywordtype">void</span> s0a(FDI *fdi)
00284 {
00285     <span class="keywordtype">int</span> i, bits = (fdi-&gt;track_src[0] &lt;&lt; 8) | fdi-&gt;track_src[1];
00286     uae_u8 b;
00287     fdi-&gt;track_src += 2;
00288     debuglog (<span class="stringliteral">"s0a:bits=%d,data=%s"</span>, bits, datalog(fdi-&gt;track_src, (bits + 7) / 8));
00289     <span class="keywordflow">while</span> (bits &gt;= 8) {
00290         byte_add (fdi, *fdi-&gt;track_src++);
00291         bits -= 8;
00292     }
00293     <span class="keywordflow">if</span> (bits &gt; 0) {
00294         i = 7;
00295         b = *fdi-&gt;track_src++;
00296         <span class="keywordflow">while</span> (bits--) {
00297             bit_add (fdi, b &amp; (1 &lt;&lt; i));
00298             i--;
00299         }
00300     }
00301 }
00302 <span class="comment">/* MFM-encoded data */</span>
00303 <span class="keyword">static</span> <span class="keywordtype">void</span> s0b(FDI *fdi)
00304 {
00305     <span class="keywordtype">int</span> i, bits = ((fdi-&gt;track_src[0] &lt;&lt; 8) | fdi-&gt;track_src[1]) + 65536;
00306     uae_u8 b;
00307     fdi-&gt;track_src += 2;
00308     debuglog (<span class="stringliteral">"s0b:bits=%d,data=%s"</span>, bits, datalog(fdi-&gt;track_src, (bits + 7) / 8));
00309     <span class="keywordflow">while</span> (bits &gt;= 8) {
00310         byte_add (fdi, *fdi-&gt;track_src++);
00311         bits -= 8;
00312     }
00313     <span class="keywordflow">if</span> (bits &gt; 0) {
00314         i = 7;
00315         b = *fdi-&gt;track_src++;
00316         <span class="keywordflow">while</span> (bits--) {
00317             bit_add (fdi, b &amp; (1 &lt;&lt; i));
00318             i--;
00319         }
00320     }
00321 }
00322 <span class="comment">/* MFM-decoded data */</span>
00323 <span class="keyword">static</span> <span class="keywordtype">void</span> s0c(FDI *fdi)
00324 {
00325     <span class="keywordtype">int</span> i, bits = (fdi-&gt;track_src[0] &lt;&lt; 8) | fdi-&gt;track_src[1];
00326     uae_u8 b;
00327     fdi-&gt;track_src += 2;
00328     bit_drop_next (fdi);
00329     debuglog (<span class="stringliteral">"s0c:bits=%d,data=%s"</span>, bits, datalog(fdi-&gt;track_src, (bits + 7) / 8));
00330     <span class="keywordflow">while</span> (bits &gt;= 8) {
00331         byte_mfm_add (fdi, *fdi-&gt;track_src++);
00332         bits -= 8;
00333     }
00334     <span class="keywordflow">if</span> (bits &gt; 0) {
00335         i = 7;
00336         b = *fdi-&gt;track_src++;
00337         <span class="keywordflow">while</span>(bits--) {
00338             bit_mfm_add (fdi, b &amp; (1 &lt;&lt; i));
00339             i--;
00340         }
00341     }
00342 }
00343 <span class="comment">/* MFM-decoded data */</span>
00344 <span class="keyword">static</span> <span class="keywordtype">void</span> s0d(FDI *fdi)
00345 {
00346     <span class="keywordtype">int</span> i, bits = ((fdi-&gt;track_src[0] &lt;&lt; 8) | fdi-&gt;track_src[1]) + 65536;
00347     uae_u8 b;
00348     fdi-&gt;track_src += 2;
00349     bit_drop_next (fdi);
00350     debuglog (<span class="stringliteral">"s0d:bits=%d,data=%s"</span>, bits, datalog(fdi-&gt;track_src, (bits + 7) / 8));
00351     <span class="keywordflow">while</span> (bits &gt;= 8) {
00352         byte_mfm_add (fdi, *fdi-&gt;track_src++);
00353         bits -= 8;
00354     }
00355     <span class="keywordflow">if</span> (bits &gt; 0) {
00356         i = 7;
00357         b = *fdi-&gt;track_src++;
00358         <span class="keywordflow">while</span>(bits--) {
00359             bit_mfm_add (fdi, b &amp; (1 &lt;&lt; i));
00360             i--;
00361         }
00362     }
00363 }
00364 
00365 <span class="comment">/* ***** */</span>
00366 <span class="comment">/* AMIGA */</span>
00367 <span class="comment">/* ***** */</span>
00368 
00369 <span class="comment">/* just for testing integrity of Amiga sectors */</span>
00370 
00371 <span class="preprocessor">#define MFMMASK 0x55555555</span>
00372 <span class="preprocessor"></span><span class="keyword">static</span> uae_u32 getmfmlong (uae_u16 * mbuf)
00373 {
00374     <span class="keywordflow">return</span> ((*mbuf &lt;&lt; 16) | *(mbuf + 1)) &amp; MFMMASK;
00375 }
00376 
00377 <span class="keyword">static</span> <span class="keywordtype">int</span> amiga_check_track (FDI *fdi)
00378 {
00379     <span class="keywordtype">int</span> i, secwritten = 0;
00380     <span class="keywordtype">int</span> fwlen = fdi-&gt;out / 8;
00381     <span class="keywordtype">int</span> length = 2 * fwlen;
00382     <span class="keywordtype">int</span> drvsec = 11;
00383     uae_u32 odd, even, chksum, id, dlong;
00384     uae_u8 *secdata;
00385     uae_u8 secbuf[544];
00386     uae_u16 bigmfmbuf[30000];
00387     uae_u16 *mbuf = bigmfmbuf;
00388     uae_u16 *mend = mbuf + length;
00389     <span class="keywordtype">char</span> sectable[22];
00390     uae_u8 *raw = fdi-&gt;track_dst_buffer;
00391     <span class="keywordtype">int</span> slabel;
00392 
00393     <span class="keywordflow">for</span> (i = 0; i &lt; (fdi-&gt;out + 15) / 16; i++)
00394         bigmfmbuf[i] = raw[i * 2 + 0] * 256 + raw[i * 2 + 1];
00395 
00396     memset (sectable, 0, <span class="keyword">sizeof</span> (sectable));
00397     <span class="comment">//memcpy (mbuf + fwlen, mbuf, fwlen * sizeof (uae_u16));</span>
00398     mend -= (4 + 16 + 8 + 512);
00399 
00400     <span class="keywordflow">while</span> (secwritten &lt; drvsec) {
00401         <span class="keywordtype">int</span> trackoffs;
00402 
00403         <span class="keywordflow">do</span> {
00404             <span class="keywordflow">while</span> (*mbuf++ != 0x4489) {
00405                 <span class="keywordflow">if</span> (mbuf &gt;= mend) <span class="keywordflow">return</span> 1;
00406             }
00407         } <span class="keywordflow">while</span> (*mbuf++ != 0x4489);
00408 
00409         odd = getmfmlong (mbuf);
00410         even = getmfmlong (mbuf + 2);
00411         mbuf += 4;
00412         id = (odd &lt;&lt; 1) | even;
00413 
00414         trackoffs = (id &amp; 0xff00) &gt;&gt; 8;
00415         <span class="keywordflow">if</span> (trackoffs + 1 &gt; drvsec) {
00416             debuglog(<span class="stringliteral">"illegal sector offset %d\n"</span>,trackoffs);
00417             <span class="keywordflow">continue</span>;
00418         }
00419         chksum = odd ^ even;
00420         slabel = 0;
00421         <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++) {
00422             odd = getmfmlong (mbuf);
00423             even = getmfmlong (mbuf + 8);
00424             mbuf += 2;
00425 
00426             dlong = (odd &lt;&lt; 1) | even;
00427             <span class="keywordflow">if</span> (dlong) slabel = 1;
00428             chksum ^= odd ^ even;
00429         }
00430         mbuf += 8;
00431         odd = getmfmlong (mbuf);
00432         even = getmfmlong (mbuf + 2);
00433         mbuf += 4;
00434         <span class="keywordflow">if</span> (((odd &lt;&lt; 1) | even) != chksum) {
00435             debuglog(<span class="stringliteral">"sector header crc error\n"</span>);
00436             <span class="keywordflow">continue</span>;
00437         }
00438         <span class="keywordflow">if</span> (((id &amp; 0x00ff0000) &gt;&gt; 16) != (uae_u32)fdi-&gt;current_track) {
00439             debuglog(<span class="stringliteral">"illegal track number %d &lt;&gt; %d\n"</span>,fdi-&gt;current_track,(id &amp; 0x00ff0000) &gt;&gt; 16);
00440             <span class="keywordflow">continue</span>;
00441         }
00442         odd = getmfmlong (mbuf);
00443         even = getmfmlong (mbuf + 2);
00444         mbuf += 4;
00445         chksum = (odd &lt;&lt; 1) | even;
00446         secdata = secbuf + 32;
00447         <span class="keywordflow">for</span> (i = 0; i &lt; 128; i++) {
00448             odd = getmfmlong (mbuf);
00449             even = getmfmlong (mbuf + 256);
00450             mbuf += 2;
00451             dlong = (odd &lt;&lt; 1) | even;
00452             *secdata++ = (uae_u8) (dlong &gt;&gt; 24);
00453             *secdata++ = (uae_u8) (dlong &gt;&gt; 16);
00454             *secdata++ = (uae_u8) (dlong &gt;&gt; 8);
00455             *secdata++ = (uae_u8) dlong;
00456             chksum ^= odd ^ even;
00457         }
00458         mbuf += 256;
00459         <span class="keywordflow">if</span> (chksum) {
00460             debuglog(<span class="stringliteral">"sector %d data checksum error"</span>,trackoffs);
00461         } <span class="keywordflow">else</span> {
00462             debuglog(<span class="stringliteral">"sector %d ok "</span>,trackoffs);
00463             <span class="keywordflow">if</span> (slabel) debuglog(<span class="stringliteral">"(non-empty sector header)"</span>);
00464         }
00465         debuglog(<span class="stringliteral">"\n"</span>);
00466         sectable[trackoffs] = 1;
00467         secwritten++;
00468     }   
00469     <span class="keywordflow">return</span> 0;
00470 }
00471 
00472 <span class="keyword">static</span> <span class="keywordtype">void</span> amiga_data_raw (FDI *fdi, uae_u8 *secbuf, uae_u8 *crc, <span class="keywordtype">int</span> len)
00473 {
00474     <span class="keywordtype">int</span> i;
00475     uae_u8 crcbuf[4];
00476 
00477     <span class="keywordflow">if</span> (!crc) {
00478         memset (crcbuf, 0, 4);
00479     } <span class="keywordflow">else</span> {
00480         memcpy (crcbuf, crc ,4);
00481     }
00482     <span class="keywordflow">for</span> (i = 0; i &lt; 4; i++)
00483         byte_mfm_add (fdi, crcbuf[i]);
00484     <span class="keywordflow">for</span> (i = 0; i &lt; len; i++)
00485         byte_mfm_add (fdi, secbuf[i]);
00486 }
00487 
00488 <span class="keyword">static</span> <span class="keywordtype">void</span> amiga_data (FDI *fdi, uae_u8 *secbuf)
00489 {
00490     uae_u16 mfmbuf[4 + 512];
00491     uae_u32 dodd, deven, dck;
00492     <span class="keywordtype">int</span> i;
00493 
00494     <span class="keywordflow">for</span> (i = 0; i &lt; 512; i += 4) {
00495         deven = ((secbuf[i + 0] &lt;&lt; 24) | (secbuf[i + 1] &lt;&lt; 16)
00496          | (secbuf[i + 2] &lt;&lt; 8) | (secbuf[i + 3]));
00497         dodd = deven &gt;&gt; 1;
00498         deven &amp;= 0x55555555;
00499         dodd &amp;= 0x55555555;
00500         mfmbuf[(i &gt;&gt; 1) + 4] = (uae_u16) (dodd &gt;&gt; 16);
00501         mfmbuf[(i &gt;&gt; 1) + 5] = (uae_u16) dodd;
00502         mfmbuf[(i &gt;&gt; 1) + 256 + 4] = (uae_u16) (deven &gt;&gt; 16);
00503         mfmbuf[(i &gt;&gt; 1) + 256 + 5] = (uae_u16) deven;
00504     }
00505     dck = 0;
00506     <span class="keywordflow">for</span> (i = 4; i &lt; 4 + 512; i += 2)
00507         dck ^= (mfmbuf[i] &lt;&lt; 16) | mfmbuf[i + 1];
00508     deven = dodd = dck;
00509     dodd &gt;&gt;= 1;
00510     deven &amp;= 0x55555555;
00511     dodd &amp;= 0x55555555;
00512     mfmbuf[0] = (uae_u16) (dodd &gt;&gt; 16);
00513     mfmbuf[1] = (uae_u16) dodd;
00514     mfmbuf[2] = (uae_u16) (deven &gt;&gt; 16);
00515     mfmbuf[3] = (uae_u16) deven;
00516 
00517     <span class="keywordflow">for</span> (i = 0; i &lt; 4 + 512; i ++)
00518         word_post_mfm_add (fdi, mfmbuf[i]);
00519 }
00520 
00521 <span class="keyword">static</span> <span class="keywordtype">void</span> amiga_sector_header (FDI *fdi, uae_u8 *header, uae_u8 *data, <span class="keywordtype">int</span> sector, <span class="keywordtype">int</span> untilgap)
00522 {
00523     uae_u8 headerbuf[4], databuf[16];
00524     uae_u32 deven, dodd, hck;
00525     uae_u16 mfmbuf[24];
00526     <span class="keywordtype">int</span> i;
00527 
00528     byte_mfm_add (fdi, 0);
00529     byte_mfm_add (fdi, 0);
00530     word_add (fdi, 0x4489);
00531     word_add (fdi, 0x4489);
00532     <span class="keywordflow">if</span> (header) {
00533         memcpy (headerbuf, header, 4);
00534     } <span class="keywordflow">else</span> {
00535         headerbuf[0] = 0xff;
00536         headerbuf[1] = (uae_u8)fdi-&gt;current_track;
00537         headerbuf[2] = (uae_u8)sector;
00538         headerbuf[3] = (uae_u8)untilgap;
00539     }
00540     <span class="keywordflow">if</span> (data)
00541         memcpy (databuf, data, 16);
00542     <span class="keywordflow">else</span>
00543         memset (databuf, 0, 16);
00544 
00545     deven = ((headerbuf[0] &lt;&lt; 24) | (headerbuf[1] &lt;&lt; 16)
00546         | (headerbuf[2] &lt;&lt; 8) | (headerbuf[3]));
00547     dodd = deven &gt;&gt; 1;
00548     deven &amp;= 0x55555555;
00549     dodd &amp;= 0x55555555;
00550     mfmbuf[0] = (uae_u16) (dodd &gt;&gt; 16);
00551     mfmbuf[1] = (uae_u16) dodd;
00552     mfmbuf[2] = (uae_u16) (deven &gt;&gt; 16);
00553     mfmbuf[3] = (uae_u16) deven;
00554     <span class="keywordflow">for</span> (i = 0; i &lt; 16; i += 4) {
00555         deven = ((databuf[i] &lt;&lt; 24) | (databuf[i + 1] &lt;&lt; 16)
00556             | (databuf[i + 2] &lt;&lt; 8) | (databuf[i + 3]));
00557         dodd = deven &gt;&gt; 1;
00558         deven &amp;= 0x55555555;
00559         dodd &amp;= 0x55555555;
00560         mfmbuf[(i &gt;&gt; 1) + 0 + 4] = (uae_u16) (dodd &gt;&gt; 16);
00561         mfmbuf[(i &gt;&gt; 1) + 0 + 5] = (uae_u16) dodd;
00562         mfmbuf[(i &gt;&gt; 1) + 8 + 4] = (uae_u16) (deven &gt;&gt; 16);
00563         mfmbuf[(i &gt;&gt; 1) + 8 + 5] = (uae_u16) deven;
00564     }
00565     hck = 0;
00566     <span class="keywordflow">for</span> (i = 0; i &lt; 4 + 16; i += 2)
00567         hck ^= (mfmbuf[i] &lt;&lt; 16) | mfmbuf[i + 1];
00568     deven = dodd = hck;
00569     dodd &gt;&gt;= 1;
00570     deven &amp;= 0x55555555;
00571     dodd &amp;= 0x55555555;
00572     mfmbuf[20] = (uae_u16) (dodd &gt;&gt; 16);
00573     mfmbuf[21] = (uae_u16) dodd;
00574     mfmbuf[22] = (uae_u16) (deven &gt;&gt; 16);
00575     mfmbuf[23] = (uae_u16) deven;
00576 
00577     <span class="keywordflow">for</span> (i = 0; i &lt; 4 + 16 + 4; i ++)
00578         word_post_mfm_add (fdi, mfmbuf[i]);
00579 }
00580 
00581 <span class="comment">/* standard super-extended Amiga sector header */</span>
00582 <span class="keyword">static</span> <span class="keywordtype">void</span> s20(FDI *fdi)
00583 {
00584     bit_drop_next (fdi);
00585     debuglog (<span class="stringliteral">"s20:header=%s,data=%s"</span>, datalog(fdi-&gt;track_src, 4), datalog(fdi-&gt;track_src + 4, 16)); 
00586     amiga_sector_header (fdi, fdi-&gt;track_src, fdi-&gt;track_src + 4, 0, 0);
00587     fdi-&gt;track_src += 4 + 16;
00588 }
00589 <span class="comment">/* standard extended Amiga sector header */</span>
00590 <span class="keyword">static</span> <span class="keywordtype">void</span> s21(FDI *fdi)
00591 {
00592     bit_drop_next (fdi);
00593     debuglog (<span class="stringliteral">"s21:header=%s"</span>, datalog(fdi-&gt;track_src, 4)); 
00594     amiga_sector_header (fdi, fdi-&gt;track_src, 0, 0, 0);
00595     fdi-&gt;track_src += 4;
00596 }
00597 <span class="comment">/* standard Amiga sector header */</span>
00598 <span class="keyword">static</span> <span class="keywordtype">void</span> s22(FDI *fdi)
00599 {
00600     bit_drop_next (fdi);
00601     debuglog(<span class="stringliteral">"s22:sector=%d,untilgap=%d"</span>, fdi-&gt;track_src[0], fdi-&gt;track_src[1]);
00602     amiga_sector_header (fdi, 0, 0, fdi-&gt;track_src[0], fdi-&gt;track_src[1]);
00603     fdi-&gt;track_src += 2;
00604 }
00605 <span class="comment">/* standard 512-byte, CRC-correct Amiga data */</span>
00606 <span class="keyword">static</span> <span class="keywordtype">void</span> s23(FDI *fdi)
00607 {
00608     debuglog(<span class="stringliteral">"s23:data=%s"</span>, datalog (fdi-&gt;track_src, 512));
00609     amiga_data (fdi, fdi-&gt;track_src);
00610     fdi-&gt;track_src += 512;
00611 }
00612 <span class="comment">/* not-decoded, 128*2^x-byte, CRC-correct Amiga data */</span>
00613 <span class="keyword">static</span> <span class="keywordtype">void</span> s24(FDI *fdi)
00614 {
00615     <span class="keywordtype">int</span> shift = *fdi-&gt;track_src++;
00616     debuglog(<span class="stringliteral">"s24:shift=%d,data=%s"</span>, shift, datalog (fdi-&gt;track_src, 128 &lt;&lt; shift));
00617     amiga_data_raw (fdi, fdi-&gt;track_src, 0, 128 &lt;&lt; shift);
00618     fdi-&gt;track_src += 128 &lt;&lt; shift;
00619 }
00620 <span class="comment">/* not-decoded, 128*2^x-byte, CRC-incorrect Amiga data */</span>
00621 <span class="keyword">static</span> <span class="keywordtype">void</span> s25(FDI *fdi)
00622 {
00623     <span class="keywordtype">int</span> shift = *fdi-&gt;track_src++;
00624     debuglog(<span class="stringliteral">"s25:shift=%d,crc=%s,data=%s"</span>, shift, datalog (fdi-&gt;track_src, 4), datalog (fdi-&gt;track_src + 4, 128 &lt;&lt; shift));
00625     amiga_data_raw (fdi, fdi-&gt;track_src + 4, fdi-&gt;track_src, 128 &lt;&lt; shift);
00626     fdi-&gt;track_src += 4 + (128 &lt;&lt; shift);
00627 }
00628 <span class="comment">/* standard extended Amiga sector */</span>
00629 <span class="keyword">static</span> <span class="keywordtype">void</span> s26(FDI *fdi)
00630 {
00631     s21 (fdi);
00632     debuglog(<span class="stringliteral">"s26:data=%s"</span>, datalog (fdi-&gt;track_src, 512));
00633     amiga_data (fdi, fdi-&gt;track_src);
00634     fdi-&gt;track_src += 512;
00635 }
00636 <span class="comment">/* standard short Amiga sector */</span>
00637 <span class="keyword">static</span> <span class="keywordtype">void</span> s27(FDI *fdi)
00638 {
00639     s22 (fdi);
00640     debuglog(<span class="stringliteral">"s27:data=%s"</span>, datalog (fdi-&gt;track_src, 512));
00641     amiga_data (fdi, fdi-&gt;track_src);
00642     fdi-&gt;track_src += 512;
00643 }
00644 
00645 <span class="comment">/* *** */</span>
00646 <span class="comment">/* IBM */</span>
00647 <span class="comment">/* *** */</span>
00648 
00649 <span class="keyword">static</span> uae_u16 ibm_crc (uae_u8 byte, <span class="keywordtype">int</span> reset)
00650 {
00651     <span class="keyword">static</span> uae_u16 crc;
00652     <span class="keywordtype">int</span> i;
00653 
00654     <span class="keywordflow">if</span> (reset) crc = 0xcdb4;
00655     <span class="keywordflow">for</span> (i = 0; i &lt; 8; i++) {
00656         <span class="keywordflow">if</span> (crc &amp; 0x8000) {
00657             crc &lt;&lt;= 1;
00658             <span class="keywordflow">if</span> (!(byte &amp; 0x80)) crc ^= 0x1021;
00659         } <span class="keywordflow">else</span> {
00660             crc &lt;&lt;= 1;
00661             <span class="keywordflow">if</span> (byte &amp; 0x80) crc ^= 0x1021;
00662         }
00663         byte &lt;&lt;= 1;
00664     }
00665     <span class="keywordflow">return</span> crc;
00666 }
00667 
00668 <span class="keyword">static</span> <span class="keywordtype">void</span> ibm_data (FDI *fdi, uae_u8 *data, uae_u8 *crc, <span class="keywordtype">int</span> len)
00669 {
00670     <span class="keywordtype">int</span> i;
00671     uae_u8 crcbuf[2];
00672     uae_u16 crcv;
00673 
00674     word_add (fdi, 0x4489);
00675     word_add (fdi, 0x4489);
00676     word_add (fdi, 0x4489);
00677     byte_mfm_add (fdi, 0xfb);
00678     ibm_crc (0xfb, 1);
00679     <span class="keywordflow">for</span> (i = 0; i &lt; len; i++) {
00680         byte_mfm_add (fdi, data[i]);
00681         crcv = ibm_crc (data[i], 0);
00682     }
00683     <span class="keywordflow">if</span> (!crc) {
00684         crc = crcbuf;
00685         crc[0] = (uae_u8)(crcv &gt;&gt; 8);
00686         crc[1] = (uae_u8)crcv;
00687     }
00688     byte_mfm_add (fdi, crc[0]);
00689     byte_mfm_add (fdi, crc[1]);
00690 }
00691 
00692 <span class="keyword">static</span> <span class="keywordtype">void</span> ibm_sector_header (FDI *fdi, uae_u8 *data, uae_u8 *crc, <span class="keywordtype">int</span> secnum, <span class="keywordtype">int</span> pre)
00693 {
00694     uae_u8 secbuf[5];
00695     uae_u8 crcbuf[2];
00696     uae_u16 crcv;
00697     <span class="keywordtype">int</span> i;
00698 
00699     <span class="keywordflow">if</span> (pre)
00700         bytes_mfm_add (fdi, 0, 12);
00701     word_add (fdi, 0x4489);
00702     word_add (fdi, 0x4489);
00703     word_add (fdi, 0x4489);
00704     secbuf[0] = 0xfe;
00705     <span class="keywordflow">if</span> (secnum &gt;= 0) {
00706         secbuf[1] = (uae_u8)(fdi-&gt;current_track/2);
00707         secbuf[2] = (uae_u8)(fdi-&gt;current_track%2);
00708         secbuf[3] = (uae_u8)secnum;
00709         secbuf[4] = 2;
00710     } <span class="keywordflow">else</span> {
00711         memcpy (secbuf + 1, data, 4);
00712     }
00713     ibm_crc (secbuf[0], 1);
00714     ibm_crc (secbuf[1], 0);
00715     ibm_crc (secbuf[2], 0);
00716     ibm_crc (secbuf[3], 0);
00717     crcv = ibm_crc (secbuf[4], 0);
00718     <span class="keywordflow">if</span> (crc) {
00719         memcpy (crcbuf, crc, 2);
00720     } <span class="keywordflow">else</span> {
00721         crcbuf[0] = (uae_u8)(crcv &gt;&gt; 8);
00722         crcbuf[1] = (uae_u8)crcv;
00723     }
00724     <span class="comment">/* data */</span>
00725     <span class="keywordflow">for</span> (i = 0;i &lt; 5; i++)
00726         byte_mfm_add (fdi, secbuf[i]);
00727     <span class="comment">/* crc */</span>
00728     byte_mfm_add (fdi, crcbuf[0]);
00729     byte_mfm_add (fdi, crcbuf[1]);
00730 }
00731 
00732 <span class="comment">/* standard IBM index address mark */</span>
00733 <span class="keyword">static</span> <span class="keywordtype">void</span> s10(FDI *fdi)
00734 {
00735     bit_drop_next (fdi);
00736     bytes_mfm_add (fdi, 0, 12);
00737     word_add (fdi, 0x5224);
00738     word_add (fdi, 0x5224);
00739     word_add (fdi, 0x5224);
00740     byte_mfm_add (fdi, 0xfc);
00741 }
00742 <span class="comment">/* standard IBM pre-gap */</span>
00743 <span class="keyword">static</span> <span class="keywordtype">void</span> s11(FDI *fdi)
00744 {
00745     bit_drop_next (fdi);
00746     bytes_mfm_add (fdi, 0x4e, 78);
00747     bit_dedrop (fdi);
00748     s10 (fdi);
00749     bytes_mfm_add (fdi, 0x4e, 50);
00750 }
00751 <span class="comment">/* standard ST pre-gap */</span>
00752 <span class="keyword">static</span> <span class="keywordtype">void</span> s12(FDI *fdi)
00753 {
00754     bit_drop_next (fdi);
00755     bytes_mfm_add (fdi, 0x4e, 78);
00756 }
00757 <span class="comment">/* standard extended IBM sector header */</span>
00758 <span class="keyword">static</span> <span class="keywordtype">void</span> s13(FDI *fdi)
00759 {
00760     bit_drop_next (fdi);
00761     debuglog (<span class="stringliteral">"s13:header=%s"</span>, datalog (fdi-&gt;track_src, 4));
00762     ibm_sector_header (fdi, fdi-&gt;track_src, 0, -1, 1);
00763     fdi-&gt;track_src += 4;
00764 }
00765 <span class="comment">/* standard mini-extended IBM sector header */</span>
00766 <span class="keyword">static</span> <span class="keywordtype">void</span> s14(FDI *fdi)
00767 {
00768     debuglog (<span class="stringliteral">"s14:header=%s"</span>, datalog (fdi-&gt;track_src, 4));
00769     ibm_sector_header (fdi, fdi-&gt;track_src, 0, -1, 0);
00770     fdi-&gt;track_src += 4;
00771 }
00772 <span class="comment">/* standard short IBM sector header */</span>
00773 <span class="keyword">static</span> <span class="keywordtype">void</span> s15(FDI *fdi)
00774 {
00775     bit_drop_next (fdi);
00776     debuglog (<span class="stringliteral">"s15:sector=%d"</span>, *fdi-&gt;track_src);
00777     ibm_sector_header (fdi, 0, 0, *fdi-&gt;track_src++, 1);
00778 }
00779 <span class="comment">/* standard mini-short IBM sector header */</span>
00780 <span class="keyword">static</span> <span class="keywordtype">void</span> s16(FDI *fdi)
00781 {
00782     debuglog (<span class="stringliteral">"s16:track=%d"</span>, *fdi-&gt;track_src);
00783     ibm_sector_header (fdi, 0, 0, *fdi-&gt;track_src++, 0);
00784 }
00785 <span class="comment">/* standard CRC-incorrect mini-extended IBM sector header */</span>
00786 <span class="keyword">static</span> <span class="keywordtype">void</span> s17(FDI *fdi)
00787 {
00788     debuglog (<span class="stringliteral">"s17:header=%s,crc=%s"</span>, datalog (fdi-&gt;track_src, 4), datalog (fdi-&gt;track_src + 4, 2));
00789     ibm_sector_header (fdi, fdi-&gt;track_src, fdi-&gt;track_src + 4, -1, 0);
00790     fdi-&gt;track_src += 4 + 2;
00791 }
00792 <span class="comment">/* standard CRC-incorrect mini-short IBM sector header */</span>
00793 <span class="keyword">static</span> <span class="keywordtype">void</span> s18(FDI *fdi)
00794 {
00795     debuglog (<span class="stringliteral">"s18:sector=%d,header=%s"</span>, *fdi-&gt;track_src, datalog (fdi-&gt;track_src + 1, 4));
00796     ibm_sector_header (fdi, 0, fdi-&gt;track_src + 1, *fdi-&gt;track_src, 0);
00797     fdi-&gt;track_src += 1 + 4;
00798 }
00799 <span class="comment">/* standard 512-byte CRC-correct IBM data */</span>
00800 <span class="keyword">static</span> <span class="keywordtype">void</span> s19(FDI *fdi)
00801 {
00802     debuglog (<span class="stringliteral">"s19:data=%s"</span>, datalog (fdi-&gt;track_src , 512));
00803     ibm_data (fdi, fdi-&gt;track_src, 0, 512);
00804     fdi-&gt;track_src += 512;
00805 }
00806 <span class="comment">/* standard 128*2^x-byte-byte CRC-correct IBM data */</span>
00807 <span class="keyword">static</span> <span class="keywordtype">void</span> s1a(FDI *fdi)
00808 {
00809     <span class="keywordtype">int</span> shift = *fdi-&gt;track_src++;
00810     debuglog (<span class="stringliteral">"s1a:shift=%d,data=%s"</span>, shift, datalog (fdi-&gt;track_src , 128 &lt;&lt; shift));
00811     ibm_data (fdi, fdi-&gt;track_src, 0, 128 &lt;&lt; shift);
00812     fdi-&gt;track_src += 128 &lt;&lt; shift;
00813 }
00814 <span class="comment">/* standard 128*2^x-byte-byte CRC-incorrect IBM data */</span>
00815 <span class="keyword">static</span> <span class="keywordtype">void</span> s1b(FDI *fdi)
00816 {
00817     <span class="keywordtype">int</span> shift = *fdi-&gt;track_src++;
00818     debuglog (<span class="stringliteral">"s1b:shift=%d,crc=%s,data=%s"</span>, shift, datalog (fdi-&gt;track_src + (128 &lt;&lt; shift), 2), datalog (fdi-&gt;track_src , 128 &lt;&lt; shift));
00819     ibm_data (fdi, fdi-&gt;track_src, fdi-&gt;track_src + (128 &lt;&lt; shift), 128 &lt;&lt; shift);
00820     fdi-&gt;track_src += (128 &lt;&lt; shift) + 2;
00821 }
00822 <span class="comment">/* standard extended IBM sector */</span>
00823 <span class="keyword">static</span> <span class="keywordtype">void</span> s1c(FDI *fdi)
00824 {
00825     <span class="keywordtype">int</span> shift = fdi-&gt;track_src[3];
00826     s13 (fdi);
00827     bytes_mfm_add (fdi, 0x4e, 22);
00828     bytes_mfm_add (fdi, 0x00, 12);
00829     ibm_data (fdi, fdi-&gt;track_src, 0, 128 &lt;&lt; shift);
00830     fdi-&gt;track_src += 128 &lt;&lt; shift;
00831 }
00832 <span class="comment">/* standard short IBM sector */</span>
00833 <span class="keyword">static</span> <span class="keywordtype">void</span> s1d(FDI *fdi)
00834 {
00835     s15 (fdi);
00836     bytes_mfm_add (fdi, 0x4e, 22);
00837     bytes_mfm_add (fdi, 0x00, 12);
00838     s19 (fdi);
00839 }
00840 
00841 <span class="comment">/* end marker */</span>
00842 <span class="keyword">static</span> <span class="keywordtype">void</span> sff(FDI *fdi)
00843 {
00844 }
00845 
00846 <span class="keyword">typedef</span> void (*decode_described_track_func)(FDI*);
00847 
00848 <span class="keyword">static</span> decode_described_track_func decode_sectors_described_track[] =
00849 {
00850     s00,s01,s02,s03,s04,dxx,dxx,dxx,s08,s09,s0a,s0b,s0c,s0d,dxx,dxx, <span class="comment">/* 00-0F */</span>
00851     s10,s11,s12,s13,s14,s15,s16,s17,s18,s19,s1a,s1b,s1c,s1d,dxx,dxx, <span class="comment">/* 10-1F */</span>
00852     s20,s21,s22,s23,s24,s25,s26,s27,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* 20-2F */</span>
00853     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* 30-3F */</span>
00854     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* 40-4F */</span>
00855     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* 50-5F */</span>
00856     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* 60-6F */</span>
00857     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* 70-7F */</span>
00858     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* 80-8F */</span>
00859     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* 90-9F */</span>
00860     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* A0-AF */</span>
00861     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* B0-BF */</span>
00862     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* C0-CF */</span>
00863     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* D0-DF */</span>
00864     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx, <span class="comment">/* E0-EF */</span>
00865     dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,dxx,sff  <span class="comment">/* F0-FF */</span>
00866 };
00867 
00868 <span class="keyword">static</span> <span class="keywordtype">void</span> track_amiga (<span class="keyword">struct</span> fdi *fdi, <span class="keywordtype">int</span> first_sector, <span class="keywordtype">int</span> max_sector)
00869 {
00870     <span class="keywordtype">int</span> i;
00871 
00872     bit_add (fdi, 0);
00873     bit_drop_next (fdi);
00874     <span class="keywordflow">for</span> (i = 0; i &lt; max_sector; i++) {
00875         amiga_sector_header (fdi, 0, 0, first_sector, max_sector - i);
00876         amiga_data (fdi, fdi-&gt;track_src + first_sector * 512);
00877         first_sector++;
00878         <span class="keywordflow">if</span> (first_sector &gt;= max_sector) first_sector = 0;
00879     }
00880     bytes_mfm_add (fdi, 0, 260); <span class="comment">/* gap */</span>
00881 }
00882 <span class="keyword">static</span> <span class="keywordtype">void</span> track_atari_st (<span class="keyword">struct</span> fdi *fdi, <span class="keywordtype">int</span> max_sector)
00883 {
00884     <span class="keywordtype">int</span> i, gap3;
00885     uae_u8 *p = fdi-&gt;track_src;
00886 
00887     <span class="keywordflow">switch</span> (max_sector)
00888         {
00889         <span class="keywordflow">case</span> 9:
00890         gap3 = 40;
00891         <span class="keywordflow">break</span>;
00892         <span class="keywordflow">case</span> 10:
00893         gap3 = 24;
00894         <span class="keywordflow">break</span>;
00895     }
00896     s15 (fdi);
00897     <span class="keywordflow">for</span> (i = 0; i &lt; max_sector; i++) {
00898         byte_mfm_add (fdi, 0x4e);
00899         byte_mfm_add (fdi, 0x4e);
00900         ibm_sector_header (fdi, 0, 0, fdi-&gt;current_track, 1);
00901         ibm_data (fdi, p + i * 512, 0, 512);
00902         bytes_mfm_add (fdi, 0x4e, gap3);
00903     }
00904     bytes_mfm_add (fdi, 0x4e, 660 - gap3);
00905     fdi-&gt;track_src += fdi-&gt;track_len * 256;
00906 }
00907 <span class="keyword">static</span> <span class="keywordtype">void</span> track_pc (<span class="keyword">struct</span> fdi *fdi, <span class="keywordtype">int</span> max_sector)
00908 {
00909     <span class="keywordtype">int</span> i, gap3;
00910     uae_u8 *p = fdi-&gt;track_src;
00911 
00912     <span class="keywordflow">switch</span> (max_sector)
00913         {
00914         <span class="keywordflow">case</span> 8:
00915         gap3 = 116;
00916         <span class="keywordflow">break</span>;
00917         <span class="keywordflow">case</span> 9:
00918         gap3 = 54;
00919         <span class="keywordflow">break</span>;
00920         <span class="keywordflow">default</span>:
00921         gap3 = 100; <span class="comment">/* fixme */</span>
00922         <span class="keywordflow">break</span>;
00923     }
00924     s11 (fdi);
00925     <span class="keywordflow">for</span> (i = 0; i &lt; max_sector; i++) {
00926         byte_mfm_add (fdi, 0x4e);
00927         byte_mfm_add (fdi, 0x4e);
00928         ibm_sector_header (fdi, 0, 0, fdi-&gt;current_track, 1);
00929         ibm_data (fdi, p + i * 512, 0, 512);
00930         bytes_mfm_add (fdi, 0x4e, gap3);
00931     }
00932     bytes_mfm_add (fdi, 0x4e, 600 - gap3);
00933     fdi-&gt;track_src += fdi-&gt;track_len * 256;
00934 }
00935 
00936 <span class="comment">/* amiga dd */</span>
00937 <span class="keyword">static</span> <span class="keywordtype">void</span> track_amiga_dd (<span class="keyword">struct</span> fdi *fdi)
00938 {
00939     uae_u8 *p = fdi-&gt;track_src;
00940     track_amiga (fdi, fdi-&gt;track_len &gt;&gt; 4, 11);
00941     fdi-&gt;track_src = p + (fdi-&gt;track_len &amp; 15) * 512;
00942 }
00943 <span class="comment">/* amiga hd */</span>
00944 <span class="keyword">static</span> <span class="keywordtype">void</span> track_amiga_hd (<span class="keyword">struct</span> fdi *fdi)
00945 {
00946     uae_u8 *p = fdi-&gt;track_src;
00947     track_amiga (fdi, 0, 22);
00948     fdi-&gt;track_src = p + fdi-&gt;track_len * 256;
00949 }
00950 <span class="comment">/* atari st 9 sector */</span>
00951 <span class="keyword">static</span> <span class="keywordtype">void</span> track_atari_st_9 (<span class="keyword">struct</span> fdi *fdi)
00952 {
00953     track_atari_st (fdi, 9);
00954 }
00955 <span class="comment">/* atari st 10 sector */</span>
00956 <span class="keyword">static</span> <span class="keywordtype">void</span> track_atari_st_10 (<span class="keyword">struct</span> fdi *fdi)
00957 {
00958     track_atari_st (fdi, 10);
00959 }
00960 <span class="comment">/* pc 8 sector */</span>
00961 <span class="keyword">static</span> <span class="keywordtype">void</span> track_pc_8 (<span class="keyword">struct</span> fdi *fdi)
00962 {
00963     track_pc (fdi, 8);
00964 }
00965 <span class="comment">/* pc 9 sector */</span>
00966 <span class="keyword">static</span> <span class="keywordtype">void</span> track_pc_9 (<span class="keyword">struct</span> fdi *fdi)
00967 {
00968     track_pc (fdi, 9);
00969 }
00970 <span class="comment">/* pc 15 sector */</span>
00971 <span class="keyword">static</span> <span class="keywordtype">void</span> track_pc_15 (<span class="keyword">struct</span> fdi *fdi)
00972 {
00973     track_pc (fdi, 15);
00974 }
00975 <span class="comment">/* pc 18 sector */</span>
00976 <span class="keyword">static</span> <span class="keywordtype">void</span> track_pc_18 (<span class="keyword">struct</span> fdi *fdi)
00977 {
00978     track_pc (fdi, 18);
00979 }
00980 <span class="comment">/* pc 36 sector */</span>
00981 <span class="keyword">static</span> <span class="keywordtype">void</span> track_pc_36 (<span class="keyword">struct</span> fdi *fdi)
00982 {
00983     track_pc (fdi, 36);
00984 }
00985 
00986 <span class="keyword">typedef</span> void (*decode_normal_track_func)(FDI*);
00987 
00988 <span class="keyword">static</span> decode_normal_track_func decode_normal_track[] =
00989 { 
00990     track_empty, <span class="comment">/* 0 */</span>
00991     track_amiga_dd, track_amiga_hd, <span class="comment">/* 1-2 */</span>
00992     track_atari_st_9, track_atari_st_10, <span class="comment">/* 3-4 */</span>
00993     track_pc_8, track_pc_9, track_pc_15, track_pc_18, track_pc_36, <span class="comment">/* 5-9 */</span>
00994     zxx,zxx,zxx,zxx,zxx <span class="comment">/* A-F */</span>
00995 };
00996 
00997 <span class="keyword">static</span> <span class="keywordtype">void</span> fix_mfm_sync (FDI *fdi)
00998 {
00999     <span class="keywordtype">int</span> i, pos, off1, off2, off3, mask1, mask2, mask3;
01000 
01001     <span class="keywordflow">for</span> (i = 0; i &lt; fdi-&gt;mfmsync_offset; i++) {
01002         pos = fdi-&gt;mfmsync_buffer[i];
01003         off1 = (pos - 1) &gt;&gt; 3;
01004         off2 = (pos + 1) &gt;&gt; 3;
01005         off3 = pos &gt;&gt; 3;
01006         mask1 = 1 &lt;&lt; (7 - ((pos - 1) &amp; 7));
01007         mask2 = 1 &lt;&lt; (7 - ((pos + 1) &amp; 7));
01008         mask3 = 1 &lt;&lt; (7 - (pos &amp; 7));
01009         <span class="keywordflow">if</span> (!(fdi-&gt;track_dst[off1] &amp; mask1) &amp;&amp; !(fdi-&gt;track_dst[off2] &amp; mask2))
01010             fdi-&gt;track_dst[off3] |= mask3;
01011         <span class="keywordflow">else</span>
01012             fdi-&gt;track_dst[off3] &amp;= ~mask3;
01013     }
01014 }
01015 
01016 <span class="keyword">static</span> <span class="keywordtype">int</span> handle_sectors_described_track (FDI *fdi)
01017 {
01018     <span class="keywordtype">int</span> oldout;
01019     uae_u8 *start_src = fdi-&gt;track_src ;
01020     fdi-&gt;encoding_type = *fdi-&gt;track_src++;
01021     fdi-&gt;index_offset = get_u32(fdi-&gt;track_src);
01022     fdi-&gt;index_offset &gt;&gt;= 8;
01023     fdi-&gt;track_src += 3;
01024     outlog (<span class="stringliteral">"sectors_described, index offset: %d\n"</span>,fdi-&gt;index_offset);
01025 
01026     <span class="keywordflow">do</span> {
01027         fdi-&gt;track_type = *fdi-&gt;track_src++;
01028         outlog (<span class="stringliteral">"%06.6X %06.6X %02.2X:"</span>,fdi-&gt;track_src - start_src + 0x200, fdi-&gt;out/8, fdi-&gt;track_type);
01029         oldout = fdi-&gt;out;
01030         decode_sectors_described_track[fdi-&gt;track_type](fdi);
01031         outlog(<span class="stringliteral">" %d\n"</span>, fdi-&gt;out - oldout);
01032         oldout = fdi-&gt;out;
01033         <span class="keywordflow">if</span> (fdi-&gt;out &lt; 0 || fdi-&gt;err) {
01034             outlog (<span class="stringliteral">"\nin %d bytes, out %d bits\n"</span>, fdi-&gt;track_src - fdi-&gt;track_src_buffer, fdi-&gt;out);
01035             <span class="keywordflow">return</span> -1;
01036         }
01037         <span class="keywordflow">if</span> (fdi-&gt;track_src - fdi-&gt;track_src_buffer &gt;= fdi-&gt;track_src_len) {
01038             outlog (<span class="stringliteral">"source buffer overrun, previous type: %02.2X\n"</span>, fdi-&gt;track_type);
01039             <span class="keywordflow">return</span> -1;
01040         }
01041     } <span class="keywordflow">while</span> (fdi-&gt;track_type != 0xff);
01042     outlog(<span class="stringliteral">"\n"</span>);
01043     fix_mfm_sync (fdi);
01044     <span class="keywordflow">return</span> fdi-&gt;out;
01045 }
01046 
01047 <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> fdiid[]={<span class="stringliteral">"Formatted Disk Image file"</span>};
01048 <span class="keyword">static</span> <span class="keywordtype">int</span> bit_rate_table[16] = { 125,150,250,300,500,1000 };
01049 
01050 <span class="keywordtype">void</span> fdi2raw_header_free (FDI *fdi)
01051 {
01052     free (fdi-&gt;mfmsync_buffer);
01053     fdi-&gt;mfmsync_buffer = 0;
01054     free (fdi-&gt;track_src_buffer);
01055     fdi-&gt;track_src_buffer = 0;
01056     free (fdi-&gt;track_dst_buffer);
01057     fdi-&gt;track_dst_buffer = 0;
01058     memset (fdi, 0, <span class="keyword">sizeof</span> (FDI));
01059 }
01060 
01061 <span class="keywordtype">int</span> fdi2raw_get_last_track (FDI *fdi)
01062 {
01063     <span class="keywordflow">return</span> fdi-&gt;last_track;
01064 }
01065 
01066 <span class="keywordtype">int</span> fdi2raw_get_last_head (FDI *fdi)
01067 {
01068     <span class="keywordflow">return</span> fdi-&gt;last_head;
01069 }
01070 
01071 <span class="keywordtype">int</span> fdi2raw_get_rotation (FDI *fdi)
01072 {
01073     <span class="keywordflow">return</span> fdi-&gt;rotation_speed;
01074 }
01075 
01076 <span class="keywordtype">int</span> fdi2raw_get_bit_rate (FDI *fdi)
01077 {
01078     <span class="keywordflow">return</span> fdi-&gt;bit_rate;
01079 }
01080 
01081 <span class="keywordtype">int</span> fdi2raw_get_type (FDI *fdi)
01082 {
01083     <span class="keywordflow">return</span> fdi-&gt;disk_type;
01084 }
01085 
01086 <span class="keywordtype">int</span> fdi2raw_get_write_protect (FDI *fdi)
01087 {
01088     <span class="keywordflow">return</span> fdi-&gt;write_protect;
01089 }
01090 
01091 FDI *fdi2raw_header(FILE *f)
01092 {
01093     <span class="keywordtype">int</span> i, offset, oldseek;
01094     uae_u8 type, size;
01095     FDI *fdi;
01096 
01097     fdi = (FDI *)malloc(<span class="keyword">sizeof</span>(FDI));
01098 
01099     fdi-&gt;file = f;
01100     oldseek = ftell (fdi-&gt;file);
01101     fseek (fdi-&gt;file, 0, SEEK_SET);
01102     fread (fdi-&gt;header, 512, 1, fdi-&gt;file);
01103     fseek (fdi-&gt;file, oldseek, SEEK_SET);
01104     <span class="keywordflow">if</span> (memcmp (fdiid, fdi-&gt;header, strlen (fdiid)) ) { free(fdi); <span class="keywordflow">return</span> NULL;}
01105     <span class="keywordflow">if</span> (fdi-&gt;header[140] != 1 || fdi-&gt;header[141] != 0) {free(fdi); <span class="keywordflow">return</span> NULL;}
01106 
01107     fdi-&gt;mfmsync_buffer = malloc (MAX_MFM_SYNC_BUFFER * <span class="keyword">sizeof</span>(<span class="keywordtype">int</span>));
01108     fdi-&gt;track_dst_buffer = malloc (MAX_DST_BUFFER);
01109     fdi-&gt;track_src_buffer = malloc (MAX_SRC_BUFFER);
01110     
01111     fdi-&gt;last_track = ((fdi-&gt;header[142] &lt;&lt; 8) + fdi-&gt;header[143]) + 1;
01112     fdi-&gt;last_track *= fdi-&gt;header[144] + 1;
01113     fdi-&gt;last_head = fdi-&gt;header[144];
01114     fdi-&gt;disk_type = fdi-&gt;header[145];
01115     fdi-&gt;rotation_speed = fdi-&gt;header[146] + 128;
01116     fdi-&gt;write_protect = fdi-&gt;header[147] &amp; 1;
01117     outlog (<span class="stringliteral">"last_track=%d rotation_speed=%d\n"</span>,fdi-&gt;last_track,fdi-&gt;rotation_speed);
01118 
01119     offset = 512;
01120     <span class="keywordflow">for</span> (i = 0; i &lt; fdi-&gt;last_track; i++) {
01121         fdi-&gt;track_offsets[i] = offset;
01122         type = fdi-&gt;header[152 + i * 2];
01123         size = fdi-&gt;header[152 + i * 2 + 1];
01124         <span class="keywordflow">if</span> (type == 1) offset += (size &amp; 15) * 512; <span class="keywordflow">else</span> offset += size * 256;
01125     }
01126     fdi-&gt;track_offsets[i] = offset;
01127 
01128     <span class="keywordflow">return</span> fdi;
01129 }
01130 
01131 
01132 uae_u8 *fdi2raw_read_track(FDI *fdi, <span class="keywordtype">int</span> track, <span class="keywordtype">int</span> *len)
01133 {
01134     uae_u8 *p;
01135     <span class="keywordtype">int</span> outlen;
01136 
01137     *len = -1;
01138     fdi-&gt;err = 0;
01139     fdi-&gt;track_src_len = fdi-&gt;track_offsets[track + 1] - fdi-&gt;track_offsets[track];
01140     memset (fdi-&gt;track_src_buffer, 0, MAX_SRC_BUFFER);
01141     fseek (fdi-&gt;file, fdi-&gt;track_offsets[track], SEEK_SET);
01142     fread (fdi-&gt;track_src_buffer, fdi-&gt;track_src_len, 1, fdi-&gt;file);
01143     memset (fdi-&gt;track_dst_buffer, 0, MAX_DST_BUFFER);
01144 
01145     fdi-&gt;current_track = track;
01146     fdi-&gt;track_src = fdi-&gt;track_src_buffer;
01147     fdi-&gt;track_dst = fdi-&gt;track_dst_buffer;
01148     p = fdi-&gt;header + 152 + fdi-&gt;current_track * 2;
01149     fdi-&gt;track_type = *p++;
01150     fdi-&gt;track_len = *p++;
01151     fdi-&gt;bit_rate = 0;
01152     fdi-&gt;out = 0;
01153     fdi-&gt;mfmsync_offset = 0;
01154 
01155     <span class="keywordflow">if</span> ((fdi-&gt;track_type &amp; 0xf0) == 0xf0 || (fdi-&gt;track_type &amp; 0xf0) == 0xe0)
01156         fdi-&gt;bit_rate = bit_rate_table[fdi-&gt;track_type &amp; 0x0f];
01157     <span class="keywordflow">else</span>
01158         fdi-&gt;bit_rate = 250;
01159 
01160     outlog (<span class="stringliteral">"track %d: srclen: %d track_type: %02.2X, bitrate: %d\n"</span>,fdi-&gt;current_track, fdi-&gt;track_src_len, fdi-&gt;track_type, fdi-&gt;bit_rate);
01161 
01162     <span class="keywordflow">if</span> ((fdi-&gt;track_type &amp; 0xf0) == 0xf0) {
01163 
01164         outlen = decode_raw_track (fdi);
01165 
01166     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((fdi-&gt;track_type &amp; 0xf0) == 0xe0) {
01167 
01168         outlen = handle_sectors_described_track (fdi);
01169 
01170     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ((fdi-&gt;track_type &amp; 0xf0)) {
01171 
01172         zxx (fdi);
01173         outlen = -1;
01174         
01175     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (fdi-&gt;track_type &lt; 0x10) {
01176 
01177         decode_normal_track[fdi-&gt;track_type](fdi);
01178         fix_mfm_sync (fdi);
01179         outlen = fdi-&gt;out;
01180 
01181     } <span class="keywordflow">else</span> {
01182 
01183         zxx (fdi);
01184         outlen = -1;
01185 
01186     }
01187 
01188     <span class="keywordflow">if</span> (fdi-&gt;err) outlen = -1;
01189     *len = outlen;
01190     <span class="keywordflow">return</span> fdi-&gt;track_dst_buffer;
01191 }
01192 
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:41 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

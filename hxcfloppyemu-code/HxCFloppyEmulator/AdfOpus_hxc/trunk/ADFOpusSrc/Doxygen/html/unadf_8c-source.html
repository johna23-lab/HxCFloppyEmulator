<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>unadf.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>unadf.c</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * unadf 1.0</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *</span>
00005 <span class="comment"> * tested under Linux and Win32</span>
00006 <span class="comment"> */</span>
00007 
00008 <span class="preprocessor">#define UNADF_VERSION "1.0"</span>
00009 <span class="preprocessor"></span>
00010 
00011 <span class="preprocessor">#include&lt;stdlib.h&gt;</span>
00012 <span class="preprocessor">#include&lt;errno.h&gt;</span>
00013 <span class="preprocessor">#include&lt;string.h&gt;</span>
00014 
00015 <span class="preprocessor">#include "adflib.h"</span>
00016 
00017 <span class="comment">/* The portable way used to create a directory is to call the MKDIR command via the</span>
00018 <span class="comment"> * system() function.</span>
00019 <span class="comment"> * It is used to create the 'dir1' directory, like the 'dir1/dir11' directory</span>
00020 <span class="comment"> */</span>
00021 
00022 <span class="comment">/* the portable way to check if a directory 'dir1' already exists i'm using is to</span>
00023 <span class="comment"> * do fopen('dir1','rb'). NULL is returned if 'dir1' doesn't exists yet, an handle instead</span>
00024 <span class="comment"> */</span>
00025 
00026 <span class="preprocessor">#define MKDIR "mkdir"</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#ifdef WIN32</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#define DIRSEP '\\'</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define DIRSEP '/'</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* WIN32 */</span>
00033 
00034 <span class="preprocessor">#define EXTBUFL 1024*8</span>
00035 <span class="preprocessor"></span>
00036 
00037 <span class="keywordtype">void</span> help()
00038 {
00039     puts(<span class="stringliteral">"unadf [-lrcsp -v n] dumpname.adf [files-with-path] [-d extractdir]"</span>);
00040     puts(<span class="stringliteral">"    -l : lists root directory contents"</span>);
00041     puts(<span class="stringliteral">"    -r : lists directory tree contents"</span>);
00042     puts(<span class="stringliteral">"    -c : use dircache data (must be used with -l)"</span>);
00043     puts(<span class="stringliteral">"    -s : display entries logical block pointer (must be used with -l)"</span>);
00044     putchar(<span class="charliteral">'\n'</span>);
00045     puts(<span class="stringliteral">"    -v n : mount volume #n instead of default #0 volume"</span>);
00046     putchar(<span class="charliteral">'\n'</span>);
00047     puts(<span class="stringliteral">"    -p : send extracted files to pipe (unadf -p dump.adf Pics/pic1.gif | xv -)"</span>);
00048     puts(<span class="stringliteral">"    -d dir : extract to 'dir' directory"</span>);
00049 }
00050 
00051 <span class="keywordtype">void</span> printEnt(<span class="keyword">struct</span> Volume *vol, <span class="keyword">struct</span> Entry* entry, <span class="keywordtype">char</span> *path, BOOL sect)
00052 {
00053     <span class="comment">/* do not print the links entries, ADFlib do not support them yet properly */</span>
00054     <span class="keywordflow">if</span> (entry-&gt;type==ST_LFILE || entry-&gt;type==ST_LDIR || entry-&gt;type==ST_LSOFT)
00055         <span class="keywordflow">return</span>;
00056 
00057     <span class="keywordflow">if</span> (entry-&gt;type==ST_DIR)
00058         printf(<span class="stringliteral">"         "</span>);
00059     <span class="keywordflow">else</span>
00060         printf(<span class="stringliteral">"%7ld  "</span>,entry-&gt;size);
00061 
00062     printf(<span class="stringliteral">"%4d/%02d/%02d  %2d:%02d:%02d "</span>,entry-&gt;year, entry-&gt;month, entry-&gt;days,
00063         entry-&gt;hour, entry-&gt;mins, entry-&gt;secs);
00064     <span class="keywordflow">if</span> (sect)
00065         printf(<span class="stringliteral">" %06ld "</span>,entry-&gt;sector);
00066 
00067     <span class="keywordflow">if</span> (strlen(path)&gt;0)
00068         printf(<span class="stringliteral">" %s/"</span>,path);
00069     <span class="keywordflow">else</span>
00070         printf(<span class="stringliteral">" "</span>);
00071     <span class="keywordflow">if</span> (entry-&gt;type==ST_DIR)
00072         printf(<span class="stringliteral">"%s/"</span>,entry-&gt;name);
00073     <span class="keywordflow">else</span>
00074         printf(<span class="stringliteral">"%s"</span>,entry-&gt;name);
00075     <span class="keywordflow">if</span> (entry-&gt;comment!=NULL &amp;&amp; strlen(entry-&gt;comment)&gt;0)
00076         printf(<span class="stringliteral">", %s"</span>,entry-&gt;comment);
00077     putchar(<span class="charliteral">'\n'</span>);
00078 
00079 }
00080 
00081 
00082 <span class="keywordtype">void</span> extractFile(<span class="keyword">struct</span> Volume *vol, <span class="keywordtype">char</span>* name, <span class="keywordtype">char</span>* path, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *extbuf,
00083     BOOL pflag, BOOL qflag)
00084 {
00085     <span class="keyword">struct </span>File *file;
00086     FILE* out;
00087     <span class="keywordtype">long</span> n;
00088     <span class="keywordtype">char</span> *filename;
00089 
00090     filename = NULL;
00091     <span class="keywordflow">if</span> (pflag)
00092         out = stdout;
00093     <span class="keywordflow">else</span> {
00094         <span class="keywordflow">if</span> (strlen(path)&gt;0) {
00095             filename=(<span class="keywordtype">char</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)* (strlen(path)+1+strlen(name)+1) );
00096             <span class="keywordflow">if</span> (!filename) <span class="keywordflow">return</span>;
00097             sprintf(filename,<span class="stringliteral">"%s%c%s"</span>,path,DIRSEP,name);
00098             out = fopen(filename, <span class="stringliteral">"wb"</span>);
00099         }
00100         <span class="keywordflow">else</span>
00101             out = fopen(name, <span class="stringliteral">"wb"</span>);
00102         <span class="keywordflow">if</span> (!out) <span class="keywordflow">return</span>;
00103     }
00104 
00105     file = adfOpenFile(vol, name, <span class="stringliteral">"r"</span>);
00106     <span class="keywordflow">if</span> (!file) { fclose(out); <span class="keywordflow">return</span>; }
00107 
00108     n = adfReadFile(file, EXTBUFL, extbuf);
00109     <span class="keywordflow">while</span>(!adfEndOfFile(file)) {
00110         fwrite(extbuf, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>), n, out);
00111         n = adfReadFile(file, EXTBUFL, extbuf);
00112     }
00113     <span class="keywordflow">if</span> (n&gt;0)
00114         fwrite(extbuf, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>), n, out);
00115 
00116     <span class="keywordflow">if</span> (!pflag)
00117         fclose(out);
00118 
00119     adfCloseFile(file);
00120 
00121     <span class="keywordflow">if</span> (!qflag) {
00122         <span class="keywordflow">if</span> (filename!=NULL)
00123             printf(<span class="stringliteral">"x - %s\n"</span>, filename);
00124         <span class="keywordflow">else</span>
00125             printf(<span class="stringliteral">"x - %s\n"</span>, name);
00126     }
00127     
00128     <span class="keywordflow">if</span> (filename!=NULL)
00129         free(filename);
00130 }
00131 
00132 
00133 <span class="keywordtype">void</span> extractTree(<span class="keyword">struct</span> Volume *vol, <span class="keyword">struct</span> List* tree, <span class="keywordtype">char</span> *path, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *extbuf,
00134     BOOL pflag, BOOL qflag)
00135 {
00136     <span class="keyword">struct </span>Entry* entry;
00137     <span class="keywordtype">char</span> *buf;
00138     <span class="keywordtype">char</span> sysbuf[200];
00139 
00140     <span class="keywordflow">while</span>(tree) {
00141         entry = (<span class="keyword">struct </span>Entry*)tree-&gt;content;
00142         <span class="keywordflow">if</span> (entry-&gt;type==ST_DIR) {
00143             buf = NULL;
00144             <span class="keywordflow">if</span> (strlen(path)&gt;0) {
00145                 buf=(<span class="keywordtype">char</span>*)malloc(strlen(path)+1+strlen(entry-&gt;name)+1);
00146                 <span class="keywordflow">if</span> (!buf) <span class="keywordflow">return</span>;
00147                 sprintf(buf,<span class="stringliteral">"%s%c%s"</span>,path,DIRSEP,entry-&gt;name);
00148                 sprintf(sysbuf,<span class="stringliteral">"%s %s"</span>,MKDIR,buf);
00149                 <span class="keywordflow">if</span> (!qflag) printf(<span class="stringliteral">"x - %s%c\n"</span>,buf,DIRSEP);
00150             }
00151             <span class="keywordflow">else</span> {
00152                 sprintf(sysbuf,<span class="stringliteral">"%s %s"</span>,MKDIR,entry-&gt;name);
00153                 <span class="keywordflow">if</span> (!qflag) printf(<span class="stringliteral">"x - %s%c\n"</span>,entry-&gt;name,DIRSEP);
00154             }
00155 
00156             <span class="keywordflow">if</span> (!pflag) system(sysbuf);
00157 
00158             <span class="keywordflow">if</span> (tree-&gt;subdir!=NULL) {
00159                 <span class="keywordflow">if</span> (adfChangeDir(vol,entry-&gt;name)==RC_OK) {
00160                     <span class="keywordflow">if</span> (buf!=NULL)
00161                         extractTree(vol,tree-&gt;subdir,buf,extbuf, pflag, qflag);
00162                     <span class="keywordflow">else</span>
00163                         extractTree(vol,tree-&gt;subdir,entry-&gt;name,extbuf, pflag, qflag);
00164                     adfParentDir(vol);
00165                 }
00166                 <span class="keywordflow">else</span> {
00167                     <span class="keywordflow">if</span> (strlen(path)&gt;0)
00168                         fprintf(stderr,<span class="stringliteral">"ExtractTree : dir \"%s/%s\" not found.\n"</span>,path,entry-&gt;name);
00169                     <span class="keywordflow">else</span>
00170                         fprintf(stderr,<span class="stringliteral">"ExtractTree : dir \"%s\" not found.\n"</span>,entry-&gt;name);
00171                 }
00172             }
00173 
00174             <span class="keywordflow">if</span> (buf!=NULL)
00175                 free(buf);
00176         }
00177         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (entry-&gt;type==ST_FILE) {
00178             extractFile(vol,entry-&gt;name,path,extbuf, pflag, qflag);
00179         }
00180         tree = tree-&gt;next;
00181     }
00182 }
00183 
00184 
00185 <span class="keywordtype">void</span> printTree(<span class="keyword">struct</span> Volume *vol, <span class="keyword">struct</span> List* tree, <span class="keywordtype">char</span>* path, BOOL sect)
00186 {
00187     <span class="keywordtype">char</span> *buf;
00188     <span class="keyword">struct </span>Entry* entry;
00189 
00190     <span class="keywordflow">while</span>(tree) {
00191         printEnt(vol, tree-&gt;content, path, sect);
00192         <span class="keywordflow">if</span> (tree-&gt;subdir!=NULL) {
00193             entry = (<span class="keyword">struct </span>Entry*)tree-&gt;content;
00194             <span class="keywordflow">if</span> (strlen(path)&gt;0) {
00195                 buf=(<span class="keywordtype">char</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>)* (strlen(path)+1+strlen(entry-&gt;name)+1) );
00196                 <span class="keywordflow">if</span> (!buf) {
00197                     fprintf(stderr,<span class="stringliteral">"printTree : malloc error\n"</span>);
00198                     <span class="keywordflow">return</span>;
00199                 }
00200                 sprintf(buf,<span class="stringliteral">"%s/%s"</span>, path, entry-&gt;name);
00201                 printTree(vol, tree-&gt;subdir, buf, sect);
00202                 free(buf);
00203             }
00204             <span class="keywordflow">else</span>
00205                 printTree(vol, tree-&gt;subdir, entry-&gt;name, sect);
00206         }
00207         tree = tree-&gt;next;
00208     }
00209 }
00210 
00211 
00212 <span class="keywordtype">void</span> printDev(<span class="keyword">struct</span> Device* dev)
00213 {
00214     printf(<span class="stringliteral">"Device : "</span>);
00215 
00216     <span class="keywordflow">switch</span>(dev-&gt;devType){
00217     <span class="keywordflow">case</span> DEVTYPE_FLOPDD:
00218         printf(<span class="stringliteral">"Floppy DD"</span>); <span class="keywordflow">break</span>;
00219     <span class="keywordflow">case</span> DEVTYPE_FLOPHD:
00220         printf(<span class="stringliteral">"Floppy HD"</span>); <span class="keywordflow">break</span>;
00221     <span class="keywordflow">case</span> DEVTYPE_HARDDISK:
00222         printf(<span class="stringliteral">"Harddisk"</span>); <span class="keywordflow">break</span>;
00223     <span class="keywordflow">case</span> DEVTYPE_HARDFILE:
00224         printf(<span class="stringliteral">"Hardfile"</span>); <span class="keywordflow">break</span>;
00225     <span class="keywordflow">default</span>:
00226         printf(<span class="stringliteral">"???"</span>); <span class="keywordflow">break</span>;
00227     }
00228 
00229     printf(<span class="stringliteral">". Cylinders = %ld, Heads = %ld, Sectors = %ld"</span>,dev-&gt;cylinders,dev-&gt;heads,dev-&gt;sectors);
00230 
00231     printf(<span class="stringliteral">". Volumes = %d\n"</span>,dev-&gt;nVol);
00232 }
00233 
00234 
00235 <span class="keywordtype">void</span> printVol(<span class="keyword">struct</span> Volume* vol, <span class="keywordtype">int</span> volNum)
00236 {
00237     printf(<span class="stringliteral">"Volume : "</span>);
00238     
00239     <span class="keywordflow">switch</span>(vol-&gt;dev-&gt;devType) {
00240     <span class="keywordflow">case</span> DEVTYPE_FLOPDD:
00241         printf (<span class="stringliteral">"Floppy 880 KBytes,"</span>);
00242         <span class="keywordflow">break</span>;
00243     <span class="keywordflow">case</span> DEVTYPE_FLOPHD:
00244         printf (<span class="stringliteral">"Floppy 1760 KBytes,"</span>);
00245         <span class="keywordflow">break</span>;
00246     <span class="keywordflow">case</span> DEVTYPE_HARDDISK:
00247         printf (<span class="stringliteral">"HD partition #%d %3.1f KBytes,"</span>, volNum, (vol-&gt;lastBlock - vol-&gt;firstBlock +1) * 512.0/1024.0);
00248         <span class="keywordflow">break</span>;
00249     <span class="keywordflow">case</span> DEVTYPE_HARDFILE:
00250         printf (<span class="stringliteral">"HardFile %3.1f KBytes,"</span>, (vol-&gt;lastBlock - vol-&gt;firstBlock +1) * 512.0/1024.0);
00251         <span class="keywordflow">break</span>;
00252     <span class="keywordflow">default</span>:
00253         printf (<span class="stringliteral">"???,"</span>);
00254     }
00255 
00256     <span class="keywordflow">if</span> (vol-&gt;volName!=NULL)
00257         printf(<span class="stringliteral">" \"%s\""</span>, vol-&gt;volName);
00258 
00259     printf(<span class="stringliteral">" between sectors [%ld-%ld]."</span>,vol-&gt;firstBlock, vol-&gt;lastBlock);
00260 
00261     printf(<span class="stringliteral">" %s "</span>,isFFS(vol-&gt;dosType) ? <span class="stringliteral">"FFS"</span> : <span class="stringliteral">"OFS"</span>);
00262     if (isINTL(vol-&gt;dosType))
00263         printf (<span class="stringliteral">"INTL "</span>);
00264     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType))
00265         printf (<span class="stringliteral">"DIRCACHE "</span>);
00266 
00267     printf(<span class="stringliteral">". Filled at %2.1f%%.\n"</span>, 100.0-
00268     (adfCountFreeBlocks(vol)*100.0)/(vol-&gt;lastBlock - vol-&gt;firstBlock +1) );
00269 
00270 }
00271 
00272 
00273 <span class="keywordtype">void</span> processFile(<span class="keyword">struct</span> Volume *vol, <span class="keywordtype">char</span>* name, <span class="keywordtype">char</span>* path, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *extbuf,
00274     BOOL pflag, BOOL qflag)
00275 {
00276     <span class="keywordtype">char</span> *sepptr, *cdstr, *fullname, *filename;
00277     <span class="keywordtype">char</span> *bigstr;
00278     FILE *tfile;
00279 
00280     adfToRootDir(vol);
00281 
00282     sepptr = strchr(name, <span class="charliteral">'/'</span>);
00283     <span class="keywordflow">if</span> (sepptr==NULL) {
00284         extractFile(vol, name, path, extbuf, pflag, qflag);
00285     }
00286     <span class="keywordflow">else</span> {
00287         <span class="comment">/* the all-in-one string : to call system(), to find the filename, the convert dir sep char ... */</span>
00288         bigstr=(<span class="keywordtype">char</span>*)malloc(strlen(MKDIR)+1+strlen(path)+1+strlen(name)+1);
00289         <span class="keywordflow">if</span> (!bigstr) { fprintf(stderr,<span class="stringliteral">"processFile : malloc"</span>); <span class="keywordflow">return</span>; }
00290 
00291         <span class="comment">/* to build to extract path */</span>
00292         <span class="keywordflow">if</span> (strlen(path)&gt;0) {
00293             sprintf(bigstr,<span class="stringliteral">"%s %s%c%s"</span>,MKDIR,path,DIRSEP,name);
00294             cdstr = bigstr+strlen(MKDIR)+1+strlen(path)+1;
00295         }
00296         <span class="keywordflow">else</span> {
00297             sprintf(bigstr,<span class="stringliteral">"%s %s"</span>,MKDIR,name);
00298             cdstr = bigstr+strlen(MKDIR)+1;
00299         }
00300         <span class="comment">/* the directory in which the file will be extracted */</span>
00301         fullname =  bigstr+strlen(MKDIR)+1;
00302 
00303         <span class="comment">/* finds the filename, and separates it from the path */</span>
00304         filename = strrchr(bigstr,<span class="charliteral">'/'</span>)+1;
00305         filename[-1]=<span class="charliteral">'\0'</span>;
00306 
00307         sepptr = cdstr;
00308         <span class="comment">/* find the end of the first dir to create */</span>
00309         <span class="keywordflow">while</span>(sepptr[0]!=<span class="charliteral">'/'</span> &amp;&amp; sepptr[0]!=<span class="charliteral">'\0'</span>)
00310             sepptr++;
00311 
00312         <span class="keywordflow">while</span>(strlen(cdstr)&gt;0) {
00313             <span class="keywordflow">if</span> (sepptr[0]==<span class="charliteral">'/'</span>) { <span class="comment">/* not the last one */</span>
00314                 sepptr[0]=<span class="charliteral">'\0'</span>;
00315                 <span class="keywordflow">if</span> (adfChangeDir(vol,cdstr)!=RC_OK)
00316                     <span class="keywordflow">return</span>;
00317                 tfile = fopen(fullname,<span class="stringliteral">"r"</span>); <span class="comment">/* the only portable way to test if the dir exists */</span>
00318                 <span class="keywordflow">if</span> (tfile==NULL) { <span class="comment">/* does't exist : create it */</span>
00319                     <span class="keywordflow">if</span> (!pflag) system(bigstr);
00320                     <span class="keywordflow">if</span> (!qflag) printf(<span class="stringliteral">"x - %s%c\n"</span>,fullname,DIRSEP);
00321                 }
00322                 <span class="keywordflow">else</span>
00323                     fclose(tfile);
00324                 sepptr[0] = DIRSEP; <span class="comment">/* converts the '/' to '/' or '\' */</span>
00325                 cdstr = sepptr+1; <span class="comment">/* next beginning of the next dir to create */</span>
00326                 <span class="comment">/* to find the end of the next dir */</span>
00327                 sepptr++;
00328                 <span class="keywordflow">while</span>(sepptr[0]!=<span class="charliteral">'/'</span> &amp;&amp; sepptr[0]!=<span class="charliteral">'\0'</span>)
00329                     sepptr++;
00330             }
00331             <span class="keywordflow">else</span> { <span class="comment">/* the last one */</span>
00332                 <span class="keywordflow">if</span> (adfChangeDir(vol,cdstr)!=RC_OK)
00333                     <span class="keywordflow">return</span>;
00334                 tfile = fopen(fullname,<span class="stringliteral">"r"</span>);
00335                 <span class="keywordflow">if</span> (tfile==NULL) {
00336                     <span class="keywordflow">if</span> (!pflag) system(bigstr);
00337                     <span class="keywordflow">if</span> (!qflag) printf(<span class="stringliteral">"x - %s%c\n"</span>,fullname,DIRSEP);
00338                 }
00339                 <span class="keywordflow">else</span>
00340                     fclose(tfile);
00341                 cdstr = cdstr+strlen(cdstr); <span class="comment">/* at the end, ends the while loop */</span>
00342             }
00343         }
00344         extractFile(vol, filename, fullname, extbuf, pflag, qflag);
00345 
00346         free(bigstr);
00347     }
00348 
00349 
00350 }
00351 
00352 
00353 <span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])
00354 {
00355     <span class="keywordtype">int</span> i, j;
00356     BOOL rflag, lflag, xflag, cflag, vflag, sflag, dflag, pflag, qflag;
00357     <span class="keyword">struct </span>List* files, *rtfiles;
00358     <span class="keywordtype">char</span> *devname, *dirname;
00359     <span class="keywordtype">char</span> strbuf[80];
00360     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *extbuf;
00361     <span class="keywordtype">int</span> vInd, dInd, fInd, aInd;
00362     BOOL nextArg;
00363 
00364     <span class="keyword">struct </span>Device *dev;
00365     <span class="keyword">struct </span>Volume *vol;
00366     <span class="keyword">struct </span>List *list, *cell;
00367     <span class="keywordtype">int</span> volNum;
00368     BOOL <span class="keyword">true</span> = TRUE;
00369 
00370     <span class="keywordflow">if</span> (argc&lt;2) {
00371         help();
00372         exit(0);
00373     }
00374 
00375     rflag = lflag = cflag = vflag = sflag = dflag = pflag = qflag = FALSE;
00376     vInd = dInd = fInd = aInd = -1;
00377     xflag = TRUE;
00378     dirname = NULL;
00379     devname = NULL;
00380     files = rtfiles = NULL;
00381     volNum = 0;
00382 
00383     fprintf(stderr,<span class="stringliteral">"unADF v%s : a unzip like for .ADF files, powered by ADFlib (v%s - %s)\n\n"</span>,
00384         UNADF_VERSION, adfGetVersionNumber(),adfGetVersionDate());
00385 
00386     <span class="comment">/* parse options */</span>
00387     i=1;
00388     <span class="keywordflow">while</span>(i&lt;argc) {
00389         <span class="keywordflow">if</span> (argv[i][0]==<span class="charliteral">'-'</span>) {
00390             j=1;
00391             nextArg = FALSE;
00392             <span class="keywordflow">while</span>(j&lt;(int)strlen(argv[i]) &amp;&amp; !nextArg) {
00393                 <span class="keywordflow">switch</span>(argv[i][j]) {
00394                 <span class="keywordflow">case</span> <span class="charliteral">'v'</span>:
00395                     vflag = TRUE;
00396                     <span class="keywordflow">if</span> ((i+1)&lt;(argc-1)) {
00397                         i++;
00398                         nextArg = TRUE;
00399                         errno = 0;
00400                         volNum = atoi(argv[i]);
00401                         <span class="keywordflow">if</span> (errno!=0 || volNum&lt;0) {
00402                             fprintf(stderr,<span class="stringliteral">"invalid volume number, aborting.\n"</span>);
00403                             exit(1);
00404                         }
00405                     }
00406                     <span class="keywordflow">else</span>
00407                         fprintf(stderr,<span class="stringliteral">"no volume number, -v option ignored.\n"</span>);
00408                     <span class="keywordflow">break</span>;
00409                 <span class="keywordflow">case</span> <span class="charliteral">'l'</span>: 
00410                     lflag = TRUE;
00411                     xflag = FALSE;
00412                     <span class="keywordflow">break</span>;
00413                 <span class="keywordflow">case</span> <span class="charliteral">'s'</span>: 
00414                     sflag = TRUE;
00415                     <span class="keywordflow">break</span>;
00416                 <span class="keywordflow">case</span> <span class="charliteral">'c'</span>: 
00417                     cflag = TRUE;
00418                     <span class="keywordflow">break</span>;
00419                 <span class="keywordflow">case</span> <span class="charliteral">'r'</span>:
00420                     rflag = TRUE;
00421                     <span class="keywordflow">break</span>;
00422                 <span class="keywordflow">case</span> <span class="charliteral">'d'</span>:
00423                     <span class="keywordflow">if</span> (devname!=NULL &amp;&amp; xflag &amp;&amp; (i+1)==(argc-1)) {
00424                         i++;
00425                         dirname = argv[i];
00426                         <span class="keywordflow">if</span> (dirname[strlen(dirname)-1]==DIRSEP)
00427                             dirname[strlen(dirname)-1]=<span class="charliteral">'\0'</span>;
00428                         nextArg = TRUE;
00429                         dflag = TRUE;
00430                     }
00431                     <span class="keywordflow">break</span>;
00432                 <span class="keywordflow">case</span> <span class="charliteral">'p'</span>:
00433                     <span class="keywordflow">if</span> (xflag) {
00434                         fprintf(stderr,<span class="stringliteral">"sending files to pipe.\n"</span>);
00435                         pflag = TRUE;
00436                         qflag = TRUE;
00437                     }
00438                     <span class="keywordflow">else</span>
00439                         fprintf(stderr,<span class="stringliteral">"-p option must be used with extraction, ignored.\n"</span>);
00440                     <span class="keywordflow">break</span>;
00441                 <span class="keywordflow">case</span> <span class="charliteral">'h'</span>:
00442                 <span class="keywordflow">default</span>:
00443                     help();
00444                     exit(0);
00445                 } <span class="comment">/* switch */</span>
00446             j++;
00447             } <span class="comment">/* while */</span>
00448         } <span class="comment">/* if */</span>
00449         <span class="keywordflow">else</span> {
00450             <span class="comment">/* the last non option string is taken as a filename */</span>
00451             <span class="keywordflow">if</span> (devname==NULL) <span class="comment">/* if the device name has been already given */</span>
00452                 devname = argv[i];
00453             <span class="keywordflow">else</span> {
00454                 <span class="keywordflow">if</span> (xflag) {
00455                     <span class="keywordflow">if</span> (rtfiles==NULL)
00456                         rtfiles = files = newCell(NULL, (<span class="keywordtype">void</span>*)argv[i]);
00457                     <span class="keywordflow">else</span>
00458                         files = newCell(files, (<span class="keywordtype">void</span>*)argv[i]);
00459                 }
00460                 <span class="keywordflow">else</span>
00461                     fprintf(stderr,<span class="stringliteral">"Must be used with extraction, ignored.\n"</span>);
00462             }
00463         }
00464         i++;
00465     } <span class="comment">/* while */</span>
00466 
00467     extbuf =(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)malloc(EXTBUFL*<span class="keyword">sizeof</span>(<span class="keywordtype">char</span>));
00468     <span class="keywordflow">if</span> (!extbuf) { fprintf(stderr,<span class="stringliteral">"malloc error\n"</span>); exit(1); }
00469 
00470     <span class="comment">/* initialize the library */</span>
00471     adfEnvInitDefault();
00472 
00473     dev = adfMountDev( devname,TRUE );
00474     <span class="keywordflow">if</span> (!dev) {
00475         sprintf(strbuf,<span class="stringliteral">"Can't mount the dump device '%s'.\n"</span>, devname);
00476         fprintf(stderr, strbuf);
00477         adfEnvCleanUp(); exit(1);
00478     }
00479     <span class="keywordflow">if</span> (!qflag)
00480         printDev(dev);
00481 
00482     <span class="keywordflow">if</span> (volNum&gt;=dev-&gt;nVol) {
00483         fprintf(stderr,<span class="stringliteral">"This device has only %d volume(s), aborting.\n"</span>,dev-&gt;nVol);
00484         exit(1);
00485     }
00486 
00487     vol = adfMount(dev, volNum, TRUE);
00488     <span class="keywordflow">if</span> (!vol) {
00489         adfUnMountDev(dev);
00490         fprintf(stderr, <span class="stringliteral">"Can't mount the volume\n"</span>);
00491         adfEnvCleanUp(); exit(1);
00492     }
00493 
00494     <span class="keywordflow">if</span> (!qflag) {
00495         printVol(vol, volNum);
00496         putchar(<span class="charliteral">'\n'</span>);
00497     }
00498 
00499     <span class="keywordflow">if</span> (cflag &amp;&amp; isDIRCACHE(vol-&gt;dosType) &amp;&amp; lflag) {
00500         adfChgEnvProp(PR_USEDIRC,&amp;<span class="keyword">true</span>);
00501         <span class="keywordflow">if</span> (!qflag)
00502             puts(<span class="stringliteral">"Using dir cache blocks."</span>);
00503     }
00504 
00505     <span class="keywordflow">if</span> (lflag) {
00506         <span class="keywordflow">if</span> (!rflag) {
00507             cell = list = adfGetDirEnt(vol,vol-&gt;curDirPtr);
00508             <span class="keywordflow">while</span>(cell) {
00509                 printEnt(vol,cell-&gt;content,<span class="stringliteral">""</span>, sflag);
00510                 cell = cell-&gt;next;
00511             }
00512             adfFreeDirList(list);
00513         } <span class="keywordflow">else</span> {
00514             cell = list = adfGetRDirEnt(vol,vol-&gt;curDirPtr,TRUE);
00515             printTree(vol,cell,<span class="stringliteral">""</span>, sflag);
00516             adfFreeDirList(list);
00517         }
00518     }<span class="keywordflow">else</span> <span class="keywordflow">if</span> (xflag) {
00519         <span class="keywordflow">if</span> (rtfiles!=NULL) {
00520             files = rtfiles;
00521             <span class="keywordflow">while</span>(files!=NULL) {
00522                 <span class="keywordflow">if</span> (dirname!=NULL)
00523                     processFile(vol, (<span class="keywordtype">char</span>*)files-&gt;content, dirname, extbuf, pflag, qflag);
00524                 <span class="keywordflow">else</span>
00525                     processFile(vol, (<span class="keywordtype">char</span>*)files-&gt;content, <span class="stringliteral">""</span>, extbuf, pflag, qflag);
00526                 files = files-&gt;next;
00527             }
00528             freeList(rtfiles);
00529         }
00530         <span class="keywordflow">else</span> {
00531             cell = list = adfGetRDirEnt(vol,vol-&gt;curDirPtr,TRUE);
00532             <span class="keywordflow">if</span> (dirname==NULL)
00533                 extractTree(vol, cell, <span class="stringliteral">""</span>, extbuf, pflag, qflag);
00534             <span class="keywordflow">else</span>
00535                 extractTree(vol, cell, dirname, extbuf, pflag, qflag);
00536             adfFreeDirList(list);
00537         }
00538     }
00539     <span class="keywordflow">else</span>
00540         help();
00541 
00542     free(extbuf);
00543 
00544     adfUnMount(vol);
00545     adfUnMountDev(dev);
00546 
00547     adfEnvCleanUp();
00548 
00549     <span class="keywordflow">return</span>(0);
00550 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:43 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

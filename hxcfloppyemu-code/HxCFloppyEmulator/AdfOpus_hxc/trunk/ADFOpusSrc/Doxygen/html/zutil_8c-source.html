<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>zutil.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>zutil.c</h1><div class="fragment"><pre>00001 <span class="comment">/* zutil.c -- target dependent utility functions for the compression library</span>
00002 <span class="comment"> * Copyright (C) 1995-2002 Jean-loup Gailly.</span>
00003 <span class="comment"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
00004 <span class="comment"> */</span>
00005 
00006 <span class="comment">/* @(#) $Id: zutil_8c-source.html,v 1.1 2002/11/14 01:50:05 garyjharris Exp $ */</span>
00007 
00008 <span class="preprocessor">#include "zutil.h"</span>
00009 
00010 <span class="keyword">struct </span>internal_state      {<span class="keywordtype">int</span> dummy;}; <span class="comment">/* for buggy compilers */</span>
00011 
00012 <span class="preprocessor">#ifndef STDC</span>
00013 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">void</span> exit OF((<span class="keywordtype">int</span>));
00014 <span class="preprocessor">#endif</span>
00015 <span class="preprocessor"></span>
00016 <span class="keyword">const</span> <span class="keywordtype">char</span> *z_errmsg[10] = {
00017 <span class="stringliteral">"need dictionary"</span>,     <span class="comment">/* Z_NEED_DICT       2  */</span>
00018 <span class="stringliteral">"stream end"</span>,          <span class="comment">/* Z_STREAM_END      1  */</span>
00019 <span class="stringliteral">""</span>,                    <span class="comment">/* Z_OK              0  */</span>
00020 <span class="stringliteral">"file error"</span>,          <span class="comment">/* Z_ERRNO         (-1) */</span>
00021 <span class="stringliteral">"stream error"</span>,        <span class="comment">/* Z_STREAM_ERROR  (-2) */</span>
00022 <span class="stringliteral">"data error"</span>,          <span class="comment">/* Z_DATA_ERROR    (-3) */</span>
00023 <span class="stringliteral">"insufficient memory"</span>, <span class="comment">/* Z_MEM_ERROR     (-4) */</span>
00024 <span class="stringliteral">"buffer error"</span>,        <span class="comment">/* Z_BUF_ERROR     (-5) */</span>
00025 <span class="stringliteral">"incompatible version"</span>,<span class="comment">/* Z_VERSION_ERROR (-6) */</span>
00026 <span class="stringliteral">""</span>};
00027 
00028 
00029 <span class="keyword">const</span> <span class="keywordtype">char</span> * ZEXPORT zlibVersion()
00030 {
00031     <span class="keywordflow">return</span> ZLIB_VERSION;
00032 }
00033 
00034 <span class="preprocessor">#ifdef DEBUG</span>
00035 <span class="preprocessor"></span>
00036 <span class="preprocessor">#  ifndef verbose</span>
00037 <span class="preprocessor"></span><span class="preprocessor">#    define verbose 0</span>
00038 <span class="preprocessor"></span><span class="preprocessor">#  endif</span>
00039 <span class="preprocessor"></span><span class="keywordtype">int</span> z_verbose = verbose;
00040 
00041 <span class="keywordtype">void</span> z_error (m)
00042     <span class="keywordtype">char</span> *m;
00043 {
00044     fprintf(stderr, <span class="stringliteral">"%s\n"</span>, m);
00045     exit(1);
00046 }
00047 <span class="preprocessor">#endif</span>
00048 <span class="preprocessor"></span>
00049 <span class="comment">/* exported to allow conversion of error code to string for compress() and</span>
00050 <span class="comment"> * uncompress()</span>
00051 <span class="comment"> */</span>
00052 <span class="keyword">const</span> <span class="keywordtype">char</span> * ZEXPORT zError(err)
00053     <span class="keywordtype">int</span> err;
00054 {
00055     <span class="keywordflow">return</span> ERR_MSG(err);
00056 }
00057 
00058 
00059 <span class="preprocessor">#ifndef HAVE_MEMCPY</span>
00060 <span class="preprocessor"></span>
00061 <span class="keywordtype">void</span> zmemcpy(dest, source, len)
00062     Bytef* dest;
00063     <span class="keyword">const</span> Bytef* source;
00064     uInt  len;
00065 {
00066     <span class="keywordflow">if</span> (len == 0) <span class="keywordflow">return</span>;
00067     <span class="keywordflow">do</span> {
00068         *dest++ = *source++; <span class="comment">/* ??? to be unrolled */</span>
00069     } <span class="keywordflow">while</span> (--len != 0);
00070 }
00071 
00072 <span class="keywordtype">int</span> zmemcmp(s1, s2, len)
00073     <span class="keyword">const</span> Bytef* s1;
00074     <span class="keyword">const</span> Bytef* s2;
00075     uInt  len;
00076 {
00077     uInt j;
00078 
00079     <span class="keywordflow">for</span> (j = 0; j &lt; len; j++) {
00080         <span class="keywordflow">if</span> (s1[j] != s2[j]) <span class="keywordflow">return</span> 2*(s1[j] &gt; s2[j])-1;
00081     }
00082     <span class="keywordflow">return</span> 0;
00083 }
00084 
00085 <span class="keywordtype">void</span> zmemzero(dest, len)
00086     Bytef* dest;
00087     uInt  len;
00088 {
00089     <span class="keywordflow">if</span> (len == 0) <span class="keywordflow">return</span>;
00090     <span class="keywordflow">do</span> {
00091         *dest++ = 0;  <span class="comment">/* ??? to be unrolled */</span>
00092     } <span class="keywordflow">while</span> (--len != 0);
00093 }
00094 <span class="preprocessor">#endif</span>
00095 <span class="preprocessor"></span>
00096 <span class="preprocessor">#ifdef __TURBOC__</span>
00097 <span class="preprocessor"></span><span class="preprocessor">#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) &amp;&amp; !defined(__32BIT__)</span>
00098 <span class="preprocessor"></span><span class="comment">/* Small and medium model in Turbo C are for now limited to near allocation</span>
00099 <span class="comment"> * with reduced MAX_WBITS and MAX_MEM_LEVEL</span>
00100 <span class="comment"> */</span>
00101 <span class="preprocessor">#  define MY_ZCALLOC</span>
00102 <span class="preprocessor"></span>
00103 <span class="comment">/* Turbo C malloc() does not allow dynamic allocation of 64K bytes</span>
00104 <span class="comment"> * and farmalloc(64K) returns a pointer with an offset of 8, so we</span>
00105 <span class="comment"> * must fix the pointer. Warning: the pointer must be put back to its</span>
00106 <span class="comment"> * original form in order to free it, use zcfree().</span>
00107 <span class="comment"> */</span>
00108 
00109 <span class="preprocessor">#define MAX_PTR 10</span>
00110 <span class="preprocessor"></span><span class="comment">/* 10*64K = 640K */</span>
00111 
00112 local <span class="keywordtype">int</span> next_ptr = 0;
00113 
00114 <span class="keyword">typedef</span> <span class="keyword">struct </span>ptr_table_s {
00115     voidpf org_ptr;
00116     voidpf new_ptr;
00117 } ptr_table;
00118 
00119 local ptr_table table[MAX_PTR];
00120 <span class="comment">/* This table is used to remember the original form of pointers</span>
00121 <span class="comment"> * to large buffers (64K). Such pointers are normalized with a zero offset.</span>
00122 <span class="comment"> * Since MSDOS is not a preemptive multitasking OS, this table is not</span>
00123 <span class="comment"> * protected from concurrent access. This hack doesn't work anyway on</span>
00124 <span class="comment"> * a protected system like OS/2. Use Microsoft C instead.</span>
00125 <span class="comment"> */</span>
00126 
00127 voidpf zcalloc (voidpf opaque, <span class="keywordtype">unsigned</span> items, <span class="keywordtype">unsigned</span> size)
00128 {
00129     voidpf buf = opaque; <span class="comment">/* just to make some compilers happy */</span>
00130     ulg bsize = (ulg)items*size;
00131 
00132     <span class="comment">/* If we allocate less than 65520 bytes, we assume that farmalloc</span>
00133 <span class="comment">     * will return a usable pointer which doesn't have to be normalized.</span>
00134 <span class="comment">     */</span>
00135     <span class="keywordflow">if</span> (bsize &lt; 65520L) {
00136         buf = farmalloc(bsize);
00137         <span class="keywordflow">if</span> (*(ush*)&amp;buf != 0) <span class="keywordflow">return</span> buf;
00138     } <span class="keywordflow">else</span> {
00139         buf = farmalloc(bsize + 16L);
00140     }
00141     <span class="keywordflow">if</span> (buf == NULL || next_ptr &gt;= MAX_PTR) <span class="keywordflow">return</span> NULL;
00142     table[next_ptr].org_ptr = buf;
00143 
00144     <span class="comment">/* Normalize the pointer to seg:0 */</span>
00145     *((ush*)&amp;buf+1) += ((ush)((uch*)buf-0) + 15) &gt;&gt; 4;
00146     *(ush*)&amp;buf = 0;
00147     table[next_ptr++].new_ptr = buf;
00148     <span class="keywordflow">return</span> buf;
00149 }
00150 
00151 <span class="keywordtype">void</span>  zcfree (voidpf opaque, voidpf ptr)
00152 {
00153     <span class="keywordtype">int</span> n;
00154     <span class="keywordflow">if</span> (*(ush*)&amp;ptr != 0) { <span class="comment">/* object &lt; 64K */</span>
00155         farfree(ptr);
00156         <span class="keywordflow">return</span>;
00157     }
00158     <span class="comment">/* Find the original pointer */</span>
00159     <span class="keywordflow">for</span> (n = 0; n &lt; next_ptr; n++) {
00160         <span class="keywordflow">if</span> (ptr != table[n].new_ptr) <span class="keywordflow">continue</span>;
00161 
00162         farfree(table[n].org_ptr);
00163         <span class="keywordflow">while</span> (++n &lt; next_ptr) {
00164             table[n-1] = table[n];
00165         }
00166         next_ptr--;
00167         <span class="keywordflow">return</span>;
00168     }
00169     ptr = opaque; <span class="comment">/* just to make some compilers happy */</span>
00170     Assert(0, <span class="stringliteral">"zcfree: ptr not found"</span>);
00171 }
00172 <span class="preprocessor">#endif</span>
00173 <span class="preprocessor"></span><span class="preprocessor">#endif </span><span class="comment">/* __TURBOC__ */</span>
00174 
00175 
00176 <span class="preprocessor">#if defined(M_I86) &amp;&amp; !defined(__32BIT__)</span>
00177 <span class="preprocessor"></span><span class="comment">/* Microsoft C in 16-bit mode */</span>
00178 
00179 <span class="preprocessor">#  define MY_ZCALLOC</span>
00180 <span class="preprocessor"></span>
00181 <span class="preprocessor">#if (!defined(_MSC_VER) || (_MSC_VER &lt;= 600))</span>
00182 <span class="preprocessor"></span><span class="preprocessor">#  define _halloc  halloc</span>
00183 <span class="preprocessor"></span><span class="preprocessor">#  define _hfree   hfree</span>
00184 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00185 <span class="preprocessor"></span>
00186 voidpf zcalloc (voidpf opaque, <span class="keywordtype">unsigned</span> items, <span class="keywordtype">unsigned</span> size)
00187 {
00188     <span class="keywordflow">if</span> (opaque) opaque = 0; <span class="comment">/* to make compiler happy */</span>
00189     <span class="keywordflow">return</span> _halloc((<span class="keywordtype">long</span>)items, size);
00190 }
00191 
00192 <span class="keywordtype">void</span>  zcfree (voidpf opaque, voidpf ptr)
00193 {
00194     <span class="keywordflow">if</span> (opaque) opaque = 0; <span class="comment">/* to make compiler happy */</span>
00195     _hfree(ptr);
00196 }
00197 
00198 <span class="preprocessor">#endif </span><span class="comment">/* MSC */</span>
00199 
00200 
00201 <span class="preprocessor">#ifndef MY_ZCALLOC </span><span class="comment">/* Any system without a special alloc function */</span>
00202 
00203 <span class="preprocessor">#ifndef STDC</span>
00204 <span class="preprocessor"></span><span class="keyword">extern</span> voidp  calloc OF((uInt items, uInt size));
00205 <span class="keyword">extern</span> <span class="keywordtype">void</span>   free   OF((voidpf ptr));
00206 <span class="preprocessor">#endif</span>
00207 <span class="preprocessor"></span>
00208 voidpf zcalloc (opaque, items, size)
00209     voidpf opaque;
00210     <span class="keywordtype">unsigned</span> items;
00211     <span class="keywordtype">unsigned</span> size;
00212 {
00213     <span class="keywordflow">if</span> (opaque) items += size - size; <span class="comment">/* make compiler happy */</span>
00214     <span class="keywordflow">return</span> (voidpf)calloc(items, size);
00215 }
00216 
00217 <span class="keywordtype">void</span>  zcfree (opaque, ptr)
00218     voidpf opaque;
00219     voidpf ptr;
00220 {
00221     free(ptr);
00222     <span class="keywordflow">if</span> (opaque) <span class="keywordflow">return</span>; <span class="comment">/* make compiler happy */</span>
00223 }
00224 
00225 <span class="preprocessor">#endif </span><span class="comment">/* MY_ZCALLOC */</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:43 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

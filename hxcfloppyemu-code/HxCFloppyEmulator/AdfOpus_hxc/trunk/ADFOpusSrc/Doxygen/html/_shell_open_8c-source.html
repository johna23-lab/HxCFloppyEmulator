<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>ShellOpen.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>ShellOpen.c</h1><a href="_shell_open_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* ADF Opus Copyright 1998-2002 by </span>
00002 <span class="comment"> * Dan Sutherland &lt;dan@chromerhino.demon.co.uk&gt; and Gary Harris &lt;gharris@zip.com.au&gt;.   </span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * This code Copyright 2000 by Gary Harris.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> */</span>
00013 <span class="preprocessor">#include "shellopen.h"</span>
00014 <span class="preprocessor">#include &lt;string.h&gt;</span>
00015 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00016 <span class="preprocessor">#include &lt;direct.h&gt;</span>
00017 
00018 <span class="keywordtype">int</span> RegisterFileTypes(<span class="keywordtype">void</span>)
00019 <span class="comment">// Register Amiga Disk File types with Windows.</span>
00020 <span class="comment">// Input:  Nil.</span>
00021 <span class="comment">// Output: Returns success or failure.</span>
00022 {
00023     <span class="comment">// Array of strings describing Opus file types:</span>
00024     <span class="comment">// "file type key", "file type target key", "Description", "Icon index within AdfOpus.exe".</span>
00025     <span class="keywordtype">char</span>    *KeyArray[20] = {<span class="stringliteral">".adf"</span>, <span class="stringliteral">"ADFOpus.adf"</span>, <span class="stringliteral">"Amiga Disk File"</span>,            <span class="stringliteral">"12"</span>,
00026                              <span class="stringliteral">".adz"</span>, <span class="stringliteral">"ADFOpus.adz"</span>, <span class="stringliteral">"GZipped Amiga Disk File"</span>,    <span class="stringliteral">"13"</span>,
00027                              <span class="stringliteral">".dms"</span>, <span class="stringliteral">"ADFOpus.dms"</span>, <span class="stringliteral">"DiskMashed Amiga Disk File"</span>, <span class="stringliteral">"14"</span>,
00028                              <span class="stringliteral">".hdf"</span>, <span class="stringliteral">"ADFOpus.hdf"</span>, <span class="stringliteral">"Amiga Hard Disk File"</span>,       <span class="stringliteral">"15"</span>,
00029                              <span class="stringliteral">".dmp"</span>, <span class="stringliteral">"ADFOpus.dmp"</span>, <span class="stringliteral">"Amiga Hard Disk Dump File"</span>,  <span class="stringliteral">"16"</span>};
00030     <span class="keywordtype">int</span>         iNumKeys = 20;
00031     <span class="keywordtype">int</span>         i;
00032     <span class="keywordtype">char</span>        szError[100];
00033 
00034 
00035     getcwd(szOpusPath, MAX_PATH);                   <span class="comment">// Get the path to ADF Opus.</span>
00036     strcat(szOpusPath, <span class="stringliteral">"\\ADFOpus.exe"</span>);
00037 
00038     <span class="keywordflow">for</span>(i = 0;i &lt; iNumKeys;i=i+4){
00039         <span class="keywordflow">if</span>(CreateFileTypeKey(KeyArray[i], KeyArray[i+1]) != 0){
00040             sprintf(szError, <span class="stringliteral">"Error creating file type key \"%s\""</span>, KeyArray[i]);
00041             MessageBox(NULL, <span class="stringliteral">"ADF Opus"</span>, szError, IDOK);
00042             <span class="keywordflow">return</span>(-1);
00043         }
00044         <span class="keywordflow">if</span>(CreateFileTypeTargetKey(KeyArray[i+1], KeyArray[i+2], KeyArray[i+3]) != 0){
00045             sprintf(szError, <span class="stringliteral">"Error creating file type target key \"%s\""</span>, KeyArray[i+1]);
00046             MessageBox(NULL, <span class="stringliteral">"ADF Opus"</span>, szError, IDOK);
00047             <span class="keywordflow">return</span>(-1);
00048         }
00049     }
00050     
00051     <span class="keywordflow">return</span>(0);
00052 }
00053 
00054 
00056 
00057 <span class="keywordtype">long</span> CreateFileTypeKey(<span class="keywordtype">char</span> *szFileType, <span class="keywordtype">char</span> *szFileTypeTarget)
00058 <span class="comment">// Creates registry keys for Amiga file types .adf, .adz, .dms, .hdf and .dmp.</span>
00059 <span class="comment">// Input:  Receives file type and target key strings from the master key array.</span>
00060 <span class="comment">// Output: Returns a long value which is either an error code returned by RegCreateKeyEx()</span>
00061 <span class="comment">//         or RegSetValueEx() or 0 on success.</span>
00062 {
00063     <span class="keywordtype">char</span>        szClass[] = <span class="stringliteral">"Amiga Disk File"</span>;      <span class="comment">// String values.</span>
00064     CONST BYTE  *lpKeyData = szFileTypeTarget;
00065     HKEY        hkResult;
00066     HKEY        *phkResult = &amp;hkResult;
00067     DWORD       dwDisposition;
00068     LPDWORD     lpdwDisposition = &amp;dwDisposition;
00069     DWORD       cbData;
00070     <span class="keywordtype">long</span>        lRetVal;
00071 
00072     <span class="comment">// Create file type key. </span>
00073     cbData = strlen(szFileTypeTarget) + 1;
00074     lRetVal = RegCreateKeyEx(HKEY_CLASSES_ROOT,     <span class="comment">// handle to an open key</span>
00075                             szFileType,             <span class="comment">// address of subkey name</span>
00076                             0,                      <span class="comment">// reserved</span>
00077                             szClass,                <span class="comment">// address of class string</span>
00078                             REG_OPTION_NON_VOLATILE,<span class="comment">// special options flag</span>
00079                             KEY_ALL_ACCESS,         <span class="comment">// desired security access</span>
00080                             NULL,                   <span class="comment">// address of key security structure</span>
00081                             phkResult,              <span class="comment">// address of buffer for opened handle</span>
00082                             lpdwDisposition);       <span class="comment">// address of disposition value buffer</span>
00083                                     
00084     <span class="comment">// Check for error condition.</span>
00085     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00086         RegCloseKey(hkResult);                      <span class="comment">// Close the open key.</span>
00087         <span class="keywordflow">return</span>(lRetVal);
00088     }
00089         
00090     lRetVal = RegSetValueEx(hkResult,               <span class="comment">// handle to key to set value for</span>
00091                             NULL,                   <span class="comment">// name of the value to set</span>
00092                             0,                      <span class="comment">// reserved  </span>
00093                             REG_SZ,                 <span class="comment">// flag for value type</span>
00094                             szFileTypeTarget,       <span class="comment">// address of value data</span>
00095                             cbData);                <span class="comment">// size of value data</span>
00096 
00097     <span class="comment">// Check for error condition.</span>
00098     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00099         RegCloseKey(hkResult);                      <span class="comment">// Close the open key.</span>
00100         <span class="keywordflow">return</span>(lRetVal);
00101     }
00102 
00103     RegCloseKey(hkResult);                          <span class="comment">// Close the open key.</span>
00104     <span class="keywordflow">return</span>(0);                                      <span class="comment">// Return success.</span>
00105 }
00106 
00107 
00108 <span class="keywordtype">long</span> CreateFileTypeTargetKey(<span class="keywordtype">char</span> *szFileTypeTarget, <span class="keywordtype">char</span> *szDescription, <span class="keywordtype">char</span> *szIconID)
00109 <span class="comment">// This function creates target registry keys for the file type subkeys</span>
00110 <span class="comment">// e.g. ADFOpus.adf for the .adf file type key.</span>
00111 <span class="comment">// Input:  Target key name, file description and icon index number strings from the</span>
00112 <span class="comment">//         master key array.</span>
00113 <span class="comment">// Output: Returns a long value which is either an error code returned by RegCreateKeyEx()</span>
00114 <span class="comment">//         or RegSetValueEx() or 0 on success.</span>
00115 {
00116     <span class="keyword">const</span> <span class="keywordtype">char</span>  lpOpenLine[] = <span class="stringliteral">"&amp;Open with ADF Opus"</span>;
00117     <span class="keyword">const</span> <span class="keywordtype">char</span>  lpIconSubKey[] = <span class="stringliteral">"DefaultIcon"</span>;         <span class="comment">// Subkeys.</span>
00118     <span class="keyword">const</span> <span class="keywordtype">char</span>  lpShellSubKey[] = <span class="stringliteral">"shell"</span>;
00119     <span class="keyword">const</span> <span class="keywordtype">char</span>  lpOpenSubKey[] = <span class="stringliteral">"open"</span>;
00120     <span class="keyword">const</span> <span class="keywordtype">char</span>  lpCommandSubKey[] = <span class="stringliteral">"command"</span>;
00121 
00122     <span class="keywordtype">char</span>        szIconPath[MAX_PATH];
00123     <span class="keywordtype">char</span>        szCommandLine[MAX_PATH];
00124     CONST BYTE  *lpDescription = szDescription;
00125     CONST BYTE  *lpIconPath = szIconPath;
00126     CONST BYTE  *lpOpenLineData = lpOpenLine;
00127     CONST BYTE  *lpCommandLineData = szCommandLine;
00128 
00129     HKEY        hkResult1, hkResult2, hkResult3, hkResult4;
00130     HKEY        *phkResult1 = &amp;hkResult1, *phkResult2 = &amp;hkResult2,
00131                 *phkResult3 = &amp;hkResult3, *phkResult4 = &amp;hkResult4;
00132     DWORD       dwDisposition;
00133     LPDWORD     lpdwDisposition = &amp;dwDisposition;
00134     DWORD       cbData;
00135     <span class="keywordtype">long</span>        lRetVal;
00136 
00137     
00138     <span class="comment">// Build the command line.</span>
00139     strcpy(szCommandLine, szOpusPath);
00140     strcat(szCommandLine, <span class="stringliteral">" %1"</span>);
00141     
00142     <span class="comment">// Create the icon path string.</span>
00143     strcpy(szIconPath, szOpusPath); 
00144     strcat(szIconPath, <span class="stringliteral">","</span>);
00145     strcat(szIconPath, szIconID);           
00146 
00147     <span class="comment">// Create target key for .xxx file type - "ADFOpus.xxx".</span>
00148     lRetVal = RegCreateKeyEx(HKEY_CLASSES_ROOT,     <span class="comment">// handle to an open key</span>
00149                            szFileTypeTarget,        <span class="comment">// address of subkey name</span>
00150                            0,                       <span class="comment">// reserved</span>
00151                            szDescription,           <span class="comment">// address of class string</span>
00152                            REG_OPTION_NON_VOLATILE, <span class="comment">// special options flag</span>
00153                            KEY_ALL_ACCESS,          <span class="comment">// desired security access</span>
00154                            NULL,                    <span class="comment">// address of key security structure</span>
00155                            phkResult1,              <span class="comment">// address of buffer for opened handle</span>
00156                            lpdwDisposition);        <span class="comment">// address of disposition value buffer);</span>
00157     <span class="comment">// Check for error condition.</span>
00158     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00159         RegCloseKey(hkResult1);                     <span class="comment">// Close the open key.</span>
00160         <span class="keywordflow">return</span>(lRetVal);
00161     }
00162 
00163 
00164     <span class="comment">// Set (default) to description of file type.</span>
00165     cbData = strlen(szDescription) + 1;
00166     lRetVal = RegSetValueEx(hkResult1,              <span class="comment">// handle to key to set value for</span>
00167                             NULL,                   <span class="comment">// name of the value to set</span>
00168                             0,                      <span class="comment">// reserved  </span>
00169                             REG_SZ,                 <span class="comment">// flag for value type</span>
00170                             lpDescription,          <span class="comment">// address of value data</span>
00171                             cbData);                <span class="comment">// size of value data</span>
00172     <span class="comment">// Check for error condition.</span>
00173     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00174         RegCloseKey(hkResult1);                     <span class="comment">// Close the open key.</span>
00175         <span class="keywordflow">return</span>(lRetVal);
00176     }
00177 
00178                  
00179     <span class="comment">// Create the "Default Icon" subkey.</span>
00180     lRetVal = RegCreateKeyEx(hkResult1,             <span class="comment">// handle to an open key</span>
00181                            lpIconSubKey,            <span class="comment">// address of subkey name</span>
00182                            0,                       <span class="comment">// reserved</span>
00183                            szDescription,           <span class="comment">// address of class string</span>
00184                            REG_OPTION_NON_VOLATILE, <span class="comment">// special options flag</span>
00185                            KEY_ALL_ACCESS,          <span class="comment">// desired security access</span>
00186                            NULL,                    <span class="comment">// address of key security structure</span>
00187                            phkResult2,              <span class="comment">// address of buffer for opened handle</span>
00188                            lpdwDisposition);        <span class="comment">// address of disposition value buffer);</span>
00189     <span class="comment">// Check for error condition.</span>
00190     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00191         RegCloseKey(hkResult1);                     <span class="comment">// Close the open keys.</span>
00192         RegCloseKey(hkResult2);
00193         <span class="keywordflow">return</span>(lRetVal);
00194     }
00195 
00196 
00197     <span class="comment">// Set default icon path.</span>
00198     cbData = strlen(szIconPath) + 1;
00199     lRetVal = RegSetValueEx(hkResult2,              <span class="comment">// handle to key to set value for</span>
00200                            NULL,                    <span class="comment">// name of the value to set</span>
00201                            0,                       <span class="comment">// reserved  </span>
00202                            REG_SZ,                  <span class="comment">// flag for value type</span>
00203                            szIconPath,              <span class="comment">// address of value data</span>
00204                            cbData);                 <span class="comment">// size of value data</span>
00205     <span class="comment">// Check for error condition.</span>
00206     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00207         RegCloseKey(hkResult1);                     <span class="comment">// Close the open keys.</span>
00208         RegCloseKey(hkResult2);
00209         <span class="keywordflow">return</span>(lRetVal);
00210     }
00211     
00212     RegCloseKey(hkResult2);                         <span class="comment">// Close the open key.</span>
00213 
00214     <span class="comment">// Create the "shell" subkey.</span>
00215     lRetVal = RegCreateKeyEx(hkResult1,             <span class="comment">// handle to an open key</span>
00216                            lpShellSubKey,           <span class="comment">// address of subkey name</span>
00217                            0,                       <span class="comment">// reserved</span>
00218                            szDescription,           <span class="comment">// address of class string</span>
00219                            REG_OPTION_NON_VOLATILE, <span class="comment">// special options flag</span>
00220                            KEY_ALL_ACCESS,          <span class="comment">// desired security access</span>
00221                            NULL,                    <span class="comment">// address of key security structure</span>
00222                            phkResult2,              <span class="comment">// address of buffer for opened handle</span>
00223                            lpdwDisposition);        <span class="comment">// address of disposition value buffer);</span>
00224     <span class="comment">// Check for error condition.</span>
00225     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00226         RegCloseKey(hkResult1);                     <span class="comment">// Close the open keys.</span>
00227         RegCloseKey(hkResult2);
00228         <span class="keywordflow">return</span>(lRetVal);
00229     }
00230 
00231     <span class="comment">// Create the "shell\open" subkey.</span>
00232     lRetVal = RegCreateKeyEx(hkResult2,             <span class="comment">// handle to an open key</span>
00233                            lpOpenSubKey,            <span class="comment">// address of subkey name</span>
00234                            0,                       <span class="comment">// reserved</span>
00235                            szDescription,           <span class="comment">// address of class string</span>
00236                            REG_OPTION_NON_VOLATILE, <span class="comment">// special options flag</span>
00237                            KEY_ALL_ACCESS,          <span class="comment">// desired security access</span>
00238                            NULL,                    <span class="comment">// address of key security structure</span>
00239                            phkResult3,              <span class="comment">// address of buffer for opened handle</span>
00240                            lpdwDisposition);        <span class="comment">// address of disposition value buffer);</span>
00241     <span class="comment">// Check for error condition.</span>
00242     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00243         RegCloseKey(hkResult1);                     <span class="comment">// Close the open keys.</span>
00244         RegCloseKey(hkResult2);
00245         RegCloseKey(hkResult3);
00246         <span class="keywordflow">return</span>(lRetVal);
00247     }
00248 
00249     <span class="comment">// Set the "open" command entry line.</span>
00250     cbData = strlen(lpOpenLine) + 1;
00251     lRetVal = RegSetValueEx(hkResult3,              <span class="comment">// handle to key to set value for</span>
00252                            NULL,                    <span class="comment">// name of the value to set</span>
00253                            0,                       <span class="comment">// reserved  </span>
00254                            REG_SZ,                  <span class="comment">// flag for value type</span>
00255                            lpOpenLineData,          <span class="comment">// address of value data</span>
00256                            cbData);                 <span class="comment">// size of value data</span>
00257     <span class="comment">// Check for error condition.</span>
00258     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00259         RegCloseKey(hkResult1);                     <span class="comment">// Close the open keys.</span>
00260         RegCloseKey(hkResult2);
00261         RegCloseKey(hkResult3);
00262         <span class="keywordflow">return</span>(lRetVal);
00263     }
00264     
00265     <span class="comment">// Create the "shell\open\command" subkey.</span>
00266     lRetVal = RegCreateKeyEx(hkResult3,             <span class="comment">// handle to an open key</span>
00267                             lpCommandSubKey,        <span class="comment">// address of subkey name</span>
00268                             0,                      <span class="comment">// reserved</span>
00269                             szDescription,          <span class="comment">// address of class string</span>
00270                             REG_OPTION_NON_VOLATILE, <span class="comment">// special options flag</span>
00271                             KEY_ALL_ACCESS,         <span class="comment">// desired security access</span>
00272                             NULL,                   <span class="comment">// address of key security structure</span>
00273                             phkResult4,             <span class="comment">// address of buffer for opened handle</span>
00274                             lpdwDisposition);       <span class="comment">// address of disposition value buffer);</span>
00275     <span class="comment">// Check for error condition.</span>
00276     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00277         RegCloseKey(hkResult1);                     <span class="comment">// Close the open keys.</span>
00278         RegCloseKey(hkResult2);
00279         RegCloseKey(hkResult3);
00280         RegCloseKey(hkResult4);
00281         <span class="keywordflow">return</span>(lRetVal);
00282     }
00283 
00284     <span class="comment">// Set the command line.</span>
00285     cbData = strlen(szCommandLine) + 1;
00286     lRetVal = RegSetValueEx(hkResult4,              <span class="comment">// handle to key to set value for</span>
00287                             NULL,                   <span class="comment">// name of the value to set</span>
00288                             0,                      <span class="comment">// reserved  </span>
00289                             REG_SZ,                 <span class="comment">// flag for value type</span>
00290                             lpCommandLineData,      <span class="comment">// address of value data</span>
00291                             cbData);                <span class="comment">// size of value data</span>
00292     <span class="comment">// Check for error condition.</span>
00293     <span class="keywordflow">if</span>(lRetVal != ERROR_SUCCESS){
00294         RegCloseKey(hkResult1);                     <span class="comment">// Close the open keys.</span>
00295         RegCloseKey(hkResult2);
00296         RegCloseKey(hkResult3);
00297         RegCloseKey(hkResult4);
00298         <span class="keywordflow">return</span>(lRetVal);
00299     }
00300     
00301     
00302     <span class="comment">// Close all open keys.</span>
00303     RegCloseKey(hkResult1);
00304     RegCloseKey(hkResult2);
00305     RegCloseKey(hkResult3);
00306     RegCloseKey(hkResult4);
00307     <span class="keywordflow">return</span>(0);
00308 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:42 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

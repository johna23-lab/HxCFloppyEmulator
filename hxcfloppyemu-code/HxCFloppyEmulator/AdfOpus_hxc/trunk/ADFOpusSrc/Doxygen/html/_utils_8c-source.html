<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Utils.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>Utils.c</h1><a href="_utils_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* ADF Opus Copyright 1998-2002 by </span>
00002 <span class="comment"> * Dan Sutherland &lt;dan@chromerhino.demon.co.uk&gt; and Gary Harris &lt;gharris@zip.com.au&gt;.   </span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> */</span>
00011 <span class="preprocessor">#include "Pch.h"</span>
00012 
00013 <span class="preprocessor">#include "ADFOpus.h"</span>
00014 <span class="preprocessor">#include "ChildCommon.h"</span>
00015 <span class="preprocessor">#include "ADF_raw.h"</span> <span class="comment">/* we shouldn't really be using this */</span>
00016 <span class="preprocessor">#include "ADF_Util.h"</span> <span class="comment">/* or this */</span>
00017 <span class="preprocessor">#include "Utils.h"</span>
00018 
00019 <span class="keyword">extern</span> <span class="keywordtype">char</span> gstrFileName[MAX_PATH * 2];
00020 <span class="keyword">extern</span> HWND ghwndFrame;
00021 <span class="keyword">extern</span> HWND ghwndMDIClient;
00022 <span class="keyword">extern</span> BOOL gbToolbarVisible;
00023 <span class="keyword">extern</span> BOOL gbStatusBarVisible;
00024 <span class="keyword">extern</span> HWND ghwndTB;
00025 <span class="keyword">extern</span> HWND ghwndSB;
00026 <span class="keyword">extern</span> BOOL ReadOnly;
00027 <span class="keyword">extern</span> BOOL bUndeleting;
00028 
00029 
<a name="l00030"></a><a class="code" href="_utils_8c.html#a9">00030</a> <span class="keywordtype">void</span> <a class="code" href="_utils_8c.html#a9">SizeToParent</a>(HWND hwndParent, HWND hwndControl)
00033 {
00034     RECT rec;
00035 
00036     GetClientRect(hwndParent, &amp;rec);
00037     MoveWindow(hwndControl, 0, 0, rec.right, rec.bottom, TRUE);
00038 }
00039 
00040 BOOL OpenDlg(HWND hwndOwner)
00041 {
00042     OPENFILENAME ofn;
00043     BOOL res;
00044 
00045     strcpy(gstrFileName, <span class="stringliteral">""</span>);
00046 
00047     ofn.lStructSize = <span class="keyword">sizeof</span>(OPENFILENAME);
00048     ofn.hwndOwner = hwndOwner;
00049     ofn.hInstance = NULL;
00050     ofn.lpstrFilter = <span class="stringliteral">"All supported types\0*.adf;*.adz;*.dms;*.hdf;*.dmp\0Amiga Disk Files (*.adf)\0*.adf\0Compressed Disk Files (*.adz)\0*.adz\0Diskmasher Files (*.dms)\0*.dms\0Hard Disk Files (*.hdf)\0*.hdf\0Device Dump Files (*.dmp)\0*.dmp\0All Files (*.*)\0*.*\0\0"</span>;
00051     ofn.lpstrCustomFilter = NULL;
00052     ofn.nMaxCustFilter = 0;
00053     ofn.lpstrFile = gstrFileName;
00054     ofn.nMaxFile = <span class="keyword">sizeof</span>(gstrFileName);
00055     ofn.lpstrFileTitle = NULL;
00056     ofn.lpstrInitialDir = NULL;
00057     ofn.lpstrTitle = <span class="stringliteral">"Open disk image"</span>;
00058     ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_SHAREAWARE;
00059     ofn.lpstrDefExt = NULL;
00060 
00061     res = GetOpenFileName(&amp;ofn);
00062     ReadOnly = (ofn.Flags &amp; OFN_READONLY);
00063     <span class="keywordflow">return</span> res;
00064 }
00065 
00066 <span class="keywordtype">void</span> SizeToStr(<span class="keyword">const</span> <span class="keywordtype">long</span> Size, <span class="keywordtype">char</span> *strBuf)
00067 <span class="comment">/* converts a number to a string containing size in KB */</span>
00068 {
00069     <span class="keywordtype">char</span> strTemp[40];
00070     <span class="keywordtype">long</span> lTemp = Size / 1024;
00071 
00072     lTemp = lTemp &gt; 0 ? lTemp : lTemp + 1;
00073     itoa(lTemp, strTemp, 10);
00074     AddCommas(strTemp);
00075     strcat(strTemp, <span class="stringliteral">"KB"</span>);
00076     strcpy(strBuf, strTemp);
00077     <span class="keywordflow">return</span>;
00078 }
00079 
00080 <span class="keywordtype">void</span> AddCommas(<span class="keywordtype">char</span> *strBuf)
00081 <span class="comment">/* adds commas to a numeric string.  this is old, lame code but it works */</span>
00082 {
00083     <span class="keywordtype">char</span> TempBuf[40] = <span class="stringliteral">""</span>;
00084     <span class="keywordtype">int</span> Pos = 0;
00085     <span class="keywordtype">int</span> i;
00086 
00087     <span class="keywordflow">if</span> (strlen(strBuf) &lt;= 3) <span class="keywordflow">return</span>;
00088 
00089     <span class="keywordflow">for</span> (i = strlen(strBuf) - 1 ; i &gt;= 0 ; i--) {
00090         TempBuf[Pos] = strBuf[i];
00091         Pos++;
00092         <span class="keywordflow">if</span> (((strlen(strBuf) - i) % 3 == 0) &amp;&amp; i &gt; 1) {
00093             TempBuf[Pos] = <span class="charliteral">','</span>;
00094             Pos++;
00095         }
00096     }
00097     TempBuf[Pos] = 0;
00098 
00099     Pos = 0;
00100     <span class="keywordflow">for</span> (i = strlen(TempBuf) - 1 ; i &gt;= 0 ; i--) {
00101         strBuf[Pos] = TempBuf[i];
00102         Pos++;
00103     }
00104     strBuf[Pos] = 0;
00105 }
00106 
00107 <span class="keywordtype">void</span> ResizeMDIClientWin()
00108 <span class="comment">/* resizes the MDI Client window to fit the frame window, including space for</span>
00109 <span class="comment"> * the toolbar and status bar where appropriate */</span>
00110 {
00111     RECT rFrm, rTB, rSB;
00112     <span class="keywordtype">long</span> lNewHeight;
00113 
00114     <span class="comment">/* get dimensions of frame window */</span>
00115     GetClientRect(ghwndFrame, &amp;rFrm);
00116     lNewHeight = rFrm.bottom - rFrm.top;
00117 
00118     <span class="comment">/* move top down by size of toolbar, if it is visible */</span>
00119     <span class="keywordflow">if</span> (gbToolbarVisible) {
00120         GetWindowRect(ghwndTB, &amp;rTB);
00121         rFrm.top += (rTB.bottom - rTB.top);
00122         lNewHeight -= (rTB.bottom - rTB.top);
00123     }
00124 
00125     <span class="keywordflow">if</span> (gbStatusBarVisible) {
00126         GetWindowRect(ghwndSB, &amp;rSB);
00127         lNewHeight -= (rSB.bottom - rSB.top);
00128     }
00129 
00130     MoveWindow(ghwndMDIClient, rFrm.left, rFrm.top, rFrm.right - rFrm.left, lNewHeight, TRUE);
00131 }
00132 
00133 
00134 <span class="keywordtype">void</span> SetMenuBitmaps(HINSTANCE hInst, HMENU hmenuMain)
00135 <span class="comment">// Set the menu item bitmaps.</span>
00136 {
00137     HBITMAP bmpMenu;
00138     HMENU   hsubmenuFile, hsubmenuView, hsubmenuAction, hsubmenuTools, hsubmenuWindow, hsubmenuHelp;
00139     <span class="keywordtype">int</span>     iBitmap;
00140     
00141     hsubmenuFile    = GetSubMenu(hmenuMain, 0);
00142     hsubmenuView    = GetSubMenu(hmenuMain, 2);
00143     hsubmenuAction  = GetSubMenu(hmenuMain, 3);
00144     hsubmenuTools   = GetSubMenu(hmenuMain, 4);
00145     hsubmenuWindow  = GetSubMenu(hmenuMain, 5);
00146     hsubmenuHelp    = GetSubMenu(hmenuMain, 6);
00147 
00148     <span class="comment">// Load menu bitmaps. Bitmap IDs range from IDB_NEW (206) to IDB_SHOWUNDELETABLE (226).</span>
00149     <span class="comment">// Cycling to IDB_SHOWUNDELETABLE + 1 prevents final bitmap being corrupted when bmpMenu</span>
00150     <span class="comment">// is released.</span>
00151     <span class="keywordflow">for</span>(iBitmap = IDB_NEW;iBitmap &lt;= IDB_SHOWUNDELETABLE + 1;iBitmap++){
00152 
00153         bmpMenu =  (HBITMAP)LoadImage(hInst, MAKEINTRESOURCE(iBitmap), IMAGE_BITMAP, 0, 0, 
00154                                       LR_DEFAULTSIZE|LR_DEFAULTCOLOR);<span class="comment">//LR_LOADTRANSPARENT);</span>
00155 
00156         <span class="keywordflow">switch</span>(iBitmap){
00157         <span class="comment">// File menu.</span>
00158         <span class="keywordflow">case</span> IDB_NEW:
00159             SetMenuItemBitmaps(hsubmenuFile, 0, MF_BYPOSITION, bmpMenu, bmpMenu);
00160             <span class="keywordflow">break</span>;
00161         <span class="keywordflow">case</span> IDB_OPEN:
00162             SetMenuItemBitmaps(hsubmenuFile, 1, MF_BYPOSITION, bmpMenu, bmpMenu);
00163             <span class="keywordflow">break</span>;
00164         <span class="keywordflow">case</span> IDB_CLOSE:
00165             SetMenuItemBitmaps(hsubmenuFile, 3, MF_BYPOSITION, bmpMenu, bmpMenu);
00166             <span class="keywordflow">break</span>;
00167         <span class="keywordflow">case</span> IDB_INFO:
00168             SetMenuItemBitmaps(hsubmenuFile, 5, MF_BYPOSITION, bmpMenu, bmpMenu);
00169             <span class="keywordflow">break</span>;
00170         <span class="comment">// View menu.</span>
00171         <span class="keywordflow">case</span> IDB_SHOWUNDELETABLE:
00172             SetMenuItemBitmaps(hsubmenuView, 1, MF_BYPOSITION, bmpMenu, bmpMenu);
00173             <span class="keywordflow">break</span>;
00174         <span class="comment">// Action menu.</span>
00175         <span class="keywordflow">case</span> IDB_UPONELEVEL:
00176             SetMenuItemBitmaps(hsubmenuAction, 0, MF_BYPOSITION, bmpMenu, bmpMenu);
00177             <span class="keywordflow">break</span>;
00178         <span class="keywordflow">case</span> IDB_CREATEDIR:
00179             SetMenuItemBitmaps(hsubmenuAction, 1, MF_BYPOSITION, bmpMenu, bmpMenu);
00180             <span class="keywordflow">break</span>;
00181         <span class="keywordflow">case</span> IDB_DELETE:
00182             SetMenuItemBitmaps(hsubmenuAction, 3, MF_BYPOSITION, bmpMenu, bmpMenu);
00183             <span class="keywordflow">break</span>;
00184         <span class="keywordflow">case</span> IDB_UNDELETE:
00185             SetMenuItemBitmaps(hsubmenuAction, 4, MF_BYPOSITION, bmpMenu, bmpMenu);
00186             <span class="keywordflow">break</span>;
00187         <span class="keywordflow">case</span> IDB_RENAME:
00188             SetMenuItemBitmaps(hsubmenuAction, 5, MF_BYPOSITION, bmpMenu, bmpMenu);
00189             <span class="keywordflow">break</span>;
00190         <span class="keywordflow">case</span> IDB_PROPERTIES:
00191             SetMenuItemBitmaps(hsubmenuAction, 6, MF_BYPOSITION, bmpMenu, bmpMenu);
00192             <span class="keywordflow">break</span>;
00193         <span class="comment">// Tools menu.</span>
00194         <span class="keywordflow">case</span> IDB_OPTIONS:
00195             SetMenuItemBitmaps(hsubmenuTools, 0, MF_BYPOSITION, bmpMenu, bmpMenu);
00196             <span class="keywordflow">break</span>;
00197         <span class="keywordflow">case</span> IDB_BATCH:
00198             SetMenuItemBitmaps(hsubmenuTools, 2, MF_BYPOSITION, bmpMenu, bmpMenu);
00199             <span class="keywordflow">break</span>;
00200         <span class="keywordflow">case</span> IDB_DISK2FDI:
00201             SetMenuItemBitmaps(hsubmenuTools, 3, MF_BYPOSITION, bmpMenu, bmpMenu);
00202             <span class="keywordflow">break</span>;
00203         <span class="keywordflow">case</span> IDB_INSTALL:
00204             SetMenuItemBitmaps(hsubmenuTools, 5, MF_BYPOSITION, bmpMenu, bmpMenu);
00205             <span class="keywordflow">break</span>;
00206         <span class="keywordflow">case</span> IDB_DISPLAY:
00207             SetMenuItemBitmaps(hsubmenuTools, 6, MF_BYPOSITION, bmpMenu, bmpMenu);
00208             <span class="keywordflow">break</span>;
00209         <span class="comment">// Window menu.</span>
00210         <span class="keywordflow">case</span> IDB_CASCADE:
00211             SetMenuItemBitmaps(hsubmenuWindow, 0, MF_BYPOSITION, bmpMenu, bmpMenu);
00212             <span class="keywordflow">break</span>;
00213         <span class="keywordflow">case</span> IDB_TILEHOR:
00214             SetMenuItemBitmaps(hsubmenuWindow, 1, MF_BYPOSITION, bmpMenu, bmpMenu);
00215             <span class="keywordflow">break</span>;
00216         <span class="keywordflow">case</span> IDB_TILEVER:
00217             SetMenuItemBitmaps(hsubmenuWindow, 2, MF_BYPOSITION, bmpMenu, bmpMenu);
00218             <span class="keywordflow">break</span>;
00219         <span class="comment">// Help menu.</span>
00220         <span class="keywordflow">case</span> IDB_HELP:
00221             SetMenuItemBitmaps(hsubmenuHelp, 0, MF_BYPOSITION, bmpMenu, bmpMenu);
00222             SetMenuItemBitmaps(hsubmenuHelp, 1, MF_BYPOSITION, bmpMenu, bmpMenu);
00223             <span class="keywordflow">break</span>;
00224         <span class="keywordflow">case</span> IDB_ABOUT:
00225             SetMenuItemBitmaps(hsubmenuHelp, 3, MF_BYPOSITION, bmpMenu, bmpMenu);
00226             <span class="keywordflow">break</span>;
00227         }
00228         
00229     }
00230     DeleteObject(bmpMenu);
00231 }
00232 
00233 
00234 <span class="keywordtype">void</span> UpdateMenuItems(HMENU menu)
00235 {
00236     <span class="comment">/* set new state to enable if there are any child windows open,</span>
00237 <span class="comment">           otherwise set it to grayed */</span>
00238     BOOL        isActive = ((HWND)SendMessage(ghwndMDIClient, WM_MDIGETACTIVE, 0, 0 ) != NULL);
00239     <span class="keywordtype">int</span>         iNewState = isActive ? MF_ENABLED : MF_GRAYED;
00240     <span class="keywordtype">int</span>         tempState;
00241     HWND        ac = (HWND)SendMessage(ghwndMDIClient, WM_MDIGETACTIVE, 0, 0);
00242     CHILDINFO   *ci = NULL;
00243     
00244 
00245     <span class="keywordflow">if</span>(isActive)
00246         ci = (CHILDINFO *)GetWindowLong(ac, 0);
00247 
00248     <span class="comment">/* file menu */</span>
00249     EnableMenuItem(menu, ID_FIL_CLOSE, iNewState);
00250     <span class="keywordflow">if</span>(ci == NULL)      <span class="comment">// Prevent error if no MDI window open.</span>
00251         EnableMenuItem(menu, ID_FIL_INFORMATION, MF_GRAYED);
00252     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ci-&gt;isAmi)                                      
00253         EnableMenuItem(menu, ID_FIL_INFORMATION, MF_ENABLED);
00254     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(ci != NULL)
00255         EnableMenuItem(menu, ID_FIL_INFORMATION, MF_GRAYED);
00256     
00257     <span class="comment">/* edit menu */</span>
00258     EnableMenuItem(menu, ID_EDIT_SELECTALL, iNewState);
00259     EnableMenuItem(menu, ID_EDIT_SELECTNONE, iNewState);
00260     EnableMenuItem(menu, ID_EDIT_INVERTSELECTION, iNewState);
00261 
00262     <span class="comment">/* view menu */</span>
00263     EnableMenuItem(menu, ID_VIEW_REFRESH, iNewState);
00264 <span class="comment">//  EnableMenuItem(menu, ID_VIEW_REFRESHALL, iNewState);</span>
00265 <span class="comment">//  EnableMenuItem(menu, ID_VIEW_CLONECURRENTWINDOW, MF_GRAYED);</span>
00266     <span class="keywordflow">if</span>(ci != NULL &amp;&amp; ci-&gt;isAmi &amp;&amp; !bUndeleting)
00267         EnableMenuItem(hMenu, ID_VIEW_SHOWUNDELETABLEFILES, MF_ENABLED);
00268 
00269     <span class="comment">/* action menu */</span>
00270 <span class="comment">//  EnableMenuItem(menu, ID_ACTION_UPONELEVEL, iNewState);</span>
00271     <span class="keywordflow">if</span>(isActive)
00272         EnableMenuItem(menu, ID_ACTION_UPONELEVEL, ci-&gt;atRoot == TRUE?MF_GRAYED:MF_ENABLED);
00273     <span class="keywordflow">else</span>
00274         EnableMenuItem(menu, ID_ACTION_UPONELEVEL, MF_GRAYED);
00275 
00276     <span class="comment">// If it's a DMS disable "Rename", "Delete" and "New Directory".</span>
00277     <span class="comment">// Checking for isActive avoids a failed access of unitialised ci-&gt;dfDisk.</span>
00278     <span class="keywordflow">if</span>(isActive &amp;&amp; ci-&gt;dfDisk == DMS){
00279         tempState = iNewState;
00280         iNewState = MF_GRAYED;
00281     }
00282     
00283     <span class="comment">// If we're in the drives window, disable the Delete, Rename and Make New Directory menu items.</span>
00284     <span class="keywordflow">if</span>(ci == NULL || strcmp(ci-&gt;curDir, <span class="stringliteral">""</span>) == 0){
00285         EnableMenuItem(menu, ID_ACTION_DELETE, MF_GRAYED);
00286         EnableMenuItem(menu, ID_ACTION_RENAME, MF_GRAYED);
00287         EnableMenuItem(menu, ID_ACTION_NEWDIRECTORY, MF_GRAYED);
00288     }
00289     <span class="comment">// If not an undeletable file, set as per iNewState.</span>
00290     <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!bUndeleting){
00291         EnableMenuItem(menu, ID_ACTION_NEWDIRECTORY, iNewState);
00292         EnableMenuItem(menu, ID_ACTION_DELETE, iNewState);
00293         EnableMenuItem(menu, ID_ACTION_RENAME, iNewState);
00294     }
00295     <span class="comment">// Restore iNewState state.</span>
00296     <span class="keywordflow">if</span>(isActive &amp;&amp; ci-&gt;dfDisk == DMS)
00297         iNewState = tempState;
00298     
00299     <span class="comment">/* tools menu */</span>
00300     EnableMenuItem(menu, ID_TOOLS_OPTIONS, MF_ENABLED);
00301     EnableMenuItem(menu, ID_TOOLS_INSTALL, MF_GRAYED);
00302     EnableMenuItem(menu, ID_TOOLS_DISPLAYBOOTBLOCK, MF_GRAYED);
00303 
00304     <span class="comment">// Check bootblock and enable "Install" menu item if not already bootable.</span>
00305     <span class="keywordflow">if</span>(ci != NULL &amp;&amp; ci-&gt;isAmi &amp;&amp; (ci-&gt;vol-&gt;bootCode != 1))
00306         EnableMenuItem(menu, ID_TOOLS_INSTALL, MF_ENABLED);
00307     <span class="comment">// Enable bootblock display if Ami lister.</span>
00308     <span class="keywordflow">if</span>(ci != NULL &amp;&amp; ci-&gt;isAmi)
00309         EnableMenuItem(menu, ID_TOOLS_DISPLAYBOOTBLOCK, MF_ENABLED);
00310 
00311 
00312     <span class="comment">/* window menu */</span> 
00313     EnableMenuItem(menu, ID_WIN_CASCADE, iNewState);
00314     EnableMenuItem(menu, ID_WIN_TILEVERTICAL, iNewState);
00315     EnableMenuItem(menu, ID_WIN_TILEHORIZONTAL, iNewState);
00316     EnableMenuItem(menu, ID_WIN_CLOSEALL, iNewState);
00317     EnableMenuItem(menu, ID_WIN_ARRANGEICONS, iNewState);
00318 }
00319 
00320 <span class="keywordtype">void</span> UpdateToolbar()
00321 <span class="comment">/* wait wait don't tell me...</span>
00322 <span class="comment"> */</span>
00323 {
00324     HWND        ac = (HWND)SendMessage(ghwndMDIClient, WM_MDIGETACTIVE, 0, 0);
00325     BOOL        isActive = (ac != NULL);
00326     BOOL        tempActive = FALSE;
00327     CHILDINFO   *ci = NULL;
00328 
00329     <span class="keywordflow">if</span> (isActive)
00330         ci = (CHILDINFO *)GetWindowLong(ac, 0);
00331 
00332     <span class="comment">/* enable/disable buttons that depend on whether a child window is active */</span>    
00333     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_FIL_CLOSE, MAKELONG(isActive, 0));
00334     
00335     <span class="comment">// If its a DMS disable "Rename", "Delete" and "New Directory".</span>
00336     <span class="comment">// Checking for isActive avoids a failed access of unitialised ci-&gt;dfDisk.</span>
00337     <span class="keywordflow">if</span>(isActive &amp;&amp; ci-&gt;dfDisk == DMS){
00338         tempActive = isActive;
00339         isActive = FALSE;
00340     }
00341 
00342     <span class="comment">// If we're in the drives window, disable the Delete, Rename and Make New Directory toolbar items.</span>
00343     <span class="keywordflow">if</span>(ci == NULL || strcmp(ci-&gt;curDir, <span class="stringliteral">""</span>) == 0){
00344         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_DELETE, MAKELONG(FALSE, 0));
00345         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_RENAME, MAKELONG(FALSE, 0));
00346         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_NEWDIRECTORY, MAKELONG(FALSE, 0));
00347     }
00348     <span class="keywordflow">else</span>{
00349         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_RENAME, MAKELONG(isActive, 0));
00350         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_DELETE, MAKELONG(isActive, 0));
00351         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_NEWDIRECTORY, MAKELONG(isActive, 0));
00352     }
00353     <span class="comment">// Restore isActive state.</span>
00354     <span class="keywordflow">if</span>(tempActive)
00355         isActive = tempActive;
00356 
00357     <span class="keywordflow">if</span>(isActive) {
00358         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_UPONELEVEL, MAKELONG(! ci-&gt;atRoot, 0));
00359         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_FIL_INFORMATION, MAKELONG(GetWindowLong(ac, GWL_USERDATA) == CHILD_AMILISTER, 0));
00360     }<span class="keywordflow">else</span>{
00361         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_UPONELEVEL, MAKELONG(FALSE, 0));
00362         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_FIL_INFORMATION, MAKELONG(isActive, 0));
00363     }
00364 
00365     <span class="comment">// View items.</span>
00366     <span class="keywordflow">if</span>(ci != NULL &amp;&amp; ci-&gt;isAmi &amp;&amp; !bUndeleting)
00367         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_VIEW_SHOWUNDELETABLEFILES, MAKELONG(TRUE, 0));
00368     <span class="keywordflow">else</span>
00369         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_VIEW_SHOWUNDELETABLEFILES, MAKELONG(FALSE, 0));
00370 
00371     <span class="comment">// Action items.</span>
00372     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_ACTION_UNDELETE, MAKELONG(FALSE, 0));
00373 
00374     <span class="comment">// Tools items.</span>
00375     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_TOOLS_INSTALL, MAKELONG(FALSE, 0));
00376     SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_TOOLS_DISPLAYBOOTBLOCK, MAKELONG(FALSE, 0));
00377 
00378     <span class="comment">// Check bootblock and enable "Install" menu item if not already bootable.</span>
00379     <span class="keywordflow">if</span>(ci != NULL &amp;&amp; ci-&gt;isAmi)<span class="comment">// &amp;&amp; (ci-&gt;vol-&gt;bootCode != 1))</span>
00380         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_TOOLS_INSTALL, MAKELONG(isActive, 0));
00381     <span class="comment">// Enable bootblock display if Ami lister.</span>
00382     <span class="keywordflow">if</span>(ci != NULL &amp;&amp; ci-&gt;isAmi)
00383         SendMessage(ghwndTB, TB_ENABLEBUTTON, ID_TOOLS_DISPLAYBOOTBLOCK, MAKELONG(isActive, 0));
00384 
00385 }
00386 
00387 <span class="keywordtype">int</span> CountOFNFiles(<span class="keywordtype">char</span> *lst, <span class="keywordtype">int</span> siz)
00388 <span class="comment">/* counts no of files in OFN filelist lst.  returns 1 if 1 file or no of files + 1</span>
00389 <span class="comment"> * if &gt; 1 file</span>
00390 <span class="comment"> */</span>
00391 {
00392     <span class="keywordtype">int</span> i, count = 0;
00393 
00394     <span class="keywordflow">for</span> (i = 0 ; i &lt; siz ; i++) {
00395         <span class="keywordflow">if</span> (lst[i] == 0) {
00396             count++;
00397             <span class="keywordflow">if</span> (lst[i + 1] == 0)
00398                 <span class="keywordflow">return</span> count;
00399         }
00400     }
00401     <span class="keywordflow">return</span> count;
00402 }
00403 
00404 <span class="keywordtype">void</span> GetOFNFile(<span class="keywordtype">char</span> *lst, <span class="keywordtype">int</span> no, <span class="keywordtype">char</span> *fil)
00405 <span class="comment">/* gets the noth file from an OFN filelist (path\0file1\0file2\0....)</span>
00406 <span class="comment"> */</span>
00407 {
00408     <span class="keywordtype">int</span> i = 0, count = 0;
00409 
00410     <span class="keywordflow">while</span> (count &lt; no) {
00411         <span class="keywordflow">if</span> (lst[i] == 0)
00412             count++;
00413         i++;
00414     }
00415 
00416     strcpy(fil, lst);
00417     strcat(fil, <span class="stringliteral">"\\"</span>);
00418     strcat(fil, lst + i);
00419 }
00420 
00421 <span class="preprocessor">#ifdef DEBUG_INFO</span>
00422 <span class="preprocessor"></span><span class="comment">// Debug info dialogue.</span>
00423 <span class="comment">// Activate  DEBUG_INFO in ADFOpus.h.</span>
00424 
00425 <span class="keywordtype">void</span> adfVolumeInfoWin(HWND hWnd, <span class="keyword">struct</span> Volume *vol)
00426 <span class="comment">// Windows version of adfVolumeInfo().</span>
00427 <span class="comment">// Input:  Receives a handle to the window on which to display the dialogue and a pointer</span>
00428 <span class="comment">//         to a ADFLib Volume structure.</span>
00429 <span class="comment">// Output: Nil. Displays a windows dialogue containing the disk file data.</span>
00430 {
00431     <span class="keywordtype">char</span>    szTemp[50], szAdfInfo[500];     <span class="comment">// Info string.</span>
00432     
00433     <span class="keyword">struct  </span>bRootBlock root;
00434     <span class="keywordtype">char</span>    diskName[35];
00435     <span class="keywordtype">int</span>     days,month,year;
00436     
00437     <span class="keywordflow">if</span> (adfReadRootBlock(vol, vol-&gt;rootBlock, &amp;root)!=RC_OK)
00438         <span class="keywordflow">return</span>;
00439     
00440     memset(diskName, 0, 35);
00441     memcpy(diskName, root.diskName, root.nameLen);
00442     
00443     sprintf(szAdfInfo, <span class="stringliteral">"Name : %-30s\n"</span>, vol-&gt;volName);
00444     strcat(szAdfInfo, <span class="stringliteral">"Type : "</span>);
00445     <span class="keywordflow">switch</span>(vol-&gt;dev-&gt;devType) {
00446         <span class="keywordflow">case</span> DEVTYPE_FLOPDD:
00447             strcat(szAdfInfo, <span class="stringliteral">"Floppy Double Density : 880 KBytes\n"</span>);
00448             <span class="keywordflow">break</span>;
00449         <span class="keywordflow">case</span> DEVTYPE_FLOPHD:
00450             strcat(szAdfInfo, <span class="stringliteral">"Floppy High Density : 1760 KBytes\n"</span>);
00451             <span class="keywordflow">break</span>;
00452         <span class="keywordflow">case</span> DEVTYPE_HARDDISK:
00453             sprintf(szTemp, <span class="stringliteral">"Hard Disk partition : %3.1f KBytes\n"</span>, 
00454                 (vol-&gt;lastBlock - vol-&gt;firstBlock +1) * 512.0/1024.0);
00455             strcat(szAdfInfo, szTemp);
00456             <span class="keywordflow">break</span>;
00457         <span class="keywordflow">case</span> DEVTYPE_HARDFILE:
00458             sprintf(szTemp, <span class="stringliteral">"HardFile : %3.1f KBytes\n"</span>, 
00459                 (vol-&gt;lastBlock - vol-&gt;firstBlock +1) * 512.0/1024.0);
00460             strcat(szAdfInfo, szTemp);
00461             <span class="keywordflow">break</span>;
00462         <span class="keywordflow">default</span>:
00463             strcat(szAdfInfo, <span class="stringliteral">"Unknown devType!\n"</span>);
00464     }
00465     strcat(szAdfInfo, <span class="stringliteral">"Filesystem : "</span>);
00466     sprintf(szTemp, <span class="stringliteral">"%s "</span>,isFFS(vol-&gt;dosType) ? <span class="stringliteral">"FFS"</span> : <span class="stringliteral">"OFS"</span>);
00467     strcat(szAdfInfo, szTemp);
00468     <span class="keywordflow">if</span> (isINTL(vol-&gt;dosType))
00469         strcat(szAdfInfo, <span class="stringliteral">"INTL "</span>);
00470     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType))
00471         strcat(szAdfInfo, <span class="stringliteral">"DIRCACHE "</span>);
00472     strcat(szAdfInfo, <span class="stringliteral">"\n"</span>);
00473 
00474     sprintf(szTemp, <span class="stringliteral">"Free blocks = %ld\n"</span>, adfCountFreeBlocks(vol));
00475     strcat(szAdfInfo, szTemp);
00476     <span class="keywordflow">if</span> (vol-&gt;readOnly)
00477         strcat(szAdfInfo, <span class="stringliteral">"Read only\n"</span>);
00478     <span class="keywordflow">else</span>
00479         strcat(szAdfInfo, <span class="stringliteral">"Read/Write\n"</span>);
00480     
00481     <span class="comment">/* created */</span>
00482     adfDays2Date(root.coDays, &amp;year, &amp;month, &amp;days);
00483     sprintf(szTemp, <span class="stringliteral">"created %d/%02d/%02d %ld:%02ld:%02ld\n"</span>,days,month,year,
00484         root.coMins/60,root.coMins%60,root.coTicks/50);
00485     strcat(szAdfInfo, szTemp);
00486     adfDays2Date(root.days, &amp;year, &amp;month, &amp;days);
00487     sprintf(szTemp, <span class="stringliteral">"last access %d/%02d/%02d %ld:%02ld:%02ld,   "</span>,days,month,year,
00488         root.mins/60,root.mins%60,root.ticks/50);
00489     strcat(szAdfInfo, szTemp);
00490     adfDays2Date(root.cDays, &amp;year, &amp;month, &amp;days);
00491     sprintf(szTemp, <span class="stringliteral">"%d/%02d/%02d %ld:%02ld:%02ld\n"</span>,days,month,year,
00492         root.cMins/60,root.cMins%60,root.cTicks/50);
00493     strcat(szAdfInfo, szTemp);
00494 
00495     MessageBox(hWnd, szAdfInfo, <span class="stringliteral">"Adf Info"</span>, MB_OK);
00496 }
00497 
00498 #endif
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:43 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

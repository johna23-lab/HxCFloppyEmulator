<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>adf_cache.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>adf_cache.c</h1><a href="adf__cache_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  ADF Library. (C) 1997-2002 Laurent Clevy</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> */</span>
00010 <span class="preprocessor">#include&lt;stdlib.h&gt;</span>
00011 <span class="preprocessor">#include&lt;string.h&gt;</span>
00012 
00013 <span class="preprocessor">#include"adf_defs.h"</span>
00014 <span class="preprocessor">#include"adf_str.h"</span>
00015 <span class="preprocessor">#include"adf_err.h"</span>
00016 <span class="preprocessor">#include"defendian.h"</span>
00017 <span class="preprocessor">#include"adf_cache.h"</span>
00018 <span class="preprocessor">#include"adf_raw.h"</span>
00019 <span class="preprocessor">#include"adf_disk.h"</span>
00020 <span class="preprocessor">#include"adf_bitm.h"</span>
00021 <span class="preprocessor">#include"adf_util.h"</span>
00022 <span class="preprocessor">#include"adf_dir.h"</span>
00023 
00024 
00025 <span class="keyword">extern</span> <span class="keyword">struct </span>Env adfEnv;
00026 <span class="comment">/*</span>
00027 <span class="comment">freeEntCache(struct CacheEntry *cEntry)</span>
00028 <span class="comment">{</span>
00029 <span class="comment">    if (cEntry-&gt;name!=NULL)</span>
00030 <span class="comment">        free(cEntry-&gt;name);</span>
00031 <span class="comment">    if (cEntry-&gt;comm!=NULL)</span>
00032 <span class="comment">        free(cEntry-&gt;comm);</span>
00033 <span class="comment">}</span>
00034 <span class="comment">*/</span>
00035 
00036 <span class="comment">/*</span>
00037 <span class="comment"> * adfGetDirEntCache</span>
00038 <span class="comment"> *</span>
00039 <span class="comment"> * replace 'adfGetDirEnt'. returns a the dir contents based on the dircache list</span>
00040 <span class="comment"> */</span>
00041 <span class="keyword">struct </span>List* adfGetDirEntCache(struct Volume *vol, SECTNUM dir, BOOL recurs)
00042 {
00043     <span class="keyword">struct </span>bEntryBlock parent;
00044     <span class="keyword">struct </span>bDirCacheBlock dirc;
00045     <span class="keywordtype">int</span> offset, n;
00046     <span class="keyword">struct </span>List *cell, *head;
00047     <span class="keyword">struct </span>CacheEntry caEntry;
00048     <span class="keyword">struct </span>Entry *entry;
00049     SECTNUM nSect;
00050 
00051     <span class="keywordflow">if</span> (adfReadEntryBlock(vol,dir,&amp;parent)!=RC_OK)
00052         <span class="keywordflow">return</span> NULL;
00053 
00054     nSect = parent.extension;
00055 
00056     cell = head = NULL;
00057     <span class="keywordflow">do</span> {
00058         <span class="comment">/* one loop per cache block */</span>
00059         n = offset = 0;
00060         <span class="keywordflow">if</span> (adfReadDirCBlock(vol, nSect, &amp;dirc)!=RC_OK)
00061             <span class="keywordflow">return</span> NULL;
00062         <span class="keywordflow">while</span> (n&lt;dirc.recordsNb) {
00063             <span class="comment">/* one loop per record */</span>
00064             entry = (<span class="keyword">struct </span>Entry*)malloc(sizeof(struct Entry));
00065             <span class="keywordflow">if</span> (!entry) {
00066                 adfFreeDirList(head);
00067                 <span class="keywordflow">return</span> NULL;
00068             }
00069             adfGetCacheEntry(&amp;dirc, &amp;offset, &amp;caEntry);
00070 
00071             <span class="comment">/* converts a cache entry into a dir entry */</span>
00072             entry-&gt;type = (int)caEntry.type;
00073             entry-&gt;name = strdup(caEntry.name);
00074             <span class="keywordflow">if</span> (entry-&gt;name==NULL) {
00075                 free(entry); adfFreeDirList(head);
00076                 <span class="keywordflow">return</span> NULL;
00077             }
00078             entry-&gt;sector = caEntry.header;
00079             entry-&gt;comment = strdup(caEntry.comm);
00080             <span class="keywordflow">if</span> (entry-&gt;comment==NULL) {
00081                 free(entry-&gt;name); adfFreeDirList(head);
00082                 <span class="keywordflow">return</span> NULL;
00083             }
00084             entry-&gt;size = caEntry.size;
00085             entry-&gt;access = caEntry.protect;
00086             adfDays2Date( caEntry.days, &amp;(entry-&gt;year), &amp;(entry-&gt;month), 
00087                 &amp;(entry-&gt;days) );
00088             entry-&gt;hour = caEntry.mins/60;
00089             entry-&gt;mins = caEntry.mins%60;
00090             entry-&gt;secs = caEntry.ticks/50;
00091 
00092             <span class="comment">/* add it into the linked list */</span>
00093             <span class="keywordflow">if</span> (head==NULL)
00094                 head = cell = newCell(NULL, (<span class="keywordtype">void</span>*)entry); 
00095             <span class="keywordflow">else</span>
00096                 cell = newCell(cell, (<span class="keywordtype">void</span>*)entry); 
00097 
00098             <span class="keywordflow">if</span> (cell==NULL) {
00099                 adfFreeEntry(entry);
00100                 adfFreeDirList(head);
00101                 <span class="keywordflow">return</span> NULL;
00102             }
00103 
00104             <span class="keywordflow">if</span> (recurs &amp;&amp; entry-&gt;type==ST_DIR)
00105                  cell-&gt;subdir = adfGetDirEntCache(vol,entry-&gt;sector,recurs);
00106 
00107             n++;
00108         }
00109         nSect = dirc.nextDirC;
00110     }<span class="keywordflow">while</span> (nSect!=0);
00111     
00112     <span class="keywordflow">return</span> head;    
00113 }
00114 
00115 
00116 
00117 <span class="comment">/*</span>
00118 <span class="comment"> * adfGetCacheEntry</span>
00119 <span class="comment"> *</span>
00120 <span class="comment"> * Returns a cache entry, starting from the offset p (the index into records[])</span>
00121 <span class="comment"> * This offset is updated to the end of the returned entry.</span>
00122 <span class="comment"> */</span>
00123 <span class="keywordtype">void</span> adfGetCacheEntry(<span class="keyword">struct</span> bDirCacheBlock *dirc, <span class="keywordtype">int</span> *p, <span class="keyword">struct</span> CacheEntry *cEntry)
00124 {
00125     <span class="keywordtype">int</span> ptr;
00126 
00127     ptr = *p;
00128 
00129 <span class="comment">/*printf("p=%d\n",ptr);*/</span>
00130 
00131 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00132 <span class="preprocessor"></span>    cEntry-&gt;header = swapLong(dirc-&gt;records+ptr);
00133     cEntry-&gt;size = swapLong(dirc-&gt;records+ptr+4);
00134     cEntry-&gt;protect = swapLong(dirc-&gt;records+ptr+8);
00135     cEntry-&gt;days = swapShort(dirc-&gt;records+ptr+16);
00136     cEntry-&gt;mins = swapShort(dirc-&gt;records+ptr+18);
00137     cEntry-&gt;ticks = swapShort(dirc-&gt;records+ptr+20);
00138 <span class="preprocessor">#else</span>
00139 <span class="preprocessor"></span>    cEntry-&gt;header = Long(dirc-&gt;records+ptr);
00140     cEntry-&gt;size = Long(dirc-&gt;records+ptr+4);
00141     cEntry-&gt;protect = Long(dirc-&gt;records+ptr+8);
00142     cEntry-&gt;days = Short(dirc-&gt;records+ptr+16);
00143     cEntry-&gt;mins = Short(dirc-&gt;records+ptr+18);
00144     cEntry-&gt;ticks = Short(dirc-&gt;records+ptr+20);
00145 <span class="preprocessor">#endif</span>
00146 <span class="preprocessor"></span>    cEntry-&gt;type =(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>) dirc-&gt;records[ptr+22];
00147 
00148     cEntry-&gt;nLen = dirc-&gt;records[ptr+23];
00149 <span class="comment">/*    cEntry-&gt;name = (char*)malloc(sizeof(char)*(cEntry-&gt;nLen+1));</span>
00150 <span class="comment">    if (!cEntry-&gt;name)</span>
00151 <span class="comment">         return;</span>
00152 <span class="comment">*/</span>    memcpy(cEntry-&gt;name, dirc-&gt;records+ptr+24, cEntry-&gt;nLen);
00153     cEntry-&gt;name[(int)(cEntry-&gt;nLen)]=<span class="charliteral">'\0'</span>;
00154 
00155     cEntry-&gt;cLen = dirc-&gt;records[ptr+24+cEntry-&gt;nLen];
00156     <span class="keywordflow">if</span> (cEntry-&gt;cLen&gt;0) {
00157 <span class="comment">/*        cEntry-&gt;comm =(char*)malloc(sizeof(char)*(cEntry-&gt;cLen+1));</span>
00158 <span class="comment">        if (!cEntry-&gt;comm) {</span>
00159 <span class="comment">            free( cEntry-&gt;name ); cEntry-&gt;name=NULL;</span>
00160 <span class="comment">            return;</span>
00161 <span class="comment">        }</span>
00162 <span class="comment">*/</span>        memcpy(cEntry-&gt;comm,dirc-&gt;records+ptr+24+cEntry-&gt;nLen+1,cEntry-&gt;cLen);
00163     }
00164         cEntry-&gt;comm[(int)(cEntry-&gt;cLen)]=<span class="charliteral">'\0'</span>;
00165 <span class="comment">/*printf("cEntry-&gt;nLen %d cEntry-&gt;cLen %d %s\n",cEntry-&gt;nLen,cEntry-&gt;cLen,cEntry-&gt;name);*/</span>
00166     *p  = ptr+24+cEntry-&gt;nLen+1+cEntry-&gt;cLen;
00167 
00168     <span class="comment">/* the starting offset of each record must be even (68000 constraint) */</span> 
00169     <span class="keywordflow">if</span> ((*p%2)!=0)
00170         *p=(*p)+1;
00171 }
00172 
00173 
00174 <span class="comment">/*</span>
00175 <span class="comment"> * adfPutCacheEntry</span>
00176 <span class="comment"> *</span>
00177 <span class="comment"> * remplaces one cache entry at the p offset, and returns its length</span>
00178 <span class="comment"> */</span>
00179 <span class="keywordtype">int</span> adfPutCacheEntry( <span class="keyword">struct</span> bDirCacheBlock *dirc, <span class="keywordtype">int</span> *p, <span class="keyword">struct</span> CacheEntry *cEntry)
00180 {
00181     <span class="keywordtype">int</span> ptr, l;
00182 
00183     ptr = *p;
00184 
00185 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00186 <span class="preprocessor"></span>    swLong(dirc-&gt;records+ptr, cEntry-&gt;header);
00187     swLong(dirc-&gt;records+ptr+4, cEntry-&gt;size);
00188     swLong(dirc-&gt;records+ptr+8, cEntry-&gt;protect);
00189     swShort(dirc-&gt;records+ptr+16, cEntry-&gt;days);
00190     swShort(dirc-&gt;records+ptr+18, cEntry-&gt;mins);
00191     swShort(dirc-&gt;records+ptr+20, cEntry-&gt;ticks);
00192 <span class="preprocessor">#else</span>
00193 <span class="preprocessor"></span>    memcpy(dirc-&gt;records+ptr,&amp;(cEntry-&gt;header),4);
00194     memcpy(dirc-&gt;records+ptr+4,&amp;(cEntry-&gt;size),4);
00195     memcpy(dirc-&gt;records+ptr+8,&amp;(cEntry-&gt;protect),4);
00196     memcpy(dirc-&gt;records+ptr+16,&amp;(cEntry-&gt;days),2);
00197     memcpy(dirc-&gt;records+ptr+18,&amp;(cEntry-&gt;mins),2);
00198     memcpy(dirc-&gt;records+ptr+20,&amp;(cEntry-&gt;ticks),2);
00199 <span class="preprocessor">#endif</span>
00200 <span class="preprocessor"></span>    dirc-&gt;records[ptr+22] =(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>)cEntry-&gt;type;
00201 
00202     dirc-&gt;records[ptr+23] = cEntry-&gt;nLen;
00203     memcpy(dirc-&gt;records+ptr+24, cEntry-&gt;name, cEntry-&gt;nLen);
00204 
00205     dirc-&gt;records[ptr+24+cEntry-&gt;nLen] = cEntry-&gt;cLen;
00206     memcpy(dirc-&gt;records+ptr+24+cEntry-&gt;nLen+1, cEntry-&gt;comm, cEntry-&gt;cLen);
00207 
00208 <span class="comment">/*puts("adfPutCacheEntry");*/</span>
00209 
00210     l = 25+cEntry-&gt;nLen+cEntry-&gt;cLen;
00211     <span class="keywordflow">if</span> ((l%2)==0)
00212         <span class="keywordflow">return</span> l;
00213     <span class="keywordflow">else</span> {
00214         dirc-&gt;records[ptr+l] =(char)0;
00215         <span class="keywordflow">return</span> l+1;
00216     }
00217 
00218     <span class="comment">/* ptr%2 must be == 0, if l%2==0, (ptr+l)%2==0 */</span> 
00219 }
00220 
00221 
00222 <span class="comment">/*</span>
00223 <span class="comment"> * adfEntry2CacheEntry</span>
00224 <span class="comment"> *</span>
00225 <span class="comment"> * converts one dir entry into a cache entry, and return its future length in records[]</span>
00226 <span class="comment"> */</span>
00227 <span class="keywordtype">int</span> adfEntry2CacheEntry(<span class="keyword">struct</span> bEntryBlock *entry, <span class="keyword">struct</span> CacheEntry *newEntry)
00228 {
00229     <span class="keywordtype">int</span> entryLen;
00230 
00231     <span class="comment">/* new entry */</span>
00232     newEntry-&gt;header = entry-&gt;headerKey;
00233     <span class="keywordflow">if</span> (entry-&gt;secType==ST_FILE)
00234         newEntry-&gt;size = entry-&gt;byteSize;
00235     <span class="keywordflow">else</span>
00236         newEntry-&gt;size = 0L;
00237     newEntry-&gt;protect = entry-&gt;access;
00238     newEntry-&gt;days = (short)entry-&gt;days;
00239     newEntry-&gt;mins = (short)entry-&gt;mins;
00240     newEntry-&gt;ticks  = (short)entry-&gt;ticks;
00241     newEntry-&gt;type = (<span class="keywordtype">signed</span> <span class="keywordtype">char</span>)entry-&gt;secType;
00242     newEntry-&gt;nLen = entry-&gt;nameLen;
00243     memcpy(newEntry-&gt;name, entry-&gt;name, newEntry-&gt;nLen);
00244     newEntry-&gt;name[(int)(newEntry-&gt;nLen)] = <span class="charliteral">'\0'</span>;
00245     newEntry-&gt;cLen = entry-&gt;commLen;
00246     <span class="keywordflow">if</span> (newEntry-&gt;cLen&gt;0)
00247         memcpy(newEntry-&gt;comm, entry-&gt;comment, newEntry-&gt;cLen);
00248 
00249     entryLen = 24+newEntry-&gt;nLen+1+newEntry-&gt;cLen;
00250 
00251 <span class="comment">/*printf("entry-&gt;name %d entry-&gt;comment %d\n",entry-&gt;nameLen,entry-&gt;commLen);</span>
00252 <span class="comment">printf("newEntry-&gt;nLen %d newEntry-&gt;cLen %d\n",newEntry-&gt;nLen,newEntry-&gt;cLen);</span>
00253 <span class="comment">*/</span>    <span class="keywordflow">if</span> ((entryLen%2)==0)
00254         <span class="keywordflow">return</span> entryLen;
00255     <span class="keywordflow">else</span>
00256         <span class="keywordflow">return</span> entryLen+1;
00257 }
00258 
00259 
00260 <span class="comment">/*</span>
00261 <span class="comment"> * adfDelFromCache</span>
00262 <span class="comment"> *</span>
00263 <span class="comment"> * delete one cache entry from its block. don't do 'records garbage collecting'</span>
00264 <span class="comment"> */</span>
00265 RETCODE adfDelFromCache(<span class="keyword">struct</span> Volume *vol, <span class="keyword">struct</span> bEntryBlock *parent, 
00266     SECTNUM headerKey)
00267 {
00268     <span class="keyword">struct </span>bDirCacheBlock dirc;
00269     SECTNUM nSect, prevSect;
00270     <span class="keyword">struct </span>CacheEntry caEntry;
00271     <span class="keywordtype">int</span> offset, oldOffset, n;
00272     BOOL found;
00273     <span class="keywordtype">int</span> entryLen;
00274     <span class="keywordtype">int</span> i;
00275     RETCODE rc = RC_OK;
00276 
00277     prevSect = -1;
00278     nSect = parent-&gt;extension;
00279     found = FALSE;
00280     <span class="keywordflow">do</span> {
00281         adfReadDirCBlock(vol, nSect, &amp;dirc);
00282         offset = 0; n = 0;
00283         <span class="keywordflow">while</span>(n &lt; dirc.recordsNb &amp;&amp; !found) {
00284             oldOffset = offset;
00285             adfGetCacheEntry(&amp;dirc, &amp;offset, &amp;caEntry);
00286             found = (caEntry.header==headerKey);
00287             <span class="keywordflow">if</span> (found) {
00288                 entryLen = offset-oldOffset;
00289                 <span class="keywordflow">if</span> (dirc.recordsNb&gt;1 || prevSect==-1) {
00290                     <span class="keywordflow">if</span> (n&lt;dirc.recordsNb-1) {
00291                         <span class="comment">/* not the last of the block : switch the following records */</span>
00292                         <span class="keywordflow">for</span>(i=oldOffset; i&lt;(488-entryLen); i++)
00293                             dirc.records[i] = dirc.records[i+entryLen];
00294                         <span class="comment">/* and clear the following bytes */</span>
00295                         <span class="keywordflow">for</span>(i=488-entryLen; i&lt;488; i++)
00296                             dirc.records[i] = 0;
00297                     }
00298                     <span class="keywordflow">else</span> {
00299                         <span class="comment">/* the last record of this cache block */</span>
00300                         <span class="keywordflow">for</span>(i=oldOffset; i&lt;offset; i++)
00301                             dirc.records[i] = 0;
00302                     }
00303                     dirc.recordsNb--;
00304                     <span class="keywordflow">if</span> (adfWriteDirCBlock(vol, dirc.headerKey, &amp;dirc)!=RC_OK)
00305                         <span class="keywordflow">return</span> -1;
00306                 }
00307                 <span class="keywordflow">else</span> {
00308                     <span class="comment">/* dirc.recordsNb ==1 or == 0 , prevSect!=-1 : </span>
00309 <span class="comment">                    * the only record in this dirc block and a previous dirc block exists </span>
00310 <span class="comment">                    */</span>
00311                     adfSetBlockFree(vol, dirc.headerKey);
00312                     adfReadDirCBlock(vol, prevSect, &amp;dirc);
00313                     dirc.nextDirC = 0L;
00314                     adfWriteDirCBlock(vol, prevSect, &amp;dirc);
00315 
00316                     adfUpdateBitmap(vol);
00317                 }
00318             }
00319             n++;
00320         }
00321         prevSect = nSect;
00322         nSect = dirc.nextDirC;
00323     }<span class="keywordflow">while</span>(nSect!=0 &amp;&amp; !found);
00324 
00325     <span class="keywordflow">if</span> (!found)
00326         (*adfEnv.wFct)(<span class="stringliteral">"adfUpdateCache : entry not found"</span>);
00327 
00328     <span class="keywordflow">return</span> rc;
00329 }
00330 
00331 
00332 <span class="comment">/*</span>
00333 <span class="comment"> * adfAddInCache</span>
00334 <span class="comment"> *</span>
00335 <span class="comment"> */</span>
00336 RETCODE adfAddInCache(<span class="keyword">struct</span> Volume *vol, <span class="keyword">struct</span> bEntryBlock *parent, 
00337     <span class="keyword">struct</span> bEntryBlock *entry)
00338 {
00339     <span class="keyword">struct </span>bDirCacheBlock dirc, newDirc;
00340     SECTNUM nSect, nCache;
00341     <span class="keyword">struct </span>CacheEntry caEntry, newEntry;
00342     <span class="keywordtype">int</span> offset, n;
00343     <span class="keywordtype">int</span> entryLen;
00344 
00345     entryLen = adfEntry2CacheEntry(entry, &amp;newEntry);
00346 <span class="comment">/*printf("adfAddInCache--%4ld %2d %6ld %8lx %4d %2d:%02d:%02d %30s %22s\n",</span>
00347 <span class="comment">    newEntry.header, newEntry.type, newEntry.size, newEntry.protect,</span>
00348 <span class="comment">    newEntry.days, newEntry.mins/60, newEntry.mins%60, </span>
00349 <span class="comment">    newEntry.ticks/50,</span>
00350 <span class="comment">    newEntry.name, newEntry.comm);</span>
00351 <span class="comment">*/</span>
00352     nSect = parent-&gt;extension;
00353     <span class="keywordflow">do</span> {
00354         <span class="keywordflow">if</span> (adfReadDirCBlock(vol, nSect, &amp;dirc)!=RC_OK)
00355             <span class="keywordflow">return</span> RC_ERROR;
00356         offset = 0; n = 0;
00357 <span class="comment">/*printf("parent=%4ld\n",dirc.parent);*/</span>
00358         <span class="keywordflow">while</span>(n &lt; dirc.recordsNb) {
00359             adfGetCacheEntry(&amp;dirc, &amp;offset, &amp;caEntry);
00360 <span class="comment">/*printf("*%4ld %2d %6ld %8lx %4d %2d:%02d:%02d %30s %22s\n",</span>
00361 <span class="comment">    caEntry.header, caEntry.type, caEntry.size, caEntry.protect,</span>
00362 <span class="comment">    caEntry.days, caEntry.mins/60, caEntry.mins%60, </span>
00363 <span class="comment">    caEntry.ticks/50,</span>
00364 <span class="comment">    caEntry.name, caEntry.comm);</span>
00365 <span class="comment">*/</span>
00366             n++;
00367         }
00368         
00369 <span class="comment">/*        if (offset+entryLen&lt;=488) {</span>
00370 <span class="comment">            adfPutCacheEntry(&amp;dirc, &amp;offset, &amp;newEntry);</span>
00371 <span class="comment">            dirc.recordsNb++;</span>
00372 <span class="comment">            adfWriteDirCBlock(vol, dirc.headerKey, &amp;dirc);</span>
00373 <span class="comment">            return rc;</span>
00374 <span class="comment">        }*/</span>
00375         nSect = dirc.nextDirC;
00376     }<span class="keywordflow">while</span>(nSect!=0);
00377 
00378     <span class="comment">/* in the last block */</span>
00379     <span class="keywordflow">if</span> (offset+entryLen&lt;=488) {
00380         adfPutCacheEntry(&amp;dirc, &amp;offset, &amp;newEntry);
00381         dirc.recordsNb++;
00382 <span class="comment">/*printf("entry name=%s\n",newEntry.name);*/</span>
00383     }
00384     <span class="keywordflow">else</span> {
00385         <span class="comment">/* request one new block free */</span>
00386         nCache = adfGet1FreeBlock(vol);
00387         <span class="keywordflow">if</span> (nCache==-1) {
00388            (*adfEnv.wFct)(<span class="stringliteral">"adfCreateDir : nCache==-1"</span>);
00389            <span class="keywordflow">return</span> RC_VOLFULL;
00390         }
00391 
00392         <span class="comment">/* create a new dircache block */</span>
00393         memset(&amp;newDirc,0,512);
00394         <span class="keywordflow">if</span> (parent-&gt;secType==ST_ROOT)
00395             newDirc.parent = vol-&gt;rootBlock;
00396         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parent-&gt;secType==ST_DIR)
00397             newDirc.parent = parent-&gt;headerKey;
00398         <span class="keywordflow">else</span>
00399             (*adfEnv.wFct)(<span class="stringliteral">"adfAddInCache : unknown secType"</span>);
00400         newDirc.recordsNb = 0L;
00401         newDirc.nextDirC = 0L;
00402 
00403         adfPutCacheEntry(&amp;dirc, &amp;offset, &amp;newEntry);
00404         newDirc.recordsNb++;
00405         <span class="keywordflow">if</span> (adfWriteDirCBlock(vol, nCache, &amp;newDirc)!=RC_OK)
00406             <span class="keywordflow">return</span> RC_ERROR;
00407         dirc.nextDirC = nCache;
00408     }
00409 <span class="comment">/*printf("dirc.headerKey=%ld\n",dirc.headerKey);*/</span>
00410     <span class="keywordflow">if</span> (adfWriteDirCBlock(vol, dirc.headerKey, &amp;dirc)!=RC_OK)
00411         <span class="keywordflow">return</span> RC_ERROR;
00412 <span class="comment">/*if (strcmp(entry-&gt;name,"file_5u")==0)</span>
00413 <span class="comment">dumpBlock(&amp;dirc);</span>
00414 <span class="comment">*/</span>
00415     <span class="keywordflow">return</span> RC_OK;
00416 }
00417 
00418 
00419 <span class="comment">/*</span>
00420 <span class="comment"> * adfUpdateCache</span>
00421 <span class="comment"> *</span>
00422 <span class="comment"> */</span>
00423 RETCODE adfUpdateCache(<span class="keyword">struct</span> Volume *vol, <span class="keyword">struct</span> bEntryBlock *parent, 
00424     <span class="keyword">struct</span> bEntryBlock *entry, BOOL entryLenChg)
00425 {
00426     <span class="keyword">struct </span>bDirCacheBlock dirc;
00427     SECTNUM nSect;
00428     <span class="keyword">struct </span>CacheEntry caEntry, newEntry;
00429     <span class="keywordtype">int</span> offset, oldOffset, n;
00430     BOOL found;
00431     <span class="keywordtype">int</span> i, oLen, nLen;
00432     <span class="keywordtype">int</span> sLen; <span class="comment">/* shift length */</span>
00433 
00434     nLen = adfEntry2CacheEntry(entry, &amp;newEntry);
00435 
00436     nSect = parent-&gt;extension;
00437     found = FALSE;
00438     <span class="keywordflow">do</span> {
00439 <span class="comment">/*printf("dirc=%ld\n",nSect);*/</span>
00440         <span class="keywordflow">if</span> (adfReadDirCBlock(vol, nSect, &amp;dirc)!=RC_OK)
00441             <span class="keywordflow">return</span> RC_ERROR;
00442         offset = 0; n = 0;
00443         <span class="comment">/* search entry to update with its header_key */</span>
00444         <span class="keywordflow">while</span>(n &lt; dirc.recordsNb &amp;&amp; !found) {
00445             oldOffset = offset;
00446             <span class="comment">/* offset is updated */</span>
00447             adfGetCacheEntry(&amp;dirc, &amp;offset, &amp;caEntry);
00448             oLen = offset-oldOffset;
00449             sLen = oLen-nLen;
00450 <span class="comment">/*printf("olen=%d nlen=%d\n",oLen,nLen);*/</span>
00451             found = (caEntry.header==newEntry.header);
00452             <span class="keywordflow">if</span> (found) {
00453                 <span class="keywordflow">if</span> (!entryLenChg || oLen==nLen) {
00454                     <span class="comment">/* same length : remplace the old values */</span>
00455                     adfPutCacheEntry(&amp;dirc, &amp;oldOffset, &amp;newEntry);
00456 <span class="comment">/*if (entryLenChg) puts("oLen==nLen");*/</span>
00457                     <span class="keywordflow">if</span> (adfWriteDirCBlock(vol, dirc.headerKey, &amp;dirc)!=RC_OK)
00458                         <span class="keywordflow">return</span> RC_ERROR;
00459                 }
00460                 <span class="keywordflow">else</span> <span class="keywordflow">if</span> (oLen&gt;nLen) {
00461 <span class="comment">/*puts("oLen&gt;nLen");*/</span>
00462                     <span class="comment">/* the new record is shorter, write it, </span>
00463 <span class="comment">                     * then shift down the following records </span>
00464 <span class="comment">                     */</span>
00465                     adfPutCacheEntry(&amp;dirc, &amp;oldOffset, &amp;newEntry);
00466                     <span class="keywordflow">for</span>(i=oldOffset+nLen; i&lt;(488-sLen); i++)
00467                         dirc.records[i] = dirc.records[i+sLen];
00468                     <span class="comment">/* then clear the following bytes */</span>
00469                     <span class="keywordflow">for</span>(i=488-sLen; i&lt;488; i++)
00470                         dirc.records[i] = (char)0;
00471 
00472                     <span class="keywordflow">if</span> (adfWriteDirCBlock(vol, dirc.headerKey, &amp;dirc)!=RC_OK)
00473                         <span class="keywordflow">return</span> RC_ERROR;
00474                 }
00475                 <span class="keywordflow">else</span> {
00476                     <span class="comment">/* the new record is larger */</span>
00477 <span class="comment">/*puts("oLen&lt;nLen");*/</span>
00478                     adfDelFromCache(vol,parent,entry-&gt;headerKey);
00479                     adfAddInCache(vol,parent,entry);
00480 <span class="comment">/*puts("oLen&lt;nLen end");*/</span>
00481 
00482                 }
00483             }
00484             n++;
00485         }
00486         nSect = dirc.nextDirC;
00487     }<span class="keywordflow">while</span>(nSect!=0 &amp;&amp; !found);
00488 
00489     <span class="keywordflow">if</span> (found) {
00490         <span class="keywordflow">if</span> (adfUpdateBitmap(vol)!=RC_OK)
00491             <span class="keywordflow">return</span> RC_ERROR;
00492     }
00493     <span class="keywordflow">else</span>
00494         (*adfEnv.wFct)(<span class="stringliteral">"adfUpdateCache : entry not found"</span>);
00495 
00496     <span class="keywordflow">return</span> RC_OK;
00497 }
00498 
00499 
00500 <span class="comment">/*</span>
00501 <span class="comment"> * adfCreateEmptyCache</span>
00502 <span class="comment"> *</span>
00503 <span class="comment"> */</span>
00504 RETCODE adfCreateEmptyCache(<span class="keyword">struct</span> Volume *vol, <span class="keyword">struct</span> bEntryBlock *parent, SECTNUM nSect)
00505 {
00506     <span class="keyword">struct </span>bDirCacheBlock dirc;
00507     SECTNUM nCache;
00508 
00509     <span class="keywordflow">if</span> (nSect==-1) {
00510         nCache = adfGet1FreeBlock(vol);
00511         <span class="keywordflow">if</span> (nCache==-1) {
00512            (*adfEnv.wFct)(<span class="stringliteral">"adfCreateDir : nCache==-1"</span>);
00513            <span class="keywordflow">return</span> RC_VOLFULL;
00514         }
00515     }
00516     <span class="keywordflow">else</span>
00517         nCache = nSect;
00518 
00519     <span class="keywordflow">if</span> (parent-&gt;extension==0)
00520         parent-&gt;extension = nCache;
00521 
00522     memset(&amp;dirc,0, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> bDirCacheBlock));
00523 
00524     <span class="keywordflow">if</span> (parent-&gt;secType==ST_ROOT)
00525         dirc.parent = vol-&gt;rootBlock;
00526     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (parent-&gt;secType==ST_DIR)
00527         dirc.parent = parent-&gt;headerKey;
00528     <span class="keywordflow">else</span> {
00529         (*adfEnv.wFct)(<span class="stringliteral">"adfCreateEmptyCache : unknown secType"</span>);
00530 <span class="comment">/*printf("secType=%ld\n",parent-&gt;secType);*/</span>
00531     }
00532         
00533     dirc.recordsNb = 0;
00534     dirc.nextDirC = 0;
00535 
00536     <span class="keywordflow">if</span> (adfWriteDirCBlock(vol, nCache, &amp;dirc)!=RC_OK)
00537         <span class="keywordflow">return</span> RC_ERROR;
00538 
00539     <span class="keywordflow">return</span> RC_OK;
00540 }
00541 
00542 
00543 <span class="comment">/*</span>
00544 <span class="comment"> * adfReadDirCBlock</span>
00545 <span class="comment"> *</span>
00546 <span class="comment"> */</span>
00547 RETCODE adfReadDirCBlock(<span class="keyword">struct</span> Volume *vol, SECTNUM nSect, <span class="keyword">struct</span> bDirCacheBlock *dirc)
00548 {
00549     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[512];
00550 
00551     <span class="keywordflow">if</span> (adfReadBlock(vol, nSect, buf)!=RC_OK)
00552         <span class="keywordflow">return</span> RC_ERROR;
00553 
00554     memcpy(dirc,buf,512);
00555 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00556 <span class="preprocessor"></span>    swapEndian((<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>*)dirc,SWBL_CACHE);
00557 <span class="preprocessor">#endif</span>
00558 <span class="preprocessor"></span>    <span class="keywordflow">if</span> (dirc-&gt;checkSum!=adfNormalSum(buf,20,512))
00559         (*adfEnv.wFct)(<span class="stringliteral">"adfReadDirCBlock : invalid checksum"</span>);
00560     <span class="keywordflow">if</span> (dirc-&gt;type!=T_DIRC)
00561         (*adfEnv.wFct)(<span class="stringliteral">"adfReadDirCBlock : T_DIRC not found"</span>);
00562     <span class="keywordflow">if</span> (dirc-&gt;headerKey!=nSect)
00563         (*adfEnv.wFct)(<span class="stringliteral">"adfReadDirCBlock : headerKey!=nSect"</span>);
00564 
00565     <span class="keywordflow">return</span> RC_OK;
00566 }
00567 
00568 
00569 <span class="comment">/*</span>
00570 <span class="comment"> * adfWriteDirCblock</span>
00571 <span class="comment"> *</span>
00572 <span class="comment"> */</span>
00573 RETCODE adfWriteDirCBlock(<span class="keyword">struct</span> Volume* vol, <span class="keywordtype">long</span> nSect, <span class="keyword">struct</span> bDirCacheBlock* dirc)
00574 {
00575     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> buf[LOGICAL_BLOCK_SIZE];
00576     <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> newSum;
00577  
00578     dirc-&gt;type = T_DIRC;
00579     dirc-&gt;headerKey = nSect; 
00580 
00581     memcpy(buf, dirc, LOGICAL_BLOCK_SIZE);
00582 <span class="preprocessor">#ifdef LITT_ENDIAN</span>
00583 <span class="preprocessor"></span>    swapEndian(buf, SWBL_CACHE);
00584 <span class="preprocessor">#endif</span>
00585 <span class="preprocessor"></span>
00586     newSum = adfNormalSum(buf, 20, LOGICAL_BLOCK_SIZE);
00587     swLong(buf+20,newSum);
00588 <span class="comment">/*    *(long*)(buf+20) = swapLong((unsigned char*)&amp;newSum);*/</span>
00589 
00590     <span class="keywordflow">if</span> (adfWriteBlock(vol, nSect, buf)!=RC_OK)
00591         <span class="keywordflow">return</span> RC_ERROR;
00592 <span class="comment">/*puts("adfWriteDirCBlock");*/</span>
00593 
00594     <span class="keywordflow">return</span> RC_OK;
00595 }
00596 
00597 <span class="comment">/*################################################################################*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:37 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

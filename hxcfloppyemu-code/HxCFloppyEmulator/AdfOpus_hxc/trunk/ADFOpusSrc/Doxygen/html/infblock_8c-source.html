<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>infblock.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>infblock.c</h1><div class="fragment"><pre>00001 <span class="comment">/* infblock.c -- interpret and process block types to last block</span>
00002 <span class="comment"> * Copyright (C) 1995-2002 Mark Adler</span>
00003 <span class="comment"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
00004 <span class="comment"> */</span>
00005 
00006 <span class="preprocessor">#include "zutil.h"</span>
00007 <span class="preprocessor">#include "infblock.h"</span>
00008 <span class="preprocessor">#include "inftrees.h"</span>
00009 <span class="preprocessor">#include "infcodes.h"</span>
00010 <span class="preprocessor">#include "infutil.h"</span>
00011 
00012 <span class="keyword">struct </span>inflate_codes_state {<span class="keywordtype">int</span> dummy;}; <span class="comment">/* for buggy compilers */</span>
00013 
00014 <span class="comment">/* simplify the use of the inflate_huft type with some defines */</span>
00015 <span class="preprocessor">#define exop word.what.Exop</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#define bits word.what.Bits</span>
00017 <span class="preprocessor"></span>
00018 <span class="comment">/* Table for deflate from PKZIP's appnote.txt. */</span>
00019 local <span class="keyword">const</span> uInt border[] = { <span class="comment">/* Order of the bit length code lengths */</span>
00020         16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
00021 
00022 <span class="comment">/*</span>
00023 <span class="comment">   Notes beyond the 1.93a appnote.txt:</span>
00024 <span class="comment"></span>
00025 <span class="comment">   1. Distance pointers never point before the beginning of the output</span>
00026 <span class="comment">      stream.</span>
00027 <span class="comment">   2. Distance pointers can point back across blocks, up to 32k away.</span>
00028 <span class="comment">   3. There is an implied maximum of 7 bits for the bit length table and</span>
00029 <span class="comment">      15 bits for the actual data.</span>
00030 <span class="comment">   4. If only one code exists, then it is encoded using one bit.  (Zero</span>
00031 <span class="comment">      would be more efficient, but perhaps a little confusing.)  If two</span>
00032 <span class="comment">      codes exist, they are coded using one bit each (0 and 1).</span>
00033 <span class="comment">   5. There is no way of sending zero distance codes--a dummy must be</span>
00034 <span class="comment">      sent if there are none.  (History: a pre 2.0 version of PKZIP would</span>
00035 <span class="comment">      store blocks with no distance codes, but this was discovered to be</span>
00036 <span class="comment">      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow</span>
00037 <span class="comment">      zero distance codes, which is sent as one code of zero bits in</span>
00038 <span class="comment">      length.</span>
00039 <span class="comment">   6. There are up to 286 literal/length codes.  Code 256 represents the</span>
00040 <span class="comment">      end-of-block.  Note however that the static length tree defines</span>
00041 <span class="comment">      288 codes just to fill out the Huffman codes.  Codes 286 and 287</span>
00042 <span class="comment">      cannot be used though, since there is no length base or extra bits</span>
00043 <span class="comment">      defined for them.  Similarily, there are up to 30 distance codes.</span>
00044 <span class="comment">      However, static trees define 32 codes (all 5 bits) to fill out the</span>
00045 <span class="comment">      Huffman codes, but the last two had better not show up in the data.</span>
00046 <span class="comment">   7. Unzip can check dynamic Huffman blocks for complete code sets.</span>
00047 <span class="comment">      The exception is that a single code would not be complete (see #4).</span>
00048 <span class="comment">   8. The five bits following the block type is really the number of</span>
00049 <span class="comment">      literal codes sent minus 257.</span>
00050 <span class="comment">   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits</span>
00051 <span class="comment">      (1+6+6).  Therefore, to output three times the length, you output</span>
00052 <span class="comment">      three codes (1+1+1), whereas to output four times the same length,</span>
00053 <span class="comment">      you only need two codes (1+3).  Hmm.</span>
00054 <span class="comment">  10. In the tree reconstruction algorithm, Code = Code + Increment</span>
00055 <span class="comment">      only if BitLength(i) is not zero.  (Pretty obvious.)</span>
00056 <span class="comment">  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)</span>
00057 <span class="comment">  12. Note: length code 284 can represent 227-258, but length code 285</span>
00058 <span class="comment">      really is 258.  The last length deserves its own, short code</span>
00059 <span class="comment">      since it gets used a lot in very redundant files.  The length</span>
00060 <span class="comment">      258 is special since 258 - 3 (the min match length) is 255.</span>
00061 <span class="comment">  13. The literal/length and distance code bit lengths are read as a</span>
00062 <span class="comment">      single stream of lengths.  It is possible (and advantageous) for</span>
00063 <span class="comment">      a repeat code (16, 17, or 18) to go across the boundary between</span>
00064 <span class="comment">      the two sets of lengths.</span>
00065 <span class="comment"> */</span>
00066 
00067 
00068 <span class="keywordtype">void</span> inflate_blocks_reset(s, z, c)
00069 inflate_blocks_statef *s;
00070 z_streamp z;
00071 uLongf *c;
00072 {
00073   <span class="keywordflow">if</span> (c != Z_NULL)
00074     *c = s-&gt;check;
00075   <span class="keywordflow">if</span> (s-&gt;mode == BTREE || s-&gt;mode == DTREE)
00076     ZFREE(z, s-&gt;sub.trees.blens);
00077   <span class="keywordflow">if</span> (s-&gt;mode == CODES)
00078     inflate_codes_free(s-&gt;sub.decode.codes, z);
00079   s-&gt;mode = TYPE;
00080   s-&gt;bitk = 0;
00081   s-&gt;bitb = 0;
00082   s-&gt;read = s-&gt;write = s-&gt;window;
00083   <span class="keywordflow">if</span> (s-&gt;checkfn != Z_NULL)
00084     z-&gt;adler = s-&gt;check = (*s-&gt;checkfn)(0L, (<span class="keyword">const</span> Bytef *)Z_NULL, 0);
00085   Tracev((stderr, <span class="stringliteral">"inflate:   blocks reset\n"</span>));
00086 }
00087 
00088 
00089 inflate_blocks_statef *inflate_blocks_new(z, c, w)
00090 z_streamp z;
00091 check_func c;
00092 uInt w;
00093 {
00094   inflate_blocks_statef *s;
00095 
00096   <span class="keywordflow">if</span> ((s = (inflate_blocks_statef *)ZALLOC
00097        (z,1,<span class="keyword">sizeof</span>(<span class="keyword">struct </span>inflate_blocks_state))) == Z_NULL)
00098     <span class="keywordflow">return</span> s;
00099   <span class="keywordflow">if</span> ((s-&gt;hufts =
00100        (inflate_huft *)ZALLOC(z, <span class="keyword">sizeof</span>(inflate_huft), MANY)) == Z_NULL)
00101   {
00102     ZFREE(z, s);
00103     <span class="keywordflow">return</span> Z_NULL;
00104   }
00105   <span class="keywordflow">if</span> ((s-&gt;window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
00106   {
00107     ZFREE(z, s-&gt;hufts);
00108     ZFREE(z, s);
00109     <span class="keywordflow">return</span> Z_NULL;
00110   }
00111   s-&gt;end = s-&gt;window + w;
00112   s-&gt;checkfn = c;
00113   s-&gt;mode = TYPE;
00114   Tracev((stderr, <span class="stringliteral">"inflate:   blocks allocated\n"</span>));
00115   inflate_blocks_reset(s, z, Z_NULL);
00116   <span class="keywordflow">return</span> s;
00117 }
00118 
00119 
00120 <span class="keywordtype">int</span> inflate_blocks(s, z, r)
00121 inflate_blocks_statef *s;
00122 z_streamp z;
00123 <span class="keywordtype">int</span> r;
00124 {
00125   uInt t;               <span class="comment">/* temporary storage */</span>
00126   uLong b;              <span class="comment">/* bit buffer */</span>
00127   uInt k;               <span class="comment">/* bits in bit buffer */</span>
00128   Bytef *p;             <span class="comment">/* input data pointer */</span>
00129   uInt n;               <span class="comment">/* bytes available there */</span>
00130   Bytef *q;             <span class="comment">/* output window write pointer */</span>
00131   uInt m;               <span class="comment">/* bytes to end of window or read pointer */</span>
00132 
00133   <span class="comment">/* copy input/output information to locals (UPDATE macro restores) */</span>
00134   LOAD
00135 
00136   <span class="comment">/* process input based on current state */</span>
00137   <span class="keywordflow">while</span> (1) <span class="keywordflow">switch</span> (s-&gt;mode)
00138   {
00139     <span class="keywordflow">case</span> TYPE:
00140       NEEDBITS(3)
00141       t = (uInt)b &amp; 7;
00142       s-&gt;last = t &amp; 1;
00143       <span class="keywordflow">switch</span> (t &gt;&gt; 1)
00144       {
00145         <span class="keywordflow">case</span> 0:                         <span class="comment">/* stored */</span>
00146           Tracev((stderr, <span class="stringliteral">"inflate:     stored block%s\n"</span>,
00147                  s-&gt;last ? <span class="stringliteral">" (last)"</span> : <span class="stringliteral">""</span>));
00148           DUMPBITS(3)
00149           t = k &amp; 7;                    <span class="comment">/* go to byte boundary */</span>
00150           DUMPBITS(t)
00151           s-&gt;mode = LENS;               <span class="comment">/* get length of stored block */</span>
00152           <span class="keywordflow">break</span>;
00153         <span class="keywordflow">case</span> 1:                         <span class="comment">/* fixed */</span>
00154           Tracev((stderr, <span class="stringliteral">"inflate:     fixed codes block%s\n"</span>,
00155                  s-&gt;last ? <span class="stringliteral">" (last)"</span> : <span class="stringliteral">""</span>));
00156           {
00157             uInt bl, bd;
00158             inflate_huft *tl, *td;
00159 
00160             inflate_trees_fixed(&amp;bl, &amp;bd, &amp;tl, &amp;td, z);
00161             s-&gt;sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
00162             <span class="keywordflow">if</span> (s-&gt;sub.decode.codes == Z_NULL)
00163             {
00164               r = Z_MEM_ERROR;
00165               LEAVE
00166             }
00167           }
00168           DUMPBITS(3)
00169           s-&gt;mode = CODES;
00170           <span class="keywordflow">break</span>;
00171         <span class="keywordflow">case</span> 2:                         <span class="comment">/* dynamic */</span>
00172           Tracev((stderr, <span class="stringliteral">"inflate:     dynamic codes block%s\n"</span>,
00173                  s-&gt;last ? <span class="stringliteral">" (last)"</span> : <span class="stringliteral">""</span>));
00174           DUMPBITS(3)
00175           s-&gt;mode = TABLE;
00176           <span class="keywordflow">break</span>;
00177         <span class="keywordflow">case</span> 3:                         <span class="comment">/* illegal */</span>
00178           DUMPBITS(3)
00179           s-&gt;mode = BAD;
00180           z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"invalid block type"</span>;
00181           r = Z_DATA_ERROR;
00182           LEAVE
00183       }
00184       <span class="keywordflow">break</span>;
00185     <span class="keywordflow">case</span> LENS:
00186       NEEDBITS(32)
00187       <span class="keywordflow">if</span> ((((~b) &gt;&gt; 16) &amp; 0xffff) != (b &amp; 0xffff))
00188       {
00189         s-&gt;mode = BAD;
00190         z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"invalid stored block lengths"</span>;
00191         r = Z_DATA_ERROR;
00192         LEAVE
00193       }
00194       s-&gt;sub.left = (uInt)b &amp; 0xffff;
00195       b = k = 0;                      <span class="comment">/* dump bits */</span>
00196       Tracev((stderr, <span class="stringliteral">"inflate:       stored length %u\n"</span>, s-&gt;sub.left));
00197       s-&gt;mode = s-&gt;sub.left ? STORED : (s-&gt;last ? DRY : TYPE);
00198       <span class="keywordflow">break</span>;
00199     <span class="keywordflow">case</span> STORED:
00200       <span class="keywordflow">if</span> (n == 0)
00201         LEAVE
00202       NEEDOUT
00203       t = s-&gt;sub.left;
00204       <span class="keywordflow">if</span> (t &gt; n) t = n;
00205       <span class="keywordflow">if</span> (t &gt; m) t = m;
00206       zmemcpy(q, p, t);
00207       p += t;  n -= t;
00208       q += t;  m -= t;
00209       <span class="keywordflow">if</span> ((s-&gt;sub.left -= t) != 0)
00210         <span class="keywordflow">break</span>;
00211       Tracev((stderr, <span class="stringliteral">"inflate:       stored end, %lu total out\n"</span>,
00212               z-&gt;total_out + (q &gt;= s-&gt;read ? q - s-&gt;read :
00213               (s-&gt;end - s-&gt;read) + (q - s-&gt;window))));
00214       s-&gt;mode = s-&gt;last ? DRY : TYPE;
00215       <span class="keywordflow">break</span>;
00216     <span class="keywordflow">case</span> TABLE:
00217       NEEDBITS(14)
00218       s-&gt;sub.trees.table = t = (uInt)b &amp; 0x3fff;
00219 <span class="preprocessor">#ifndef PKZIP_BUG_WORKAROUND</span>
00220 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ((t &amp; 0x1f) &gt; 29 || ((t &gt;&gt; 5) &amp; 0x1f) &gt; 29)
00221       {
00222         s-&gt;mode = BAD;
00223         z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"too many length or distance symbols"</span>;
00224         r = Z_DATA_ERROR;
00225         LEAVE
00226       }
00227 <span class="preprocessor">#endif</span>
00228 <span class="preprocessor"></span>      t = 258 + (t &amp; 0x1f) + ((t &gt;&gt; 5) &amp; 0x1f);
00229       <span class="keywordflow">if</span> ((s-&gt;sub.trees.blens = (uIntf*)ZALLOC(z, t, <span class="keyword">sizeof</span>(uInt))) == Z_NULL)
00230       {
00231         r = Z_MEM_ERROR;
00232         LEAVE
00233       }
00234       DUMPBITS(14)
00235       s-&gt;sub.trees.index = 0;
00236       Tracev((stderr, <span class="stringliteral">"inflate:       table sizes ok\n"</span>));
00237       s-&gt;mode = BTREE;
00238     <span class="keywordflow">case</span> BTREE:
00239       <span class="keywordflow">while</span> (s-&gt;sub.trees.index &lt; 4 + (s-&gt;sub.trees.table &gt;&gt; 10))
00240       {
00241         NEEDBITS(3)
00242         s-&gt;sub.trees.blens[border[s-&gt;sub.trees.index++]] = (uInt)b &amp; 7;
00243         DUMPBITS(3)
00244       }
00245       <span class="keywordflow">while</span> (s-&gt;sub.trees.index &lt; 19)
00246         s-&gt;sub.trees.blens[border[s-&gt;sub.trees.index++]] = 0;
00247       s-&gt;sub.trees.bb = 7;
00248       t = inflate_trees_bits(s-&gt;sub.trees.blens, &amp;s-&gt;sub.trees.bb,
00249                              &amp;s-&gt;sub.trees.tb, s-&gt;hufts, z);
00250       <span class="keywordflow">if</span> (t != Z_OK)
00251       {
00252         r = t;
00253         <span class="keywordflow">if</span> (r == Z_DATA_ERROR)
00254         {
00255           ZFREE(z, s-&gt;sub.trees.blens);
00256           s-&gt;mode = BAD;
00257         }
00258         LEAVE
00259       }
00260       s-&gt;sub.trees.index = 0;
00261       Tracev((stderr, <span class="stringliteral">"inflate:       bits tree ok\n"</span>));
00262       s-&gt;mode = DTREE;
00263     <span class="keywordflow">case</span> DTREE:
00264       <span class="keywordflow">while</span> (t = s-&gt;sub.trees.table,
00265              s-&gt;sub.trees.index &lt; 258 + (t &amp; 0x1f) + ((t &gt;&gt; 5) &amp; 0x1f))
00266       {
00267         inflate_huft *h;
00268         uInt i, j, c;
00269 
00270         t = s-&gt;sub.trees.bb;
00271         NEEDBITS(t)
00272         h = s-&gt;sub.trees.tb + ((uInt)b &amp; inflate_mask[t]);
00273         t = h-&gt;bits;
00274         c = h-&gt;base;
00275         <span class="keywordflow">if</span> (c &lt; 16)
00276         {
00277           DUMPBITS(t)
00278           s-&gt;sub.trees.blens[s-&gt;sub.trees.index++] = c;
00279         }
00280         <span class="keywordflow">else</span> <span class="comment">/* c == 16..18 */</span>
00281         {
00282           i = c == 18 ? 7 : c - 14;
00283           j = c == 18 ? 11 : 3;
00284           NEEDBITS(t + i)
00285           DUMPBITS(t)
00286           j += (uInt)b &amp; inflate_mask[i];
00287           DUMPBITS(i)
00288           i = s-&gt;sub.trees.index;
00289           t = s-&gt;sub.trees.table;
00290           <span class="keywordflow">if</span> (i + j &gt; 258 + (t &amp; 0x1f) + ((t &gt;&gt; 5) &amp; 0x1f) ||
00291               (c == 16 &amp;&amp; i &lt; 1))
00292           {
00293             ZFREE(z, s-&gt;sub.trees.blens);
00294             s-&gt;mode = BAD;
00295             z-&gt;msg = (<span class="keywordtype">char</span>*)<span class="stringliteral">"invalid bit length repeat"</span>;
00296             r = Z_DATA_ERROR;
00297             LEAVE
00298           }
00299           c = c == 16 ? s-&gt;sub.trees.blens[i - 1] : 0;
00300           <span class="keywordflow">do</span> {
00301             s-&gt;sub.trees.blens[i++] = c;
00302           } <span class="keywordflow">while</span> (--j);
00303           s-&gt;sub.trees.index = i;
00304         }
00305       }
00306       s-&gt;sub.trees.tb = Z_NULL;
00307       {
00308         uInt bl, bd;
00309         inflate_huft *tl, *td;
00310         inflate_codes_statef *c;
00311 
00312         bl = 9;         <span class="comment">/* must be &lt;= 9 for lookahead assumptions */</span>
00313         bd = 6;         <span class="comment">/* must be &lt;= 9 for lookahead assumptions */</span>
00314         t = s-&gt;sub.trees.table;
00315         t = inflate_trees_dynamic(257 + (t &amp; 0x1f), 1 + ((t &gt;&gt; 5) &amp; 0x1f),
00316                                   s-&gt;sub.trees.blens, &amp;bl, &amp;bd, &amp;tl, &amp;td,
00317                                   s-&gt;hufts, z);
00318         <span class="keywordflow">if</span> (t != Z_OK)
00319         {
00320           <span class="keywordflow">if</span> (t == (uInt)Z_DATA_ERROR)
00321           {
00322             ZFREE(z, s-&gt;sub.trees.blens);
00323             s-&gt;mode = BAD;
00324           }
00325           r = t;
00326           LEAVE
00327         }
00328         Tracev((stderr, <span class="stringliteral">"inflate:       trees ok\n"</span>));
00329         <span class="keywordflow">if</span> ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
00330         {
00331           r = Z_MEM_ERROR;
00332           LEAVE
00333         }
00334         s-&gt;sub.decode.codes = c;
00335       }
00336       ZFREE(z, s-&gt;sub.trees.blens);
00337       s-&gt;mode = CODES;
00338     <span class="keywordflow">case</span> CODES:
00339       UPDATE
00340       <span class="keywordflow">if</span> ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
00341         <span class="keywordflow">return</span> inflate_flush(s, z, r);
00342       r = Z_OK;
00343       inflate_codes_free(s-&gt;sub.decode.codes, z);
00344       LOAD
00345       Tracev((stderr, <span class="stringliteral">"inflate:       codes end, %lu total out\n"</span>,
00346               z-&gt;total_out + (q &gt;= s-&gt;read ? q - s-&gt;read :
00347               (s-&gt;end - s-&gt;read) + (q - s-&gt;window))));
00348       <span class="keywordflow">if</span> (!s-&gt;last)
00349       {
00350         s-&gt;mode = TYPE;
00351         <span class="keywordflow">break</span>;
00352       }
00353       s-&gt;mode = DRY;
00354     <span class="keywordflow">case</span> DRY:
00355       FLUSH
00356       <span class="keywordflow">if</span> (s-&gt;read != s-&gt;write)
00357         LEAVE
00358       s-&gt;mode = DONE;
00359     <span class="keywordflow">case</span> DONE:
00360       r = Z_STREAM_END;
00361       LEAVE
00362     <span class="keywordflow">case</span> BAD:
00363       r = Z_DATA_ERROR;
00364       LEAVE
00365     <span class="keywordflow">default</span>:
00366       r = Z_STREAM_ERROR;
00367       LEAVE
00368   }
00369 }
00370 
00371 
00372 <span class="keywordtype">int</span> inflate_blocks_free(s, z)
00373 inflate_blocks_statef *s;
00374 z_streamp z;
00375 {
00376   inflate_blocks_reset(s, z, Z_NULL);
00377   ZFREE(z, s-&gt;window);
00378   ZFREE(z, s-&gt;hufts);
00379   ZFREE(z, s);
00380   Tracev((stderr, <span class="stringliteral">"inflate:   blocks freed\n"</span>));
00381   <span class="keywordflow">return</span> Z_OK;
00382 }
00383 
00384 
00385 <span class="keywordtype">void</span> inflate_set_dictionary(s, d, n)
00386 inflate_blocks_statef *s;
00387 <span class="keyword">const</span> Bytef *d;
00388 uInt  n;
00389 {
00390   zmemcpy(s-&gt;window, d, n);
00391   s-&gt;read = s-&gt;write = s-&gt;window + n;
00392 }
00393 
00394 
00395 <span class="comment">/* Returns true if inflate is currently at the end of a block generated</span>
00396 <span class="comment"> * by Z_SYNC_FLUSH or Z_FULL_FLUSH. </span>
00397 <span class="comment"> * IN assertion: s != Z_NULL</span>
00398 <span class="comment"> */</span>
00399 <span class="keywordtype">int</span> inflate_blocks_sync_point(s)
00400 inflate_blocks_statef *s;
00401 {
00402   <span class="keywordflow">return</span> s-&gt;mode == LENS;
00403 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:41 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

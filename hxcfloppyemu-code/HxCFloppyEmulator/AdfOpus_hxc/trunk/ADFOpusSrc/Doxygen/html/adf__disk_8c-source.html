<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>adf_disk.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>adf_disk.c</h1><a href="adf__disk_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> *  ADF Library. (C) 1997-2002 Laurent Clevy</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> */</span>
00010 <span class="preprocessor">#include &lt;limits.h&gt;</span>
00011 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00012 <span class="preprocessor">#include &lt;string.h&gt;</span>
00013 
00014 <span class="preprocessor">#include "adf_str.h"</span>
00015 <span class="preprocessor">#include "adf_disk.h"</span>
00016 <span class="preprocessor">#include "adf_raw.h"</span>
00017 <span class="preprocessor">#include "adf_hd.h"</span>
00018 <span class="preprocessor">#include "adf_bitm.h"</span>
00019 <span class="preprocessor">#include "adf_util.h"</span>
00020 <span class="preprocessor">#include "adf_nativ.h"</span>
00021 <span class="preprocessor">#include "adf_dump.h"</span>
00022 <span class="preprocessor">#include "adf_err.h"</span>
00023 <span class="preprocessor">#include "adf_cache.h"</span>
00024 
00025 <span class="keyword">extern</span> <span class="keyword">struct </span>Env adfEnv;
00026 
00027 <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bitMask[32] = { 
00028     0x1, 0x2, 0x4, 0x8,
00029     0x10, 0x20, 0x40, 0x80,
00030     0x100, 0x200, 0x400, 0x800,
00031     0x1000, 0x2000, 0x4000, 0x8000,
00032     0x10000, 0x20000, 0x40000, 0x80000,
00033     0x100000, 0x200000, 0x400000, 0x800000,
00034     0x1000000, 0x2000000, 0x4000000, 0x8000000,
00035     0x10000000, 0x20000000, 0x40000000, 0x80000000 };
00036 
00037 
00038 RETCODE adfInstallBootBlock(<span class="keyword">struct</span> Volume *vol, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* code)
00039 {
00040     <span class="keywordtype">int</span> i;
00041     <span class="keyword">struct </span>bBootBlock boot;
00042 
00043     <span class="keywordflow">if</span> (vol-&gt;dev-&gt;devType!=DEVTYPE_FLOPDD &amp;&amp; vol-&gt;dev-&gt;devType!=DEVTYPE_FLOPHD)
00044         <span class="keywordflow">return</span> RC_ERROR;
00045 
00046     <span class="keywordflow">if</span> (adfReadBootBlock(vol, &amp;boot)!=RC_OK)
00047         <span class="keywordflow">return</span> RC_ERROR;
00048 
00049     boot.rootBlock = 880;
00050     <span class="keywordflow">for</span>(i=0; i&lt;1024-12; i++)         <span class="comment">/* bootcode */</span>
00051         boot.data[i] = code[i+12];
00052 
00053     <span class="keywordflow">if</span> (adfWriteBootBlock(vol, &amp;boot)!=RC_OK)
00054         <span class="keywordflow">return</span> RC_ERROR;
00055 
00056     vol-&gt;bootCode = TRUE;
00057 
00058     <span class="keywordflow">return</span> RC_OK;
00059 }
00060 
00061 
00062 <span class="comment">/*</span>
00063 <span class="comment"> * isSectNumValid</span>
00064 <span class="comment"> *</span>
00065 <span class="comment"> */</span>
00066 BOOL isSectNumValid(<span class="keyword">struct</span> Volume *vol, SECTNUM nSect)
00067 {
00068     <span class="keywordflow">return</span>( 0&lt;=nSect &amp;&amp; nSect&lt;=(vol-&gt;lastBlock - vol-&gt;firstBlock) );
00069 }   
00070     
00071 
00072 
00073 <span class="comment">/*</span>
00074 <span class="comment"> * adfVolumeInfo</span>
00075 <span class="comment"> *</span>
00076 <span class="comment"> */</span>
00077 <span class="keywordtype">void</span> adfVolumeInfo(<span class="keyword">struct</span> Volume *vol)
00078 {
00079     <span class="keyword">struct </span>bRootBlock root;
00080     <span class="keywordtype">char</span> diskName[35];
00081     <span class="keywordtype">int</span> days,month,year;
00082     
00083     <span class="keywordflow">if</span> (adfReadRootBlock(vol, vol-&gt;rootBlock, &amp;root)!=RC_OK)
00084         <span class="keywordflow">return</span>;
00085     
00086     memset(diskName, 0, 35);
00087     memcpy(diskName, root.diskName, root.nameLen);
00088     
00089     printf (<span class="stringliteral">"Name : %-30s\n"</span>,vol-&gt;volName);
00090     printf (<span class="stringliteral">"Type : "</span>);
00091     <span class="keywordflow">switch</span>(vol-&gt;dev-&gt;devType) {
00092         <span class="keywordflow">case</span> DEVTYPE_FLOPDD:
00093             printf (<span class="stringliteral">"Floppy Double Density : 880 KBytes\n"</span>);
00094             <span class="keywordflow">break</span>;
00095         <span class="keywordflow">case</span> DEVTYPE_FLOPHD:
00096             printf (<span class="stringliteral">"Floppy High Density : 1760 KBytes\n"</span>);
00097             <span class="keywordflow">break</span>;
00098         <span class="keywordflow">case</span> DEVTYPE_HARDDISK:
00099             printf (<span class="stringliteral">"Hard Disk partition : %3.1f KBytes\n"</span>, 
00100                 (vol-&gt;lastBlock - vol-&gt;firstBlock +1) * 512.0/1024.0);
00101             <span class="keywordflow">break</span>;
00102         <span class="keywordflow">case</span> DEVTYPE_HARDFILE:
00103             printf (<span class="stringliteral">"HardFile : %3.1f KBytes\n"</span>, 
00104                 (vol-&gt;lastBlock - vol-&gt;firstBlock +1) * 512.0/1024.0);
00105             <span class="keywordflow">break</span>;
00106         <span class="keywordflow">default</span>:
00107             printf (<span class="stringliteral">"Unknown devType!\n"</span>);
00108     }
00109     printf (<span class="stringliteral">"Filesystem : "</span>);
00110     printf(<span class="stringliteral">"%s "</span>,isFFS(vol-&gt;dosType) ? <span class="stringliteral">"FFS"</span> : <span class="stringliteral">"OFS"</span>);
00111     if (isINTL(vol-&gt;dosType))
00112         printf (<span class="stringliteral">"INTL "</span>);
00113     <span class="keywordflow">if</span> (isDIRCACHE(vol-&gt;dosType))
00114         printf (<span class="stringliteral">"DIRCACHE "</span>);
00115     putchar(<span class="charliteral">'\n'</span>);
00116 
00117     printf(<span class="stringliteral">"Free blocks = %ld\n"</span>, adfCountFreeBlocks(vol));
00118     <span class="keywordflow">if</span> (vol-&gt;readOnly)
00119         printf(<span class="stringliteral">"Read only\n"</span>);
00120     <span class="keywordflow">else</span>
00121         printf(<span class="stringliteral">"Read/Write\n"</span>);
00122     
00123     <span class="comment">/* created */</span>
00124     adfDays2Date(root.coDays, &amp;year, &amp;month, &amp;days);
00125     printf (<span class="stringliteral">"created %d/%02d/%02d %ld:%02ld:%02ld\n"</span>,days,month,year,
00126         root.coMins/60,root.coMins%60,root.coTicks/50); 
00127     adfDays2Date(root.days, &amp;year, &amp;month, &amp;days);
00128     printf (<span class="stringliteral">"last access %d/%02d/%02d %ld:%02ld:%02ld,   "</span>,days,month,year,
00129         root.mins/60,root.mins%60,root.ticks/50);   
00130     adfDays2Date(root.cDays, &amp;year, &amp;month, &amp;days);
00131     printf (<span class="stringliteral">"%d/%02d/%02d %ld:%02ld:%02ld\n"</span>,days,month,year,
00132         root.cMins/60,root.cMins%60,root.cTicks/50);    
00133 }
00134 
00135 
00136 
00137 <span class="comment">/*</span>
00138 <span class="comment"> * adfMount</span>
00139 <span class="comment"> *</span>
00140 <span class="comment"> * </span>
00141 <span class="comment"> */</span>
00142 <span class="keyword">struct </span>Volume* adfMount( struct Device *dev, int nPart, BOOL readOnly )
00143 {
00144     <span class="keywordtype">long</span> nBlock;
00145     <span class="keyword">struct </span>bRootBlock root;
00146     <span class="keyword">struct </span>bBootBlock boot;
00147     <span class="keyword">struct </span>Volume* vol;
00148 
00149     <span class="keywordflow">if</span> (dev==NULL || nPart&lt;nPart || nPart &gt;= dev-&gt;nVol) {
00150         (*adfEnv.eFct)(<span class="stringliteral">"adfMount : invalid parameter(s)"</span>);
00151         <span class="keywordflow">return</span> NULL;
00152     }
00153 
00154     vol = dev-&gt;volList[nPart];
00155     vol-&gt;dev = dev;
00156     vol-&gt;mounted = TRUE;
00157 
00158 <span class="comment">/*printf("first=%ld last=%ld root=%ld\n",vol-&gt;firstBlock,</span>
00159 <span class="comment"> vol-&gt;lastBlock, vol-&gt;rootBlock);</span>
00160 <span class="comment">*/</span>
00161     <span class="keywordflow">if</span> (adfReadBootBlock(vol, &amp;boot)!=RC_OK) {
00162         (*adfEnv.wFct)(<span class="stringliteral">"adfMount : BootBlock invalid"</span>);
00163         <span class="keywordflow">return</span> NULL;
00164     }       
00165     
00166     vol-&gt;dosType = boot.dosType[3];
00167     <span class="keywordflow">if</span> (isFFS(vol-&gt;dosType))
00168         vol-&gt;datablockSize=512;
00169     <span class="keywordflow">else</span>
00170         vol-&gt;datablockSize=488;
00171 
00172     <span class="keywordflow">if</span> (dev-&gt;readOnly <span class="comment">/*|| isDIRCACHE(vol-&gt;dosType)*/</span>)
00173        vol-&gt;readOnly = TRUE;
00174     <span class="keywordflow">else</span>
00175        vol-&gt;readOnly = readOnly;
00176         
00177     <span class="keywordflow">if</span> (adfReadRootBlock(vol, vol-&gt;rootBlock, &amp;root)!=RC_OK) {
00178         (*adfEnv.wFct)(<span class="stringliteral">"adfMount : RootBlock invalid"</span>);       
00179         <span class="keywordflow">return</span> NULL;
00180     }
00181 
00182     nBlock = vol-&gt;lastBlock - vol-&gt;firstBlock +1 - 2;
00183 
00184     adfReadBitmap( vol, nBlock, &amp;root );
00185     vol-&gt;curDirPtr = vol-&gt;rootBlock;
00186 
00187 <span class="comment">/*printf("blockSize=%d\n",vol-&gt;blockSize);*/</span>
00188 
00189     <span class="keywordflow">return</span>( vol );
00190 }
00191 
00192 
00193 <span class="comment">/*</span>
00194 <span class="comment">*</span>
00195 <span class="comment">* adfUnMount</span>
00196 <span class="comment">*</span>
00197 <span class="comment">* free bitmap structures</span>
00198 <span class="comment">* free current dir</span>
00199 <span class="comment">*/</span>
00200 <span class="keywordtype">void</span> adfUnMount(<span class="keyword">struct</span> Volume *vol)
00201 {
00202     <span class="keywordflow">if</span> (!vol) {
00203         (*adfEnv.eFct)(<span class="stringliteral">"adfUnMount : vol is null"</span>);
00204         <span class="keywordflow">return</span>;
00205     }
00206 
00207     adfFreeBitmap(vol);
00208 
00209     vol-&gt;mounted = FALSE;
00210     
00211 }
00212 
00213 
00214 
00215 <span class="comment">/*</span>
00216 <span class="comment"> * adfCreateVol</span>
00217 <span class="comment"> *</span>
00218 <span class="comment"> * </span>
00219 <span class="comment"> */</span>
00220 <span class="keyword">struct </span>Volume* adfCreateVol( struct Device* dev, long start, long len, 
00221     char* volName, int volType )
00222 {
00223     <span class="keyword">struct </span>bBootBlock boot;
00224     <span class="keyword">struct </span>bRootBlock root;
00225 <span class="comment">/*    struct bDirCacheBlock dirc;*/</span>
00226     SECTNUM blkList[2];
00227     <span class="keyword">struct </span>Volume* vol;
00228     <span class="keywordtype">int</span> nlen;
00229 
00230     <span class="keywordflow">if</span> (adfEnv.useProgressBar)
00231         (*adfEnv.progressBar)(0);
00232 
00233     vol=(<span class="keyword">struct </span>Volume*)malloc(sizeof(struct Volume));
00234     <span class="keywordflow">if</span> (!vol) { 
00235         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateVol : malloc vol"</span>);
00236         <span class="keywordflow">return</span> NULL;
00237     }
00238     
00239     vol-&gt;dev = dev;
00240     vol-&gt;firstBlock = (dev-&gt;heads * dev-&gt;sectors)*start;
00241     vol-&gt;lastBlock = (vol-&gt;firstBlock + (dev-&gt;heads * dev-&gt;sectors)*len)-1;
00242     vol-&gt;rootBlock = (vol-&gt;lastBlock - vol-&gt;firstBlock+1)/2;
00243 <span class="comment">/*printf("first=%ld last=%ld root=%ld\n",vol-&gt;firstBlock,</span>
00244 <span class="comment"> vol-&gt;lastBlock, vol-&gt;rootBlock);</span>
00245 <span class="comment">*/</span>
00246     vol-&gt;curDirPtr = vol-&gt;rootBlock;
00247 
00248     vol-&gt;readOnly = dev-&gt;readOnly;
00249 
00250     vol-&gt;mounted = TRUE;
00251 
00252     nlen = min( MAXNAMELEN, strlen(volName) );
00253     vol-&gt;volName = (<span class="keywordtype">char</span>*)malloc(nlen+1);
00254     <span class="keywordflow">if</span> (!vol-&gt;volName) { 
00255         (*adfEnv.eFct)(<span class="stringliteral">"adfCreateVol : malloc"</span>);
00256         free(vol); <span class="keywordflow">return</span> NULL;
00257     }
00258     memcpy(vol-&gt;volName, volName, nlen);
00259     vol-&gt;volName[nlen]=<span class="charliteral">'\0'</span>;
00260 
00261     <span class="keywordflow">if</span> (adfEnv.useProgressBar)
00262         (*adfEnv.progressBar)(25);
00263 
00264     memset(&amp;boot, 0, 1024);
00265     boot.dosType[3] = volType;
00266 <span class="comment">/*printf("first=%d last=%d\n", vol-&gt;firstBlock, vol-&gt;lastBlock);</span>
00267 <span class="comment">printf("name=%s root=%d\n", vol-&gt;volName, vol-&gt;rootBlock);</span>
00268 <span class="comment">*/</span>
00269     <span class="keywordflow">if</span> (adfWriteBootBlock(vol, &amp;boot)!=RC_OK) {
00270         free(vol-&gt;volName); free(vol);
00271         <span class="keywordflow">return</span> NULL;
00272     }
00273 
00274     <span class="keywordflow">if</span> (adfEnv.useProgressBar)
00275         (*adfEnv.progressBar)(20);
00276 
00277     <span class="keywordflow">if</span> (adfCreateBitmap( vol )!=RC_OK) {
00278         free(vol-&gt;volName); free(vol);
00279         <span class="keywordflow">return</span> NULL;
00280     }
00281 
00282     <span class="keywordflow">if</span> (adfEnv.useProgressBar)
00283         (*adfEnv.progressBar)(40);
00284 
00285 
00286 <span class="comment">/*for(i=0; i&lt;127; i++)</span>
00287 <span class="comment">printf("%3d %x, ",i,vol-&gt;bitmapTable[0]-&gt;map[i]);</span>
00288 <span class="comment">*/</span>
00289     <span class="keywordflow">if</span> ( isDIRCACHE(volType) )
00290         adfGetFreeBlocks( vol, 2, blkList );
00291     <span class="keywordflow">else</span>
00292         adfGetFreeBlocks( vol, 1, blkList );
00293 
00294 
00295 <span class="comment">/*printf("[0]=%d [1]=%d\n",blkList[0],blkList[1]);*/</span>
00296 
00297     memset(&amp;root, 0, LOGICAL_BLOCK_SIZE);
00298 
00299     <span class="keywordflow">if</span> (strlen(volName)&gt;MAXNAMELEN)
00300         volName[MAXNAMELEN]=<span class="charliteral">'\0'</span>;
00301     root.nameLen = strlen(volName);
00302     memcpy(root.diskName,volName,root.nameLen);
00303     adfTime2AmigaTime(adfGiveCurrentTime(),&amp;(root.coDays),&amp;(root.coMins),&amp;(root.coTicks));
00304 
00305     <span class="comment">/* dircache block */</span>
00306     <span class="keywordflow">if</span> ( isDIRCACHE(volType) ) {
00307         root.extension = 0L;
00308         root.secType = ST_ROOT; <span class="comment">/* needed by adfCreateEmptyCache() */</span>
00309         adfCreateEmptyCache(vol, (<span class="keyword">struct</span> bEntryBlock*)&amp;root, blkList[1]);
00310     }
00311 
00312     <span class="keywordflow">if</span> (adfEnv.useProgressBar)
00313         (*adfEnv.progressBar)(60);
00314 
00315     <span class="keywordflow">if</span> (adfWriteRootBlock(vol, blkList[0], &amp;root)!=RC_OK) {
00316         free(vol-&gt;volName); free(vol);
00317         <span class="keywordflow">return</span> NULL;
00318     }
00319 
00320    <span class="comment">/* fills root-&gt;bmPages[] and writes filled bitmapExtBlocks */</span>
00321     <span class="keywordflow">if</span> (adfWriteNewBitmap(vol)!=RC_OK)
00322         <span class="keywordflow">return</span> NULL;
00323 
00324     <span class="keywordflow">if</span> (adfEnv.useProgressBar)
00325         (*adfEnv.progressBar)(80);
00326 
00327     <span class="keywordflow">if</span> (adfUpdateBitmap(vol)!=RC_OK)
00328         <span class="keywordflow">return</span> NULL;
00329 
00330     <span class="keywordflow">if</span> (adfEnv.useProgressBar)
00331         (*adfEnv.progressBar)(100);
00332 <span class="comment">/*printf("free blocks %ld\n",adfCountFreeBlocks(vol));*/</span>
00333 
00334     <span class="comment">/* will be managed by adfMount() later */</span>
00335     adfFreeBitmap(vol);
00336 
00337     vol-&gt;mounted = FALSE;
00338 
00339     <span class="keywordflow">return</span>(vol);
00340 }
00341 
00342 
00343 <span class="comment">/*-----*/</span>
00344 
00345 <span class="comment">/*</span>
00346 <span class="comment"> * adfReadBlock</span>
00347 <span class="comment"> *</span>
00348 <span class="comment"> * read logical block</span>
00349 <span class="comment"> */</span>
00350 RETCODE
00351 adfReadBlock(<span class="keyword">struct</span> Volume* vol, <span class="keywordtype">long</span> nSect, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* buf)
00352 {
00353   <span class="comment">/*    char strBuf[80];*/</span>
00354     <span class="keywordtype">long</span> pSect;
00355     <span class="keyword">struct </span>nativeFunctions *nFct;
00356     RETCODE rc;
00357 
00358     <span class="keywordflow">if</span> (!vol-&gt;mounted) {
00359         (*adfEnv.eFct)(<span class="stringliteral">"the volume isn't mounted, adfReadBlock not possible"</span>);
00360         <span class="keywordflow">return</span> RC_ERROR;
00361     }
00362 
00363     <span class="comment">/* translate logical sect to physical sect */</span>
00364     pSect = nSect+vol-&gt;firstBlock;
00365 
00366     <span class="keywordflow">if</span> (adfEnv.useRWAccess)
00367         (*adfEnv.rwhAccess)(pSect,nSect,FALSE);
00368 
00369 <span class="comment">/*printf("psect=%ld nsect=%ld\n",pSect,nSect);*/</span>
00370 <span class="comment">/*    sprintf(strBuf,"ReadBlock : accessing logical block #%ld", nSect);    </span>
00371 <span class="comment">    (*adfEnv.vFct)(strBuf);</span>
00372 <span class="comment">*/</span>
00373     <span class="keywordflow">if</span> (pSect&lt;vol-&gt;firstBlock || pSect&gt;vol-&gt;lastBlock) {
00374         (*adfEnv.wFct)(<span class="stringliteral">"adfReadBlock : nSect out of range"</span>);
00375         
00376     }
00377 <span class="comment">/*printf("pSect R =%ld\n",pSect);*/</span>
00378     nFct = adfEnv.nativeFct;
00379     <span class="keywordflow">if</span> (vol-&gt;dev-&gt;isNativeDev)
00380         rc = (*nFct-&gt;adfNativeReadSector)(vol-&gt;dev, pSect, 512, buf);
00381     <span class="keywordflow">else</span>
00382         rc = adfReadDumpSector(vol-&gt;dev, pSect, 512, buf);
00383 <span class="comment">/*printf("rc=%ld\n",rc);*/</span>
00384     <span class="keywordflow">if</span> (rc!=RC_OK)
00385         <span class="keywordflow">return</span> RC_ERROR;
00386     <span class="keywordflow">else</span>
00387         <span class="keywordflow">return</span> RC_OK;
00388 }
00389 
00390 
00391 <span class="comment">/*</span>
00392 <span class="comment"> * adfWriteBlock</span>
00393 <span class="comment"> *</span>
00394 <span class="comment"> */</span>
00395 RETCODE adfWriteBlock(<span class="keyword">struct</span> Volume* vol, <span class="keywordtype">long</span> nSect, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *buf)
00396 {
00397     <span class="keywordtype">long</span> pSect;
00398     <span class="keyword">struct </span>nativeFunctions *nFct;
00399     RETCODE rc;
00400 
00401     <span class="keywordflow">if</span> (!vol-&gt;mounted) {
00402         (*adfEnv.eFct)(<span class="stringliteral">"the volume isn't mounted, adfWriteBlock not possible"</span>);
00403         <span class="keywordflow">return</span> RC_ERROR;
00404     }
00405 
00406     <span class="keywordflow">if</span> (vol-&gt;readOnly) {
00407         (*adfEnv.wFct)(<span class="stringliteral">"adfWriteBlock : can't write block, read only volume"</span>);
00408         <span class="keywordflow">return</span> RC_ERROR;
00409     }
00410 
00411     pSect = nSect+vol-&gt;firstBlock;
00412 <span class="comment">/*printf("write nsect=%ld psect=%ld\n",nSect,pSect);*/</span>
00413 
00414     <span class="keywordflow">if</span> (adfEnv.useRWAccess)
00415         (*adfEnv.rwhAccess)(pSect,nSect,TRUE);
00416  
00417     <span class="keywordflow">if</span> (pSect&lt;vol-&gt;firstBlock || pSect&gt;vol-&gt;lastBlock) {
00418         (*adfEnv.wFct)(<span class="stringliteral">"adfWriteBlock : nSect out of range"</span>);
00419     }
00420 
00421     nFct = adfEnv.nativeFct;
00422 <span class="comment">/*printf("nativ=%d\n",vol-&gt;dev-&gt;isNativeDev);*/</span>
00423     <span class="keywordflow">if</span> (vol-&gt;dev-&gt;isNativeDev)
00424         rc = (*nFct-&gt;adfNativeWriteSector)(vol-&gt;dev, pSect, 512, buf);
00425     <span class="keywordflow">else</span>
00426         rc = adfWriteDumpSector(vol-&gt;dev, pSect, 512, buf);
00427 
00428     <span class="keywordflow">if</span> (rc!=RC_OK)
00429         <span class="keywordflow">return</span> RC_ERROR;
00430     <span class="keywordflow">else</span>
00431         <span class="keywordflow">return</span> RC_OK;
00432 }
00433 
00434 
00435 
00436 <span class="comment">/*#######################################################################################*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:38 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

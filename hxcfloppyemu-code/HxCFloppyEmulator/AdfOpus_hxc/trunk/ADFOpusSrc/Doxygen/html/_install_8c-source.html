<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Install.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>Install.c</h1><a href="_install_8c.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/* ADF Opus Copyright 1998-2002 by </span>
00002 <span class="comment"> * Dan Sutherland &lt;dan@chromerhino.demon.co.uk&gt; and Gary Harris &lt;gharris@zip.com.au&gt;.   </span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> *  This code by Gary Harris.</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> */</span>
00014 <span class="preprocessor">#include "Install.h"</span>
00015 
00016     
00017 <span class="keyword">extern</span> <span class="keywordtype">char</span> gstrFileName[MAX_PATH * 2];
00018 
00019 
00020 InstallBootBlock(HWND win, <span class="keyword">struct</span> Volume *vol)
00021 {
00022     FILE* boot;
00023     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>   bootcode[1024];
00024     <span class="keywordtype">char</span>            *szWarning = <span class="stringliteral">"ADFLib is unable to detect whether or not existing boot code is valid. "</span>
00025                                 <span class="stringliteral">"You should display the bootblock to get some idea of whether or not it"</span>
00026                                 <span class="stringliteral">"contains reasonable looking code and test bootblock installation on a "</span>
00027                                 <span class="stringliteral">"copy of the ADF unless you are sure you want to continue. Overwriting "</span>
00028                                 <span class="stringliteral">"many non-standard or proprietry bootblocks will invalidate the ADF."</span>
00029                                 <span class="stringliteral">"\n\nDo you still want to install the new bootblock?"</span>;
00030  
00031     <span class="keywordtype">char</span>            *szBBMissing = <span class="stringliteral">"ADF Opus can't open the bootblock file. Please make sure that the "</span>
00032                                 <span class="stringliteral">"bootblock (\"stdboot3.bbk\") is located in a sub-directory called \"Boot\" "</span>
00033                                 <span class="stringliteral">"in the directory where ADF Opus is installed. This should automatically be "</span>
00034                                 <span class="stringliteral">"the case if you use any of the automated installation methods."</span>;
00035 
00036 
00037     <span class="keywordflow">if</span>(MessageBox(win, szWarning, <span class="stringliteral">"ADF Opus Warning!"</span>, MB_YESNO|MB_ICONWARNING) == IDYES){
00038         boot = fopen(<span class="stringliteral">"Boot\\stdboot3.bbk"</span>, <span class="stringliteral">"rb"</span>);
00039         <span class="keywordflow">if</span> (!boot) {
00040             MessageBox(win, szBBMissing, <span class="stringliteral">"ADF Opus error"</span>, MB_OK|MB_ICONERROR);
00041             <span class="keywordflow">return</span>(1);
00042         }
00043         fread(bootcode, <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>), 1024, boot);
00044         fclose(boot);
00045         
00046         <span class="keywordflow">if</span>(adfInstallBootBlock(vol,  bootcode) != RC_OK)
00047             <span class="keywordflow">return</span> 1;
00048     }
00049     <span class="keywordflow">return</span> 0;
00050 }
00051 
00052 
00053 
00055 
00056 <span class="comment">//BOOL CheckForNDOS()</span>
00057 
00058 <span class="comment">/*first look if there is the DOS letters at the 3 first bytes of the bootblock,</span>
00059 <span class="comment">then look if there is code at the 12th byte (this byte and the 3 following must not be 0).</span>
00060 <span class="comment"></span>
00061 <span class="comment">working bootcode is at least around 20 bytes long...</span>
00062 <span class="comment"></span>
00063 <span class="comment">one simple way to offer better information is to display the bootblocks sectors...</span>
00064 <span class="comment">0-31 and 128-255 should be remplaced by a '.'...</span>
00065 <span class="comment">*/</span><span class="comment">/*</span>
00066 <span class="comment">{</span>
00067 <span class="comment">    HANDLE              hFile;</span>
00068 <span class="comment">    char                lpBuffer[4];</span>
00069 <span class="comment">    LPDWORD             lpNumberOfBytesRead = 0; //**********</span>
00070 <span class="comment">    long                longFilePtr;</span>
00071 <span class="comment">    struct nativeDevice *nDev;</span>
00072 <span class="comment"> </span>
00073 <span class="comment"></span>
00074 <span class="comment">    DWORD   retval;</span>
00075 <span class="comment">    </span>
00076 <span class="comment">//  hFile = CreateFile(gstrFileName, GENERIC_READ, 0, NULL, OPEN_EXISTING, </span>
00077 <span class="comment">//                      FILE_ATTRIBUTE_NORMAL, NULL);</span>
00078 <span class="comment">//  retval = GetLastError(); //**********</span>
00079 <span class="comment"></span>
00080 <span class="comment">    nDev = ci-&gt;dev-&gt;nativeDev;</span>
00081 <span class="comment">    longFilePtr = ftell(nDev-&gt;fd);          // Get position of file pointer.</span>
00082 <span class="comment">    fseek(nDev-&gt;fd, 0, SEEK_SET);           // Seek to start of file.</span>
00083 <span class="comment"></span>
00084 <span class="comment">    // Read the first 3 bytes and check for "DOS".</span>
00085 <span class="comment">//  if(!ReadFile(nDev-&gt;fd, lpBuffer, 3, lpNumberOfBytesRead, NULL))</span>
00086 <span class="comment">//      ;</span>
00087 <span class="comment"></span>
00088 <span class="comment">//size_t fread( void *buffer, size_t size, size_t count, FILE *stream );        </span>
00089 <span class="comment">    retval = GetLastError(); //**********</span>
00090 <span class="comment"></span>
00091 <span class="comment">    fseek(nDev-&gt;fd, longFilePtr, SEEK_SET); // Reset file pointer to where we found it.</span>
00092 <span class="comment"></span>
00093 <span class="comment"></span>
00094 <span class="comment"></span>
00095 <span class="comment">    return TRUE;</span>
00096 <span class="comment">}</span>
00097 <span class="comment">*/</span>
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:42 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

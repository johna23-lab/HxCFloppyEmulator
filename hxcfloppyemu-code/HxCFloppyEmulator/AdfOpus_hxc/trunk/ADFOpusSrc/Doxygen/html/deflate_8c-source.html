<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>deflate.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>deflate.c</h1><div class="fragment"><pre>00001 <span class="comment">/* deflate.c -- compress data using the deflation algorithm</span>
00002 <span class="comment"> * Copyright (C) 1995-2002 Jean-loup Gailly.</span>
00003 <span class="comment"> * For conditions of distribution and use, see copyright notice in zlib.h </span>
00004 <span class="comment"> */</span>
00005 
00006 <span class="comment">/*</span>
00007 <span class="comment"> *  ALGORITHM</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> *      The "deflation" process depends on being able to identify portions</span>
00010 <span class="comment"> *      of the input text which are identical to earlier input (within a</span>
00011 <span class="comment"> *      sliding window trailing behind the input currently being processed).</span>
00012 <span class="comment"> *</span>
00013 <span class="comment"> *      The most straightforward technique turns out to be the fastest for</span>
00014 <span class="comment"> *      most input files: try all possible matches and select the longest.</span>
00015 <span class="comment"> *      The key feature of this algorithm is that insertions into the string</span>
00016 <span class="comment"> *      dictionary are very simple and thus fast, and deletions are avoided</span>
00017 <span class="comment"> *      completely. Insertions are performed at each input character, whereas</span>
00018 <span class="comment"> *      string matches are performed only when the previous match ends. So it</span>
00019 <span class="comment"> *      is preferable to spend more time in matches to allow very fast string</span>
00020 <span class="comment"> *      insertions and avoid deletions. The matching algorithm for small</span>
00021 <span class="comment"> *      strings is inspired from that of Rabin &amp; Karp. A brute force approach</span>
00022 <span class="comment"> *      is used to find longer strings when a small match has been found.</span>
00023 <span class="comment"> *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze</span>
00024 <span class="comment"> *      (by Leonid Broukhis).</span>
00025 <span class="comment"> *         A previous version of this file used a more sophisticated algorithm</span>
00026 <span class="comment"> *      (by Fiala and Greene) which is guaranteed to run in linear amortized</span>
00027 <span class="comment"> *      time, but has a larger average cost, uses more memory and is patented.</span>
00028 <span class="comment"> *      However the F&amp;G algorithm may be faster for some highly redundant</span>
00029 <span class="comment"> *      files if the parameter max_chain_length (described below) is too large.</span>
00030 <span class="comment"> *</span>
00031 <span class="comment"> *  ACKNOWLEDGEMENTS</span>
00032 <span class="comment"> *</span>
00033 <span class="comment"> *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and</span>
00034 <span class="comment"> *      I found it in 'freeze' written by Leonid Broukhis.</span>
00035 <span class="comment"> *      Thanks to many people for bug reports and testing.</span>
00036 <span class="comment"> *</span>
00037 <span class="comment"> *  REFERENCES</span>
00038 <span class="comment"> *</span>
00039 <span class="comment"> *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".</span>
00040 <span class="comment"> *      Available in ftp://ds.internic.net/rfc/rfc1951.txt</span>
00041 <span class="comment"> *</span>
00042 <span class="comment"> *      A description of the Rabin and Karp algorithm is given in the book</span>
00043 <span class="comment"> *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.</span>
00044 <span class="comment"> *</span>
00045 <span class="comment"> *      Fiala,E.R., and Greene,D.H.</span>
00046 <span class="comment"> *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595</span>
00047 <span class="comment"> *</span>
00048 <span class="comment"> */</span>
00049 
00050 <span class="comment">/* @(#) $Id: deflate_8c-source.html,v 1.1 2002/11/14 01:50:01 garyjharris Exp $ */</span>
00051 
00052 <span class="preprocessor">#include "deflate.h"</span>
00053 
00054 <span class="keyword">const</span> <span class="keywordtype">char</span> deflate_copyright[] =
00055    <span class="stringliteral">" deflate 1.1.4 Copyright 1995-2002 Jean-loup Gailly "</span>;
00056 <span class="comment">/*</span>
00057 <span class="comment">  If you use the zlib library in a product, an acknowledgment is welcome</span>
00058 <span class="comment">  in the documentation of your product. If for some reason you cannot</span>
00059 <span class="comment">  include such an acknowledgment, I would appreciate that you keep this</span>
00060 <span class="comment">  copyright string in the executable of your product.</span>
00061 <span class="comment"> */</span>
00062 
00063 <span class="comment">/* ===========================================================================</span>
00064 <span class="comment"> *  Function prototypes.</span>
00065 <span class="comment"> */</span>
00066 <span class="keyword">typedef</span> <span class="keyword">enum</span> {
00067     need_more,      <span class="comment">/* block not completed, need more input or more output */</span>
00068     block_done,     <span class="comment">/* block flush performed */</span>
00069     finish_started, <span class="comment">/* finish started, need only more output at next deflate */</span>
00070     finish_done     <span class="comment">/* finish done, accept no more input or output */</span>
00071 } block_state;
00072 
00073 <span class="keyword">typedef</span> block_state (*compress_func) OF((deflate_state *s, <span class="keywordtype">int</span> flush));
00074 <span class="comment">/* Compression function. Returns the block state after the call. */</span>
00075 
00076 local <span class="keywordtype">void</span> fill_window    OF((deflate_state *s));
00077 local block_state deflate_stored OF((deflate_state *s, <span class="keywordtype">int</span> flush));
00078 local block_state deflate_fast   OF((deflate_state *s, <span class="keywordtype">int</span> flush));
00079 local block_state deflate_slow   OF((deflate_state *s, <span class="keywordtype">int</span> flush));
00080 local <span class="keywordtype">void</span> lm_init        OF((deflate_state *s));
00081 local <span class="keywordtype">void</span> putShortMSB    OF((deflate_state *s, uInt b));
00082 local <span class="keywordtype">void</span> flush_pending  OF((z_streamp strm));
00083 local <span class="keywordtype">int</span> read_buf        OF((z_streamp strm, Bytef *buf, <span class="keywordtype">unsigned</span> size));
00084 <span class="preprocessor">#ifdef ASMV</span>
00085 <span class="preprocessor"></span>      <span class="keywordtype">void</span> match_init OF((<span class="keywordtype">void</span>)); <span class="comment">/* asm code initialization */</span>
00086       uInt longest_match  OF((deflate_state *s, IPos cur_match));
00087 <span class="preprocessor">#else</span>
00088 <span class="preprocessor"></span>local uInt longest_match  OF((deflate_state *s, IPos cur_match));
00089 <span class="preprocessor">#endif</span>
00090 <span class="preprocessor"></span>
00091 <span class="preprocessor">#ifdef DEBUG</span>
00092 <span class="preprocessor"></span>local  <span class="keywordtype">void</span> check_match OF((deflate_state *s, IPos start, IPos match,
00093                             <span class="keywordtype">int</span> length));
00094 <span class="preprocessor">#endif</span>
00095 <span class="preprocessor"></span>
00096 <span class="comment">/* ===========================================================================</span>
00097 <span class="comment"> * Local data</span>
00098 <span class="comment"> */</span>
00099 
00100 <span class="preprocessor">#define NIL 0</span>
00101 <span class="preprocessor"></span><span class="comment">/* Tail of hash chains */</span>
00102 
00103 <span class="preprocessor">#ifndef TOO_FAR</span>
00104 <span class="preprocessor"></span><span class="preprocessor">#  define TOO_FAR 4096</span>
00105 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00106 <span class="preprocessor"></span><span class="comment">/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */</span>
00107 
00108 <span class="preprocessor">#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)</span>
00109 <span class="preprocessor"></span><span class="comment">/* Minimum amount of lookahead, except at the end of the input file.</span>
00110 <span class="comment"> * See deflate.c for comments about the MIN_MATCH+1.</span>
00111 <span class="comment"> */</span>
00112 
00113 <span class="comment">/* Values for max_lazy_match, good_match and max_chain_length, depending on</span>
00114 <span class="comment"> * the desired pack level (0..9). The values given below have been tuned to</span>
00115 <span class="comment"> * exclude worst case performance for pathological files. Better values may be</span>
00116 <span class="comment"> * found for specific files.</span>
00117 <span class="comment"> */</span>
00118 <span class="keyword">typedef</span> <span class="keyword">struct </span>config_s {
00119    ush good_length; <span class="comment">/* reduce lazy search above this match length */</span>
00120    ush max_lazy;    <span class="comment">/* do not perform lazy search above this match length */</span>
00121    ush nice_length; <span class="comment">/* quit search above this match length */</span>
00122    ush max_chain;
00123    compress_func func;
00124 } config;
00125 
00126 local <span class="keyword">const</span> config configuration_table[10] = {
00127 <span class="comment">/*      good lazy nice chain */</span>
00128 <span class="comment">/* 0 */</span> {0,    0,  0,    0, deflate_stored},  <span class="comment">/* store only */</span>
00129 <span class="comment">/* 1 */</span> {4,    4,  8,    4, deflate_fast}, <span class="comment">/* maximum speed, no lazy matches */</span>
00130 <span class="comment">/* 2 */</span> {4,    5, 16,    8, deflate_fast},
00131 <span class="comment">/* 3 */</span> {4,    6, 32,   32, deflate_fast},
00132 
00133 <span class="comment">/* 4 */</span> {4,    4, 16,   16, deflate_slow},  <span class="comment">/* lazy matches */</span>
00134 <span class="comment">/* 5 */</span> {8,   16, 32,   32, deflate_slow},
00135 <span class="comment">/* 6 */</span> {8,   16, 128, 128, deflate_slow},
00136 <span class="comment">/* 7 */</span> {8,   32, 128, 256, deflate_slow},
00137 <span class="comment">/* 8 */</span> {32, 128, 258, 1024, deflate_slow},
00138 <span class="comment">/* 9 */</span> {32, 258, 258, 4096, deflate_slow}}; <span class="comment">/* maximum compression */</span>
00139 
00140 <span class="comment">/* Note: the deflate() code requires max_lazy &gt;= MIN_MATCH and max_chain &gt;= 4</span>
00141 <span class="comment"> * For deflate_fast() (levels &lt;= 3) good is ignored and lazy has a different</span>
00142 <span class="comment"> * meaning.</span>
00143 <span class="comment"> */</span>
00144 
00145 <span class="preprocessor">#define EQUAL 0</span>
00146 <span class="preprocessor"></span><span class="comment">/* result of memcmp for equal strings */</span>
00147 
00148 <span class="keyword">struct </span>static_tree_desc_s {<span class="keywordtype">int</span> dummy;}; <span class="comment">/* for buggy compilers */</span>
00149 
00150 <span class="comment">/* ===========================================================================</span>
00151 <span class="comment"> * Update a hash value with the given input byte</span>
00152 <span class="comment"> * IN  assertion: all calls to to UPDATE_HASH are made with consecutive</span>
00153 <span class="comment"> *    input characters, so that a running hash key can be computed from the</span>
00154 <span class="comment"> *    previous key instead of complete recalculation each time.</span>
00155 <span class="comment"> */</span>
00156 <span class="preprocessor">#define UPDATE_HASH(s,h,c) (h = (((h)&lt;&lt;s-&gt;hash_shift) ^ (c)) &amp; s-&gt;hash_mask)</span>
00157 <span class="preprocessor"></span>
00158 
00159 <span class="comment">/* ===========================================================================</span>
00160 <span class="comment"> * Insert string str in the dictionary and set match_head to the previous head</span>
00161 <span class="comment"> * of the hash chain (the most recent string with same hash key). Return</span>
00162 <span class="comment"> * the previous length of the hash chain.</span>
00163 <span class="comment"> * If this file is compiled with -DFASTEST, the compression level is forced</span>
00164 <span class="comment"> * to 1, and no hash chains are maintained.</span>
00165 <span class="comment"> * IN  assertion: all calls to to INSERT_STRING are made with consecutive</span>
00166 <span class="comment"> *    input characters and the first MIN_MATCH bytes of str are valid</span>
00167 <span class="comment"> *    (except for the last MIN_MATCH-1 bytes of the input file).</span>
00168 <span class="comment"> */</span>
00169 <span class="preprocessor">#ifdef FASTEST</span>
00170 <span class="preprocessor"></span><span class="preprocessor">#define INSERT_STRING(s, str, match_head) \</span>
00171 <span class="preprocessor">   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \</span>
00172 <span class="preprocessor">    match_head = s-&gt;head[s-&gt;ins_h], \</span>
00173 <span class="preprocessor">    s-&gt;head[s-&gt;ins_h] = (Pos)(str))</span>
00174 <span class="preprocessor"></span><span class="preprocessor">#else</span>
00175 <span class="preprocessor"></span><span class="preprocessor">#define INSERT_STRING(s, str, match_head) \</span>
00176 <span class="preprocessor">   (UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[(str) + (MIN_MATCH-1)]), \</span>
00177 <span class="preprocessor">    s-&gt;prev[(str) &amp; s-&gt;w_mask] = match_head = s-&gt;head[s-&gt;ins_h], \</span>
00178 <span class="preprocessor">    s-&gt;head[s-&gt;ins_h] = (Pos)(str))</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00180 <span class="preprocessor"></span>
00181 <span class="comment">/* ===========================================================================</span>
00182 <span class="comment"> * Initialize the hash table (avoiding 64K overflow for 16 bit systems).</span>
00183 <span class="comment"> * prev[] will be initialized on the fly.</span>
00184 <span class="comment"> */</span>
00185 <span class="preprocessor">#define CLEAR_HASH(s) \</span>
00186 <span class="preprocessor">    s-&gt;head[s-&gt;hash_size-1] = NIL; \</span>
00187 <span class="preprocessor">    zmemzero((Bytef *)s-&gt;head, (unsigned)(s-&gt;hash_size-1)*sizeof(*s-&gt;head));</span>
00188 <span class="preprocessor"></span>
00189 <span class="comment">/* ========================================================================= */</span>
00190 <span class="keywordtype">int</span> ZEXPORT deflateInit_(strm, level, version, stream_size)
00191     z_streamp strm;
00192     <span class="keywordtype">int</span> level;
00193     <span class="keyword">const</span> <span class="keywordtype">char</span> *version;
00194     <span class="keywordtype">int</span> stream_size;
00195 {
00196     <span class="keywordflow">return</span> deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
00197              Z_DEFAULT_STRATEGY, version, stream_size);
00198     <span class="comment">/* To do: ignore strm-&gt;next_in if we use it as window */</span>
00199 }
00200 
00201 <span class="comment">/* ========================================================================= */</span>
00202 <span class="keywordtype">int</span> ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
00203           version, stream_size)
00204     z_streamp strm;
00205     <span class="keywordtype">int</span>  level;
00206     <span class="keywordtype">int</span>  method;
00207     <span class="keywordtype">int</span>  windowBits;
00208     <span class="keywordtype">int</span>  memLevel;
00209     <span class="keywordtype">int</span>  strategy;
00210     <span class="keyword">const</span> <span class="keywordtype">char</span> *version;
00211     <span class="keywordtype">int</span> stream_size;
00212 {
00213     deflate_state *s;
00214     <span class="keywordtype">int</span> noheader = 0;
00215     <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* my_version = ZLIB_VERSION;
00216 
00217     ushf *overlay;
00218     <span class="comment">/* We overlay pending_buf and d_buf+l_buf. This works since the average</span>
00219 <span class="comment">     * output size for (length,distance) codes is &lt;= 24 bits.</span>
00220 <span class="comment">     */</span>
00221 
00222     <span class="keywordflow">if</span> (version == Z_NULL || version[0] != my_version[0] ||
00223         stream_size != <span class="keyword">sizeof</span>(z_stream)) {
00224     <span class="keywordflow">return</span> Z_VERSION_ERROR;
00225     }
00226     <span class="keywordflow">if</span> (strm == Z_NULL) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00227 
00228     strm-&gt;msg = Z_NULL;
00229     <span class="keywordflow">if</span> (strm-&gt;zalloc == Z_NULL) {
00230     strm-&gt;zalloc = zcalloc;
00231     strm-&gt;opaque = (voidpf)0;
00232     }
00233     <span class="keywordflow">if</span> (strm-&gt;zfree == Z_NULL) strm-&gt;zfree = zcfree;
00234 
00235     <span class="keywordflow">if</span> (level == Z_DEFAULT_COMPRESSION) level = 6;
00236 <span class="preprocessor">#ifdef FASTEST</span>
00237 <span class="preprocessor"></span>    level = 1;
00238 <span class="preprocessor">#endif</span>
00239 <span class="preprocessor"></span>
00240     <span class="keywordflow">if</span> (windowBits &lt; 0) { <span class="comment">/* undocumented feature: suppress zlib header */</span>
00241         noheader = 1;
00242         windowBits = -windowBits;
00243     }
00244     <span class="keywordflow">if</span> (memLevel &lt; 1 || memLevel &gt; MAX_MEM_LEVEL || method != Z_DEFLATED ||
00245         windowBits &lt; 9 || windowBits &gt; 15 || level &lt; 0 || level &gt; 9 ||
00246     strategy &lt; 0 || strategy &gt; Z_HUFFMAN_ONLY) {
00247         <span class="keywordflow">return</span> Z_STREAM_ERROR;
00248     }
00249     s = (deflate_state *) ZALLOC(strm, 1, <span class="keyword">sizeof</span>(deflate_state));
00250     <span class="keywordflow">if</span> (s == Z_NULL) <span class="keywordflow">return</span> Z_MEM_ERROR;
00251     strm-&gt;state = (<span class="keyword">struct </span>internal_state FAR *)s;
00252     s-&gt;strm = strm;
00253 
00254     s-&gt;noheader = noheader;
00255     s-&gt;w_bits = windowBits;
00256     s-&gt;w_size = 1 &lt;&lt; s-&gt;w_bits;
00257     s-&gt;w_mask = s-&gt;w_size - 1;
00258 
00259     s-&gt;hash_bits = memLevel + 7;
00260     s-&gt;hash_size = 1 &lt;&lt; s-&gt;hash_bits;
00261     s-&gt;hash_mask = s-&gt;hash_size - 1;
00262     s-&gt;hash_shift =  ((s-&gt;hash_bits+MIN_MATCH-1)/MIN_MATCH);
00263 
00264     s-&gt;window = (Bytef *) ZALLOC(strm, s-&gt;w_size, 2*<span class="keyword">sizeof</span>(Byte));
00265     s-&gt;prev   = (Posf *)  ZALLOC(strm, s-&gt;w_size, <span class="keyword">sizeof</span>(Pos));
00266     s-&gt;head   = (Posf *)  ZALLOC(strm, s-&gt;hash_size, <span class="keyword">sizeof</span>(Pos));
00267 
00268     s-&gt;lit_bufsize = 1 &lt;&lt; (memLevel + 6); <span class="comment">/* 16K elements by default */</span>
00269 
00270     overlay = (ushf *) ZALLOC(strm, s-&gt;lit_bufsize, <span class="keyword">sizeof</span>(ush)+2);
00271     s-&gt;pending_buf = (uchf *) overlay;
00272     s-&gt;pending_buf_size = (ulg)s-&gt;lit_bufsize * (<span class="keyword">sizeof</span>(ush)+2L);
00273 
00274     <span class="keywordflow">if</span> (s-&gt;window == Z_NULL || s-&gt;prev == Z_NULL || s-&gt;head == Z_NULL ||
00275         s-&gt;pending_buf == Z_NULL) {
00276         strm-&gt;msg = (<span class="keywordtype">char</span>*)ERR_MSG(Z_MEM_ERROR);
00277         deflateEnd (strm);
00278         <span class="keywordflow">return</span> Z_MEM_ERROR;
00279     }
00280     s-&gt;d_buf = overlay + s-&gt;lit_bufsize/<span class="keyword">sizeof</span>(ush);
00281     s-&gt;l_buf = s-&gt;pending_buf + (1+<span class="keyword">sizeof</span>(ush))*s-&gt;lit_bufsize;
00282 
00283     s-&gt;level = level;
00284     s-&gt;strategy = strategy;
00285     s-&gt;method = (Byte)method;
00286 
00287     <span class="keywordflow">return</span> deflateReset(strm);
00288 }
00289 
00290 <span class="comment">/* ========================================================================= */</span>
00291 <span class="keywordtype">int</span> ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
00292     z_streamp strm;
00293     <span class="keyword">const</span> Bytef *dictionary;
00294     uInt  dictLength;
00295 {
00296     deflate_state *s;
00297     uInt length = dictLength;
00298     uInt n;
00299     IPos hash_head = 0;
00300 
00301     <span class="keywordflow">if</span> (strm == Z_NULL || strm-&gt;state == Z_NULL || dictionary == Z_NULL ||
00302         strm-&gt;state-&gt;status != INIT_STATE) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00303 
00304     s = strm-&gt;state;
00305     strm-&gt;adler = adler32(strm-&gt;adler, dictionary, dictLength);
00306 
00307     <span class="keywordflow">if</span> (length &lt; MIN_MATCH) <span class="keywordflow">return</span> Z_OK;
00308     <span class="keywordflow">if</span> (length &gt; MAX_DIST(s)) {
00309     length = MAX_DIST(s);
00310 <span class="preprocessor">#ifndef USE_DICT_HEAD</span>
00311 <span class="preprocessor"></span>    dictionary += dictLength - length; <span class="comment">/* use the tail of the dictionary */</span>
00312 <span class="preprocessor">#endif</span>
00313 <span class="preprocessor"></span>    }
00314     zmemcpy(s-&gt;window, dictionary, length);
00315     s-&gt;strstart = length;
00316     s-&gt;block_start = (long)length;
00317 
00318     <span class="comment">/* Insert all strings in the hash table (except for the last two bytes).</span>
00319 <span class="comment">     * s-&gt;lookahead stays null, so s-&gt;ins_h will be recomputed at the next</span>
00320 <span class="comment">     * call of fill_window.</span>
00321 <span class="comment">     */</span>
00322     s-&gt;ins_h = s-&gt;window[0];
00323     UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[1]);
00324     <span class="keywordflow">for</span> (n = 0; n &lt;= length - MIN_MATCH; n++) {
00325     INSERT_STRING(s, n, hash_head);
00326     }
00327     <span class="keywordflow">if</span> (hash_head) hash_head = 0;  <span class="comment">/* to make compiler happy */</span>
00328     <span class="keywordflow">return</span> Z_OK;
00329 }
00330 
00331 <span class="comment">/* ========================================================================= */</span>
00332 <span class="keywordtype">int</span> ZEXPORT deflateReset (strm)
00333     z_streamp strm;
00334 {
00335     deflate_state *s;
00336     
00337     <span class="keywordflow">if</span> (strm == Z_NULL || strm-&gt;state == Z_NULL ||
00338         strm-&gt;zalloc == Z_NULL || strm-&gt;zfree == Z_NULL) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00339 
00340     strm-&gt;total_in = strm-&gt;total_out = 0;
00341     strm-&gt;msg = Z_NULL; <span class="comment">/* use zfree if we ever allocate msg dynamically */</span>
00342     strm-&gt;data_type = Z_UNKNOWN;
00343 
00344     s = (deflate_state *)strm-&gt;state;
00345     s-&gt;pending = 0;
00346     s-&gt;pending_out = s-&gt;pending_buf;
00347 
00348     <span class="keywordflow">if</span> (s-&gt;noheader &lt; 0) {
00349         s-&gt;noheader = 0; <span class="comment">/* was set to -1 by deflate(..., Z_FINISH); */</span>
00350     }
00351     s-&gt;status = s-&gt;noheader ? BUSY_STATE : INIT_STATE;
00352     strm-&gt;adler = 1;
00353     s-&gt;last_flush = Z_NO_FLUSH;
00354 
00355     _tr_init(s);
00356     lm_init(s);
00357 
00358     <span class="keywordflow">return</span> Z_OK;
00359 }
00360 
00361 <span class="comment">/* ========================================================================= */</span>
00362 <span class="keywordtype">int</span> ZEXPORT deflateParams(strm, level, strategy)
00363     z_streamp strm;
00364     <span class="keywordtype">int</span> level;
00365     <span class="keywordtype">int</span> strategy;
00366 {
00367     deflate_state *s;
00368     compress_func func;
00369     <span class="keywordtype">int</span> err = Z_OK;
00370 
00371     <span class="keywordflow">if</span> (strm == Z_NULL || strm-&gt;state == Z_NULL) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00372     s = strm-&gt;state;
00373 
00374     <span class="keywordflow">if</span> (level == Z_DEFAULT_COMPRESSION) {
00375     level = 6;
00376     }
00377     <span class="keywordflow">if</span> (level &lt; 0 || level &gt; 9 || strategy &lt; 0 || strategy &gt; Z_HUFFMAN_ONLY) {
00378     <span class="keywordflow">return</span> Z_STREAM_ERROR;
00379     }
00380     func = configuration_table[s-&gt;level].func;
00381 
00382     <span class="keywordflow">if</span> (func != configuration_table[level].func &amp;&amp; strm-&gt;total_in != 0) {
00383     <span class="comment">/* Flush the last buffer: */</span>
00384     err = deflate(strm, Z_PARTIAL_FLUSH);
00385     }
00386     <span class="keywordflow">if</span> (s-&gt;level != level) {
00387     s-&gt;level = level;
00388     s-&gt;max_lazy_match   = configuration_table[level].max_lazy;
00389     s-&gt;good_match       = configuration_table[level].good_length;
00390     s-&gt;nice_match       = configuration_table[level].nice_length;
00391     s-&gt;max_chain_length = configuration_table[level].max_chain;
00392     }
00393     s-&gt;strategy = strategy;
00394     <span class="keywordflow">return</span> err;
00395 }
00396 
00397 <span class="comment">/* =========================================================================</span>
00398 <span class="comment"> * Put a short in the pending buffer. The 16-bit value is put in MSB order.</span>
00399 <span class="comment"> * IN assertion: the stream state is correct and there is enough room in</span>
00400 <span class="comment"> * pending_buf.</span>
00401 <span class="comment"> */</span>
00402 local <span class="keywordtype">void</span> putShortMSB (s, b)
00403     deflate_state *s;
00404     uInt b;
00405 {
00406     put_byte(s, (Byte)(b &gt;&gt; 8));
00407     put_byte(s, (Byte)(b &amp; 0xff));
00408 }   
00409 
00410 <span class="comment">/* =========================================================================</span>
00411 <span class="comment"> * Flush as much pending output as possible. All deflate() output goes</span>
00412 <span class="comment"> * through this function so some applications may wish to modify it</span>
00413 <span class="comment"> * to avoid allocating a large strm-&gt;next_out buffer and copying into it.</span>
00414 <span class="comment"> * (See also read_buf()).</span>
00415 <span class="comment"> */</span>
00416 local <span class="keywordtype">void</span> flush_pending(strm)
00417     z_streamp strm;
00418 {
00419     <span class="keywordtype">unsigned</span> len = strm-&gt;state-&gt;pending;
00420 
00421     <span class="keywordflow">if</span> (len &gt; strm-&gt;avail_out) len = strm-&gt;avail_out;
00422     <span class="keywordflow">if</span> (len == 0) <span class="keywordflow">return</span>;
00423 
00424     zmemcpy(strm-&gt;next_out, strm-&gt;state-&gt;pending_out, len);
00425     strm-&gt;next_out  += len;
00426     strm-&gt;state-&gt;pending_out  += len;
00427     strm-&gt;total_out += len;
00428     strm-&gt;avail_out  -= len;
00429     strm-&gt;state-&gt;pending -= len;
00430     <span class="keywordflow">if</span> (strm-&gt;state-&gt;pending == 0) {
00431         strm-&gt;state-&gt;pending_out = strm-&gt;state-&gt;pending_buf;
00432     }
00433 }
00434 
00435 <span class="comment">/* ========================================================================= */</span>
00436 <span class="keywordtype">int</span> ZEXPORT deflate (strm, flush)
00437     z_streamp strm;
00438     <span class="keywordtype">int</span> flush;
00439 {
00440     <span class="keywordtype">int</span> old_flush; <span class="comment">/* value of flush param for previous deflate call */</span>
00441     deflate_state *s;
00442 
00443     <span class="keywordflow">if</span> (strm == Z_NULL || strm-&gt;state == Z_NULL ||
00444     flush &gt; Z_FINISH || flush &lt; 0) {
00445         <span class="keywordflow">return</span> Z_STREAM_ERROR;
00446     }
00447     s = strm-&gt;state;
00448 
00449     <span class="keywordflow">if</span> (strm-&gt;next_out == Z_NULL ||
00450         (strm-&gt;next_in == Z_NULL &amp;&amp; strm-&gt;avail_in != 0) ||
00451     (s-&gt;status == FINISH_STATE &amp;&amp; flush != Z_FINISH)) {
00452         ERR_RETURN(strm, Z_STREAM_ERROR);
00453     }
00454     <span class="keywordflow">if</span> (strm-&gt;avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);
00455 
00456     s-&gt;strm = strm; <span class="comment">/* just in case */</span>
00457     old_flush = s-&gt;last_flush;
00458     s-&gt;last_flush = flush;
00459 
00460     <span class="comment">/* Write the zlib header */</span>
00461     <span class="keywordflow">if</span> (s-&gt;status == INIT_STATE) {
00462 
00463         uInt header = (Z_DEFLATED + ((s-&gt;w_bits-8)&lt;&lt;4)) &lt;&lt; 8;
00464         uInt level_flags = (s-&gt;level-1) &gt;&gt; 1;
00465 
00466         <span class="keywordflow">if</span> (level_flags &gt; 3) level_flags = 3;
00467         header |= (level_flags &lt;&lt; 6);
00468     <span class="keywordflow">if</span> (s-&gt;strstart != 0) header |= PRESET_DICT;
00469         header += 31 - (header % 31);
00470 
00471         s-&gt;status = BUSY_STATE;
00472         putShortMSB(s, header);
00473 
00474     <span class="comment">/* Save the adler32 of the preset dictionary: */</span>
00475     <span class="keywordflow">if</span> (s-&gt;strstart != 0) {
00476         putShortMSB(s, (uInt)(strm-&gt;adler &gt;&gt; 16));
00477         putShortMSB(s, (uInt)(strm-&gt;adler &amp; 0xffff));
00478     }
00479     strm-&gt;adler = 1L;
00480     }
00481 
00482     <span class="comment">/* Flush as much pending output as possible */</span>
00483     <span class="keywordflow">if</span> (s-&gt;pending != 0) {
00484         flush_pending(strm);
00485         <span class="keywordflow">if</span> (strm-&gt;avail_out == 0) {
00486         <span class="comment">/* Since avail_out is 0, deflate will be called again with</span>
00487 <span class="comment">         * more output space, but possibly with both pending and</span>
00488 <span class="comment">         * avail_in equal to zero. There won't be anything to do,</span>
00489 <span class="comment">         * but this is not an error situation so make sure we</span>
00490 <span class="comment">         * return OK instead of BUF_ERROR at next call of deflate:</span>
00491 <span class="comment">             */</span>
00492         s-&gt;last_flush = -1;
00493         <span class="keywordflow">return</span> Z_OK;
00494     }
00495 
00496     <span class="comment">/* Make sure there is something to do and avoid duplicate consecutive</span>
00497 <span class="comment">     * flushes. For repeated and useless calls with Z_FINISH, we keep</span>
00498 <span class="comment">     * returning Z_STREAM_END instead of Z_BUFF_ERROR.</span>
00499 <span class="comment">     */</span>
00500     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (strm-&gt;avail_in == 0 &amp;&amp; flush &lt;= old_flush &amp;&amp;
00501            flush != Z_FINISH) {
00502         ERR_RETURN(strm, Z_BUF_ERROR);
00503     }
00504 
00505     <span class="comment">/* User must not provide more input after the first FINISH: */</span>
00506     <span class="keywordflow">if</span> (s-&gt;status == FINISH_STATE &amp;&amp; strm-&gt;avail_in != 0) {
00507         ERR_RETURN(strm, Z_BUF_ERROR);
00508     }
00509 
00510     <span class="comment">/* Start a new block or continue the current one.</span>
00511 <span class="comment">     */</span>
00512     <span class="keywordflow">if</span> (strm-&gt;avail_in != 0 || s-&gt;lookahead != 0 ||
00513         (flush != Z_NO_FLUSH &amp;&amp; s-&gt;status != FINISH_STATE)) {
00514         block_state bstate;
00515 
00516     bstate = (*(configuration_table[s-&gt;level].func))(s, flush);
00517 
00518         <span class="keywordflow">if</span> (bstate == finish_started || bstate == finish_done) {
00519             s-&gt;status = FINISH_STATE;
00520         }
00521         <span class="keywordflow">if</span> (bstate == need_more || bstate == finish_started) {
00522         <span class="keywordflow">if</span> (strm-&gt;avail_out == 0) {
00523             s-&gt;last_flush = -1; <span class="comment">/* avoid BUF_ERROR next call, see above */</span>
00524         }
00525         <span class="keywordflow">return</span> Z_OK;
00526         <span class="comment">/* If flush != Z_NO_FLUSH &amp;&amp; avail_out == 0, the next call</span>
00527 <span class="comment">         * of deflate should use the same flush parameter to make sure</span>
00528 <span class="comment">         * that the flush is complete. So we don't have to output an</span>
00529 <span class="comment">         * empty block here, this will be done at next call. This also</span>
00530 <span class="comment">         * ensures that for a very small output buffer, we emit at most</span>
00531 <span class="comment">         * one empty block.</span>
00532 <span class="comment">         */</span>
00533     }
00534         <span class="keywordflow">if</span> (bstate == block_done) {
00535             <span class="keywordflow">if</span> (flush == Z_PARTIAL_FLUSH) {
00536                 _tr_align(s);
00537             } <span class="keywordflow">else</span> { <span class="comment">/* FULL_FLUSH or SYNC_FLUSH */</span>
00538                 _tr_stored_block(s, (<span class="keywordtype">char</span>*)0, 0L, 0);
00539                 <span class="comment">/* For a full flush, this empty block will be recognized</span>
00540 <span class="comment">                 * as a special marker by inflate_sync().</span>
00541 <span class="comment">                 */</span>
00542                 <span class="keywordflow">if</span> (flush == Z_FULL_FLUSH) {
00543                     CLEAR_HASH(s);             <span class="comment">/* forget history */</span>
00544                 }
00545             }
00546             flush_pending(strm);
00547         <span class="keywordflow">if</span> (strm-&gt;avail_out == 0) {
00548           s-&gt;last_flush = -1; <span class="comment">/* avoid BUF_ERROR at next call, see above */</span>
00549           <span class="keywordflow">return</span> Z_OK;
00550         }
00551         }
00552     }
00553     Assert(strm-&gt;avail_out &gt; 0, <span class="stringliteral">"bug2"</span>);
00554 
00555     <span class="keywordflow">if</span> (flush != Z_FINISH) <span class="keywordflow">return</span> Z_OK;
00556     <span class="keywordflow">if</span> (s-&gt;noheader) <span class="keywordflow">return</span> Z_STREAM_END;
00557 
00558     <span class="comment">/* Write the zlib trailer (adler32) */</span>
00559     putShortMSB(s, (uInt)(strm-&gt;adler &gt;&gt; 16));
00560     putShortMSB(s, (uInt)(strm-&gt;adler &amp; 0xffff));
00561     flush_pending(strm);
00562     <span class="comment">/* If avail_out is zero, the application will call deflate again</span>
00563 <span class="comment">     * to flush the rest.</span>
00564 <span class="comment">     */</span>
00565     s-&gt;noheader = -1; <span class="comment">/* write the trailer only once! */</span>
00566     <span class="keywordflow">return</span> s-&gt;pending != 0 ? Z_OK : Z_STREAM_END;
00567 }
00568 
00569 <span class="comment">/* ========================================================================= */</span>
00570 <span class="keywordtype">int</span> ZEXPORT deflateEnd (strm)
00571     z_streamp strm;
00572 {
00573     <span class="keywordtype">int</span> status;
00574 
00575     <span class="keywordflow">if</span> (strm == Z_NULL || strm-&gt;state == Z_NULL) <span class="keywordflow">return</span> Z_STREAM_ERROR;
00576 
00577     status = strm-&gt;state-&gt;status;
00578     <span class="keywordflow">if</span> (status != INIT_STATE &amp;&amp; status != BUSY_STATE &amp;&amp;
00579     status != FINISH_STATE) {
00580       <span class="keywordflow">return</span> Z_STREAM_ERROR;
00581     }
00582 
00583     <span class="comment">/* Deallocate in reverse order of allocations: */</span>
00584     TRY_FREE(strm, strm-&gt;state-&gt;pending_buf);
00585     TRY_FREE(strm, strm-&gt;state-&gt;head);
00586     TRY_FREE(strm, strm-&gt;state-&gt;prev);
00587     TRY_FREE(strm, strm-&gt;state-&gt;window);
00588 
00589     ZFREE(strm, strm-&gt;state);
00590     strm-&gt;state = Z_NULL;
00591 
00592     <span class="keywordflow">return</span> status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
00593 }
00594 
00595 <span class="comment">/* =========================================================================</span>
00596 <span class="comment"> * Copy the source state to the destination state.</span>
00597 <span class="comment"> * To simplify the source, this is not supported for 16-bit MSDOS (which</span>
00598 <span class="comment"> * doesn't have enough memory anyway to duplicate compression states).</span>
00599 <span class="comment"> */</span>
00600 <span class="keywordtype">int</span> ZEXPORT deflateCopy (dest, source)
00601     z_streamp dest;
00602     z_streamp source;
00603 {
00604 <span class="preprocessor">#ifdef MAXSEG_64K</span>
00605 <span class="preprocessor"></span>    <span class="keywordflow">return</span> Z_STREAM_ERROR;
00606 <span class="preprocessor">#else</span>
00607 <span class="preprocessor"></span>    deflate_state *ds;
00608     deflate_state *ss;
00609     ushf *overlay;
00610 
00611 
00612     <span class="keywordflow">if</span> (source == Z_NULL || dest == Z_NULL || source-&gt;state == Z_NULL) {
00613         <span class="keywordflow">return</span> Z_STREAM_ERROR;
00614     }
00615 
00616     ss = source-&gt;state;
00617 
00618     *dest = *source;
00619 
00620     ds = (deflate_state *) ZALLOC(dest, 1, <span class="keyword">sizeof</span>(deflate_state));
00621     <span class="keywordflow">if</span> (ds == Z_NULL) <span class="keywordflow">return</span> Z_MEM_ERROR;
00622     dest-&gt;state = (<span class="keyword">struct </span>internal_state FAR *) ds;
00623     *ds = *ss;
00624     ds-&gt;strm = dest;
00625 
00626     ds-&gt;window = (Bytef *) ZALLOC(dest, ds-&gt;w_size, 2*<span class="keyword">sizeof</span>(Byte));
00627     ds-&gt;prev   = (Posf *)  ZALLOC(dest, ds-&gt;w_size, <span class="keyword">sizeof</span>(Pos));
00628     ds-&gt;head   = (Posf *)  ZALLOC(dest, ds-&gt;hash_size, <span class="keyword">sizeof</span>(Pos));
00629     overlay = (ushf *) ZALLOC(dest, ds-&gt;lit_bufsize, <span class="keyword">sizeof</span>(ush)+2);
00630     ds-&gt;pending_buf = (uchf *) overlay;
00631 
00632     <span class="keywordflow">if</span> (ds-&gt;window == Z_NULL || ds-&gt;prev == Z_NULL || ds-&gt;head == Z_NULL ||
00633         ds-&gt;pending_buf == Z_NULL) {
00634         deflateEnd (dest);
00635         <span class="keywordflow">return</span> Z_MEM_ERROR;
00636     }
00637     <span class="comment">/* following zmemcpy do not work for 16-bit MSDOS */</span>
00638     zmemcpy(ds-&gt;window, ss-&gt;window, ds-&gt;w_size * 2 * <span class="keyword">sizeof</span>(Byte));
00639     zmemcpy(ds-&gt;prev, ss-&gt;prev, ds-&gt;w_size * <span class="keyword">sizeof</span>(Pos));
00640     zmemcpy(ds-&gt;head, ss-&gt;head, ds-&gt;hash_size * <span class="keyword">sizeof</span>(Pos));
00641     zmemcpy(ds-&gt;pending_buf, ss-&gt;pending_buf, (uInt)ds-&gt;pending_buf_size);
00642 
00643     ds-&gt;pending_out = ds-&gt;pending_buf + (ss-&gt;pending_out - ss-&gt;pending_buf);
00644     ds-&gt;d_buf = overlay + ds-&gt;lit_bufsize/<span class="keyword">sizeof</span>(ush);
00645     ds-&gt;l_buf = ds-&gt;pending_buf + (1+<span class="keyword">sizeof</span>(ush))*ds-&gt;lit_bufsize;
00646 
00647     ds-&gt;l_desc.dyn_tree = ds-&gt;dyn_ltree;
00648     ds-&gt;d_desc.dyn_tree = ds-&gt;dyn_dtree;
00649     ds-&gt;bl_desc.dyn_tree = ds-&gt;bl_tree;
00650 
00651     <span class="keywordflow">return</span> Z_OK;
00652 <span class="preprocessor">#endif</span>
00653 <span class="preprocessor"></span>}
00654 
00655 <span class="comment">/* ===========================================================================</span>
00656 <span class="comment"> * Read a new buffer from the current input stream, update the adler32</span>
00657 <span class="comment"> * and total number of bytes read.  All deflate() input goes through</span>
00658 <span class="comment"> * this function so some applications may wish to modify it to avoid</span>
00659 <span class="comment"> * allocating a large strm-&gt;next_in buffer and copying from it.</span>
00660 <span class="comment"> * (See also flush_pending()).</span>
00661 <span class="comment"> */</span>
00662 local <span class="keywordtype">int</span> read_buf(strm, buf, size)
00663     z_streamp strm;
00664     Bytef *buf;
00665     <span class="keywordtype">unsigned</span> size;
00666 {
00667     <span class="keywordtype">unsigned</span> len = strm-&gt;avail_in;
00668 
00669     <span class="keywordflow">if</span> (len &gt; size) len = size;
00670     <span class="keywordflow">if</span> (len == 0) <span class="keywordflow">return</span> 0;
00671 
00672     strm-&gt;avail_in  -= len;
00673 
00674     <span class="keywordflow">if</span> (!strm-&gt;state-&gt;noheader) {
00675         strm-&gt;adler = adler32(strm-&gt;adler, strm-&gt;next_in, len);
00676     }
00677     zmemcpy(buf, strm-&gt;next_in, len);
00678     strm-&gt;next_in  += len;
00679     strm-&gt;total_in += len;
00680 
00681     <span class="keywordflow">return</span> (int)len;
00682 }
00683 
00684 <span class="comment">/* ===========================================================================</span>
00685 <span class="comment"> * Initialize the "longest match" routines for a new zlib stream</span>
00686 <span class="comment"> */</span>
00687 local <span class="keywordtype">void</span> lm_init (s)
00688     deflate_state *s;
00689 {
00690     s-&gt;window_size = (ulg)2L*s-&gt;w_size;
00691 
00692     CLEAR_HASH(s);
00693 
00694     <span class="comment">/* Set the default configuration parameters:</span>
00695 <span class="comment">     */</span>
00696     s-&gt;max_lazy_match   = configuration_table[s-&gt;level].max_lazy;
00697     s-&gt;good_match       = configuration_table[s-&gt;level].good_length;
00698     s-&gt;nice_match       = configuration_table[s-&gt;level].nice_length;
00699     s-&gt;max_chain_length = configuration_table[s-&gt;level].max_chain;
00700 
00701     s-&gt;strstart = 0;
00702     s-&gt;block_start = 0L;
00703     s-&gt;lookahead = 0;
00704     s-&gt;match_length = s-&gt;prev_length = MIN_MATCH-1;
00705     s-&gt;match_available = 0;
00706     s-&gt;ins_h = 0;
00707 <span class="preprocessor">#ifdef ASMV</span>
00708 <span class="preprocessor"></span>    match_init(); <span class="comment">/* initialize the asm code */</span>
00709 <span class="preprocessor">#endif</span>
00710 <span class="preprocessor"></span>}
00711 
00712 <span class="comment">/* ===========================================================================</span>
00713 <span class="comment"> * Set match_start to the longest match starting at the given string and</span>
00714 <span class="comment"> * return its length. Matches shorter or equal to prev_length are discarded,</span>
00715 <span class="comment"> * in which case the result is equal to prev_length and match_start is</span>
00716 <span class="comment"> * garbage.</span>
00717 <span class="comment"> * IN assertions: cur_match is the head of the hash chain for the current</span>
00718 <span class="comment"> *   string (strstart) and its distance is &lt;= MAX_DIST, and prev_length &gt;= 1</span>
00719 <span class="comment"> * OUT assertion: the match length is not greater than s-&gt;lookahead.</span>
00720 <span class="comment"> */</span>
00721 <span class="preprocessor">#ifndef ASMV</span>
00722 <span class="preprocessor"></span><span class="comment">/* For 80x86 and 680x0, an optimized version will be provided in match.asm or</span>
00723 <span class="comment"> * match.S. The code will be functionally equivalent.</span>
00724 <span class="comment"> */</span>
00725 <span class="preprocessor">#ifndef FASTEST</span>
00726 <span class="preprocessor"></span>local uInt longest_match(s, cur_match)
00727     deflate_state *s;
00728     IPos cur_match;                             <span class="comment">/* current match */</span>
00729 {
00730     <span class="keywordtype">unsigned</span> chain_length = s-&gt;max_chain_length;<span class="comment">/* max hash chain length */</span>
00731     <span class="keyword">register</span> Bytef *scan = s-&gt;window + s-&gt;strstart; <span class="comment">/* current string */</span>
00732     <span class="keyword">register</span> Bytef *match;                       <span class="comment">/* matched string */</span>
00733     <span class="keyword">register</span> <span class="keywordtype">int</span> len;                           <span class="comment">/* length of current match */</span>
00734     <span class="keywordtype">int</span> best_len = s-&gt;prev_length;              <span class="comment">/* best match length so far */</span>
00735     <span class="keywordtype">int</span> nice_match = s-&gt;nice_match;             <span class="comment">/* stop if match long enough */</span>
00736     IPos limit = s-&gt;strstart &gt; (IPos)MAX_DIST(s) ?
00737         s-&gt;strstart - (IPos)MAX_DIST(s) : NIL;
00738     <span class="comment">/* Stop when cur_match becomes &lt;= limit. To simplify the code,</span>
00739 <span class="comment">     * we prevent matches with the string of window index 0.</span>
00740 <span class="comment">     */</span>
00741     Posf *prev = s-&gt;prev;
00742     uInt wmask = s-&gt;w_mask;
00743 
00744 <span class="preprocessor">#ifdef UNALIGNED_OK</span>
00745 <span class="preprocessor"></span>    <span class="comment">/* Compare two bytes at a time. Note: this is not always beneficial.</span>
00746 <span class="comment">     * Try with and without -DUNALIGNED_OK to check.</span>
00747 <span class="comment">     */</span>
00748     <span class="keyword">register</span> Bytef *strend = s-&gt;window + s-&gt;strstart + MAX_MATCH - 1;
00749     <span class="keyword">register</span> ush scan_start = *(ushf*)scan;
00750     <span class="keyword">register</span> ush scan_end   = *(ushf*)(scan+best_len-1);
00751 <span class="preprocessor">#else</span>
00752 <span class="preprocessor"></span>    <span class="keyword">register</span> Bytef *strend = s-&gt;window + s-&gt;strstart + MAX_MATCH;
00753     <span class="keyword">register</span> Byte scan_end1  = scan[best_len-1];
00754     <span class="keyword">register</span> Byte scan_end   = scan[best_len];
00755 <span class="preprocessor">#endif</span>
00756 <span class="preprocessor"></span>
00757     <span class="comment">/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.</span>
00758 <span class="comment">     * It is easy to get rid of this optimization if necessary.</span>
00759 <span class="comment">     */</span>
00760     Assert(s-&gt;hash_bits &gt;= 8 &amp;&amp; MAX_MATCH == 258, <span class="stringliteral">"Code too clever"</span>);
00761 
00762     <span class="comment">/* Do not waste too much time if we already have a good match: */</span>
00763     <span class="keywordflow">if</span> (s-&gt;prev_length &gt;= s-&gt;good_match) {
00764         chain_length &gt;&gt;= 2;
00765     }
00766     <span class="comment">/* Do not look for matches beyond the end of the input. This is necessary</span>
00767 <span class="comment">     * to make deflate deterministic.</span>
00768 <span class="comment">     */</span>
00769     <span class="keywordflow">if</span> ((uInt)nice_match &gt; s-&gt;lookahead) nice_match = s-&gt;lookahead;
00770 
00771     Assert((ulg)s-&gt;strstart &lt;= s-&gt;window_size-MIN_LOOKAHEAD, <span class="stringliteral">"need lookahead"</span>);
00772 
00773     <span class="keywordflow">do</span> {
00774         Assert(cur_match &lt; s-&gt;strstart, <span class="stringliteral">"no future"</span>);
00775         match = s-&gt;window + cur_match;
00776 
00777         <span class="comment">/* Skip to next match if the match length cannot increase</span>
00778 <span class="comment">         * or if the match length is less than 2:</span>
00779 <span class="comment">         */</span>
00780 <span class="preprocessor">#if (defined(UNALIGNED_OK) &amp;&amp; MAX_MATCH == 258)</span>
00781 <span class="preprocessor"></span>        <span class="comment">/* This code assumes sizeof(unsigned short) == 2. Do not use</span>
00782 <span class="comment">         * UNALIGNED_OK if your compiler uses a different size.</span>
00783 <span class="comment">         */</span>
00784         <span class="keywordflow">if</span> (*(ushf*)(match+best_len-1) != scan_end ||
00785             *(ushf*)match != scan_start) <span class="keywordflow">continue</span>;
00786 
00787         <span class="comment">/* It is not necessary to compare scan[2] and match[2] since they are</span>
00788 <span class="comment">         * always equal when the other bytes match, given that the hash keys</span>
00789 <span class="comment">         * are equal and that HASH_BITS &gt;= 8. Compare 2 bytes at a time at</span>
00790 <span class="comment">         * strstart+3, +5, ... up to strstart+257. We check for insufficient</span>
00791 <span class="comment">         * lookahead only every 4th comparison; the 128th check will be made</span>
00792 <span class="comment">         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is</span>
00793 <span class="comment">         * necessary to put more guard bytes at the end of the window, or</span>
00794 <span class="comment">         * to check more often for insufficient lookahead.</span>
00795 <span class="comment">         */</span>
00796         Assert(scan[2] == match[2], <span class="stringliteral">"scan[2]?"</span>);
00797         scan++, match++;
00798         <span class="keywordflow">do</span> {
00799         } <span class="keywordflow">while</span> (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;
00800                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;
00801                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;
00802                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &amp;&amp;
00803                  scan &lt; strend);
00804         <span class="comment">/* The funny "do {}" generates better code on most compilers */</span>
00805 
00806         <span class="comment">/* Here, scan &lt;= window+strstart+257 */</span>
00807         Assert(scan &lt;= s-&gt;window+(<span class="keywordtype">unsigned</span>)(s-&gt;window_size-1), <span class="stringliteral">"wild scan"</span>);
00808         <span class="keywordflow">if</span> (*scan == *match) scan++;
00809 
00810         len = (MAX_MATCH - 1) - (int)(strend-scan);
00811         scan = strend - (MAX_MATCH-1);
00812 
00813 <span class="preprocessor">#else </span><span class="comment">/* UNALIGNED_OK */</span>
00814 
00815         <span class="keywordflow">if</span> (match[best_len]   != scan_end  ||
00816             match[best_len-1] != scan_end1 ||
00817             *match            != *scan     ||
00818             *++match          != scan[1])      <span class="keywordflow">continue</span>;
00819 
00820         <span class="comment">/* The check at best_len-1 can be removed because it will be made</span>
00821 <span class="comment">         * again later. (This heuristic is not always a win.)</span>
00822 <span class="comment">         * It is not necessary to compare scan[2] and match[2] since they</span>
00823 <span class="comment">         * are always equal when the other bytes match, given that</span>
00824 <span class="comment">         * the hash keys are equal and that HASH_BITS &gt;= 8.</span>
00825 <span class="comment">         */</span>
00826         scan += 2, match++;
00827         Assert(*scan == *match, <span class="stringliteral">"match[2]?"</span>);
00828 
00829         <span class="comment">/* We check for insufficient lookahead only every 8th comparison;</span>
00830 <span class="comment">         * the 256th check will be made at strstart+258.</span>
00831 <span class="comment">         */</span>
00832         <span class="keywordflow">do</span> {
00833         } <span class="keywordflow">while</span> (*++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
00834                  *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
00835                  *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
00836                  *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
00837                  scan &lt; strend);
00838 
00839         Assert(scan &lt;= s-&gt;window+(<span class="keywordtype">unsigned</span>)(s-&gt;window_size-1), <span class="stringliteral">"wild scan"</span>);
00840 
00841         len = MAX_MATCH - (int)(strend - scan);
00842         scan = strend - MAX_MATCH;
00843 
00844 <span class="preprocessor">#endif </span><span class="comment">/* UNALIGNED_OK */</span>
00845 
00846         <span class="keywordflow">if</span> (len &gt; best_len) {
00847             s-&gt;match_start = cur_match;
00848             best_len = len;
00849             <span class="keywordflow">if</span> (len &gt;= nice_match) <span class="keywordflow">break</span>;
00850 <span class="preprocessor">#ifdef UNALIGNED_OK</span>
00851 <span class="preprocessor"></span>            scan_end = *(ushf*)(scan+best_len-1);
00852 <span class="preprocessor">#else</span>
00853 <span class="preprocessor"></span>            scan_end1  = scan[best_len-1];
00854             scan_end   = scan[best_len];
00855 <span class="preprocessor">#endif</span>
00856 <span class="preprocessor"></span>        }
00857     } <span class="keywordflow">while</span> ((cur_match = prev[cur_match &amp; wmask]) &gt; limit
00858              &amp;&amp; --chain_length != 0);
00859 
00860     <span class="keywordflow">if</span> ((uInt)best_len &lt;= s-&gt;lookahead) <span class="keywordflow">return</span> (uInt)best_len;
00861     <span class="keywordflow">return</span> s-&gt;lookahead;
00862 }
00863 
00864 <span class="preprocessor">#else </span><span class="comment">/* FASTEST */</span>
00865 <span class="comment">/* ---------------------------------------------------------------------------</span>
00866 <span class="comment"> * Optimized version for level == 1 only</span>
00867 <span class="comment"> */</span>
00868 local uInt longest_match(s, cur_match)
00869     deflate_state *s;
00870     IPos cur_match;                             <span class="comment">/* current match */</span>
00871 {
00872     <span class="keyword">register</span> Bytef *scan = s-&gt;window + s-&gt;strstart; <span class="comment">/* current string */</span>
00873     <span class="keyword">register</span> Bytef *match;                       <span class="comment">/* matched string */</span>
00874     <span class="keyword">register</span> <span class="keywordtype">int</span> len;                           <span class="comment">/* length of current match */</span>
00875     <span class="keyword">register</span> Bytef *strend = s-&gt;window + s-&gt;strstart + MAX_MATCH;
00876 
00877     <span class="comment">/* The code is optimized for HASH_BITS &gt;= 8 and MAX_MATCH-2 multiple of 16.</span>
00878 <span class="comment">     * It is easy to get rid of this optimization if necessary.</span>
00879 <span class="comment">     */</span>
00880     Assert(s-&gt;hash_bits &gt;= 8 &amp;&amp; MAX_MATCH == 258, <span class="stringliteral">"Code too clever"</span>);
00881 
00882     Assert((ulg)s-&gt;strstart &lt;= s-&gt;window_size-MIN_LOOKAHEAD, <span class="stringliteral">"need lookahead"</span>);
00883 
00884     Assert(cur_match &lt; s-&gt;strstart, <span class="stringliteral">"no future"</span>);
00885 
00886     match = s-&gt;window + cur_match;
00887 
00888     <span class="comment">/* Return failure if the match length is less than 2:</span>
00889 <span class="comment">     */</span>
00890     <span class="keywordflow">if</span> (match[0] != scan[0] || match[1] != scan[1]) <span class="keywordflow">return</span> MIN_MATCH-1;
00891 
00892     <span class="comment">/* The check at best_len-1 can be removed because it will be made</span>
00893 <span class="comment">     * again later. (This heuristic is not always a win.)</span>
00894 <span class="comment">     * It is not necessary to compare scan[2] and match[2] since they</span>
00895 <span class="comment">     * are always equal when the other bytes match, given that</span>
00896 <span class="comment">     * the hash keys are equal and that HASH_BITS &gt;= 8.</span>
00897 <span class="comment">     */</span>
00898     scan += 2, match += 2;
00899     Assert(*scan == *match, <span class="stringliteral">"match[2]?"</span>);
00900 
00901     <span class="comment">/* We check for insufficient lookahead only every 8th comparison;</span>
00902 <span class="comment">     * the 256th check will be made at strstart+258.</span>
00903 <span class="comment">     */</span>
00904     <span class="keywordflow">do</span> {
00905     } <span class="keywordflow">while</span> (*++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
00906          *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
00907          *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
00908          *++scan == *++match &amp;&amp; *++scan == *++match &amp;&amp;
00909          scan &lt; strend);
00910 
00911     Assert(scan &lt;= s-&gt;window+(<span class="keywordtype">unsigned</span>)(s-&gt;window_size-1), <span class="stringliteral">"wild scan"</span>);
00912 
00913     len = MAX_MATCH - (int)(strend - scan);
00914 
00915     <span class="keywordflow">if</span> (len &lt; MIN_MATCH) <span class="keywordflow">return</span> MIN_MATCH - 1;
00916 
00917     s-&gt;match_start = cur_match;
00918     <span class="keywordflow">return</span> len &lt;= s-&gt;lookahead ? len : s-&gt;lookahead;
00919 }
00920 <span class="preprocessor">#endif </span><span class="comment">/* FASTEST */</span>
00921 <span class="preprocessor">#endif </span><span class="comment">/* ASMV */</span>
00922 
00923 <span class="preprocessor">#ifdef DEBUG</span>
00924 <span class="preprocessor"></span><span class="comment">/* ===========================================================================</span>
00925 <span class="comment"> * Check that the match at match_start is indeed a match.</span>
00926 <span class="comment"> */</span>
00927 local <span class="keywordtype">void</span> check_match(s, start, match, length)
00928     deflate_state *s;
00929     IPos start, match;
00930     <span class="keywordtype">int</span> length;
00931 {
00932     <span class="comment">/* check that the match is indeed a match */</span>
00933     <span class="keywordflow">if</span> (zmemcmp(s-&gt;window + match,
00934                 s-&gt;window + start, length) != EQUAL) {
00935         fprintf(stderr, <span class="stringliteral">" start %u, match %u, length %d\n"</span>,
00936         start, match, length);
00937         <span class="keywordflow">do</span> {
00938         fprintf(stderr, <span class="stringliteral">"%c%c"</span>, s-&gt;window[match++], s-&gt;window[start++]);
00939     } <span class="keywordflow">while</span> (--length != 0);
00940         z_error(<span class="stringliteral">"invalid match"</span>);
00941     }
00942     <span class="keywordflow">if</span> (z_verbose &gt; 1) {
00943         fprintf(stderr,<span class="stringliteral">"\\[%d,%d]"</span>, start-match, length);
00944         <span class="keywordflow">do</span> { putc(s-&gt;window[start++], stderr); } <span class="keywordflow">while</span> (--length != 0);
00945     }
00946 }
00947 <span class="preprocessor">#else</span>
00948 <span class="preprocessor"></span><span class="preprocessor">#  define check_match(s, start, match, length)</span>
00949 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00950 <span class="preprocessor"></span>
00951 <span class="comment">/* ===========================================================================</span>
00952 <span class="comment"> * Fill the window when the lookahead becomes insufficient.</span>
00953 <span class="comment"> * Updates strstart and lookahead.</span>
00954 <span class="comment"> *</span>
00955 <span class="comment"> * IN assertion: lookahead &lt; MIN_LOOKAHEAD</span>
00956 <span class="comment"> * OUT assertions: strstart &lt;= window_size-MIN_LOOKAHEAD</span>
00957 <span class="comment"> *    At least one byte has been read, or avail_in == 0; reads are</span>
00958 <span class="comment"> *    performed for at least two bytes (required for the zip translate_eol</span>
00959 <span class="comment"> *    option -- not supported here).</span>
00960 <span class="comment"> */</span>
00961 local <span class="keywordtype">void</span> fill_window(s)
00962     deflate_state *s;
00963 {
00964     <span class="keyword">register</span> <span class="keywordtype">unsigned</span> n, m;
00965     <span class="keyword">register</span> Posf *p;
00966     <span class="keywordtype">unsigned</span> more;    <span class="comment">/* Amount of free space at the end of the window. */</span>
00967     uInt wsize = s-&gt;w_size;
00968 
00969     <span class="keywordflow">do</span> {
00970         more = (unsigned)(s-&gt;window_size -(ulg)s-&gt;lookahead -(ulg)s-&gt;strstart);
00971 
00972         <span class="comment">/* Deal with !@#$% 64K limit: */</span>
00973         <span class="keywordflow">if</span> (more == 0 &amp;&amp; s-&gt;strstart == 0 &amp;&amp; s-&gt;lookahead == 0) {
00974             more = wsize;
00975 
00976         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (more == (unsigned)(-1)) {
00977             <span class="comment">/* Very unlikely, but possible on 16 bit machine if strstart == 0</span>
00978 <span class="comment">             * and lookahead == 1 (input done one byte at time)</span>
00979 <span class="comment">             */</span>
00980             more--;
00981 
00982         <span class="comment">/* If the window is almost full and there is insufficient lookahead,</span>
00983 <span class="comment">         * move the upper half to the lower one to make room in the upper half.</span>
00984 <span class="comment">         */</span>
00985         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s-&gt;strstart &gt;= wsize+MAX_DIST(s)) {
00986 
00987             zmemcpy(s-&gt;window, s-&gt;window+wsize, (<span class="keywordtype">unsigned</span>)wsize);
00988             s-&gt;match_start -= wsize;
00989             s-&gt;strstart    -= wsize; <span class="comment">/* we now have strstart &gt;= MAX_DIST */</span>
00990             s-&gt;block_start -= (long) wsize;
00991 
00992             <span class="comment">/* Slide the hash table (could be avoided with 32 bit values</span>
00993 <span class="comment">               at the expense of memory usage). We slide even when level == 0</span>
00994 <span class="comment">               to keep the hash table consistent if we switch back to level &gt; 0</span>
00995 <span class="comment">               later. (Using level 0 permanently is not an optimal usage of</span>
00996 <span class="comment">               zlib, so we don't care about this pathological case.)</span>
00997 <span class="comment">             */</span>
00998         n = s-&gt;hash_size;
00999         p = &amp;s-&gt;head[n];
01000         <span class="keywordflow">do</span> {
01001         m = *--p;
01002         *p = (Pos)(m &gt;= wsize ? m-wsize : NIL);
01003         } <span class="keywordflow">while</span> (--n);
01004 
01005         n = wsize;
01006 <span class="preprocessor">#ifndef FASTEST</span>
01007 <span class="preprocessor"></span>        p = &amp;s-&gt;prev[n];
01008         <span class="keywordflow">do</span> {
01009         m = *--p;
01010         *p = (Pos)(m &gt;= wsize ? m-wsize : NIL);
01011         <span class="comment">/* If n is not on any hash chain, prev[n] is garbage but</span>
01012 <span class="comment">         * its value will never be used.</span>
01013 <span class="comment">         */</span>
01014         } <span class="keywordflow">while</span> (--n);
01015 <span class="preprocessor">#endif</span>
01016 <span class="preprocessor"></span>            more += wsize;
01017         }
01018         <span class="keywordflow">if</span> (s-&gt;strm-&gt;avail_in == 0) <span class="keywordflow">return</span>;
01019 
01020         <span class="comment">/* If there was no sliding:</span>
01021 <span class="comment">         *    strstart &lt;= WSIZE+MAX_DIST-1 &amp;&amp; lookahead &lt;= MIN_LOOKAHEAD - 1 &amp;&amp;</span>
01022 <span class="comment">         *    more == window_size - lookahead - strstart</span>
01023 <span class="comment">         * =&gt; more &gt;= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)</span>
01024 <span class="comment">         * =&gt; more &gt;= window_size - 2*WSIZE + 2</span>
01025 <span class="comment">         * In the BIG_MEM or MMAP case (not yet supported),</span>
01026 <span class="comment">         *   window_size == input_size + MIN_LOOKAHEAD  &amp;&amp;</span>
01027 <span class="comment">         *   strstart + s-&gt;lookahead &lt;= input_size =&gt; more &gt;= MIN_LOOKAHEAD.</span>
01028 <span class="comment">         * Otherwise, window_size == 2*WSIZE so more &gt;= 2.</span>
01029 <span class="comment">         * If there was sliding, more &gt;= WSIZE. So in all cases, more &gt;= 2.</span>
01030 <span class="comment">         */</span>
01031         Assert(more &gt;= 2, <span class="stringliteral">"more &lt; 2"</span>);
01032 
01033         n = read_buf(s-&gt;strm, s-&gt;window + s-&gt;strstart + s-&gt;lookahead, more);
01034         s-&gt;lookahead += n;
01035 
01036         <span class="comment">/* Initialize the hash value now that we have some input: */</span>
01037         <span class="keywordflow">if</span> (s-&gt;lookahead &gt;= MIN_MATCH) {
01038             s-&gt;ins_h = s-&gt;window[s-&gt;strstart];
01039             UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[s-&gt;strstart+1]);
01040 <span class="preprocessor">#if MIN_MATCH != 3</span>
01041 <span class="preprocessor"></span>            Call UPDATE_HASH() MIN_MATCH-3 more times
01042 <span class="preprocessor">#endif</span>
01043 <span class="preprocessor"></span>        }
01044         <span class="comment">/* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,</span>
01045 <span class="comment">         * but this is not important since only literal bytes will be emitted.</span>
01046 <span class="comment">         */</span>
01047 
01048     } <span class="keywordflow">while</span> (s-&gt;lookahead &lt; MIN_LOOKAHEAD &amp;&amp; s-&gt;strm-&gt;avail_in != 0);
01049 }
01050 
01051 <span class="comment">/* ===========================================================================</span>
01052 <span class="comment"> * Flush the current block, with given end-of-file flag.</span>
01053 <span class="comment"> * IN assertion: strstart is set to the end of the current match.</span>
01054 <span class="comment"> */</span>
01055 <span class="preprocessor">#define FLUSH_BLOCK_ONLY(s, eof) { \</span>
01056 <span class="preprocessor">   _tr_flush_block(s, (s-&gt;block_start &gt;= 0L ? \</span>
01057 <span class="preprocessor">                   (charf *)&amp;s-&gt;window[(unsigned)s-&gt;block_start] : \</span>
01058 <span class="preprocessor">                   (charf *)Z_NULL), \</span>
01059 <span class="preprocessor">        (ulg)((long)s-&gt;strstart - s-&gt;block_start), \</span>
01060 <span class="preprocessor">        (eof)); \</span>
01061 <span class="preprocessor">   s-&gt;block_start = s-&gt;strstart; \</span>
01062 <span class="preprocessor">   flush_pending(s-&gt;strm); \</span>
01063 <span class="preprocessor">   Tracev((stderr,"[FLUSH]")); \</span>
01064 <span class="preprocessor">}</span>
01065 <span class="preprocessor"></span>
01066 <span class="comment">/* Same but force premature exit if necessary. */</span>
01067 <span class="preprocessor">#define FLUSH_BLOCK(s, eof) { \</span>
01068 <span class="preprocessor">   FLUSH_BLOCK_ONLY(s, eof); \</span>
01069 <span class="preprocessor">   if (s-&gt;strm-&gt;avail_out == 0) return (eof) ? finish_started : need_more; \</span>
01070 <span class="preprocessor">}</span>
01071 <span class="preprocessor"></span>
01072 <span class="comment">/* ===========================================================================</span>
01073 <span class="comment"> * Copy without compression as much as possible from the input stream, return</span>
01074 <span class="comment"> * the current block state.</span>
01075 <span class="comment"> * This function does not insert new strings in the dictionary since</span>
01076 <span class="comment"> * uncompressible data is probably not useful. This function is used</span>
01077 <span class="comment"> * only for the level=0 compression option.</span>
01078 <span class="comment"> * NOTE: this function should be optimized to avoid extra copying from</span>
01079 <span class="comment"> * window to pending_buf.</span>
01080 <span class="comment"> */</span>
01081 local block_state deflate_stored(s, flush)
01082     deflate_state *s;
01083     <span class="keywordtype">int</span> flush;
01084 {
01085     <span class="comment">/* Stored blocks are limited to 0xffff bytes, pending_buf is limited</span>
01086 <span class="comment">     * to pending_buf_size, and each stored block has a 5 byte header:</span>
01087 <span class="comment">     */</span>
01088     ulg max_block_size = 0xffff;
01089     ulg max_start;
01090 
01091     <span class="keywordflow">if</span> (max_block_size &gt; s-&gt;pending_buf_size - 5) {
01092         max_block_size = s-&gt;pending_buf_size - 5;
01093     }
01094 
01095     <span class="comment">/* Copy as much as possible from input to output: */</span>
01096     <span class="keywordflow">for</span> (;;) {
01097         <span class="comment">/* Fill the window as much as possible: */</span>
01098         <span class="keywordflow">if</span> (s-&gt;lookahead &lt;= 1) {
01099 
01100             Assert(s-&gt;strstart &lt; s-&gt;w_size+MAX_DIST(s) ||
01101            s-&gt;block_start &gt;= (<span class="keywordtype">long</span>)s-&gt;w_size, <span class="stringliteral">"slide too late"</span>);
01102 
01103             fill_window(s);
01104             <span class="keywordflow">if</span> (s-&gt;lookahead == 0 &amp;&amp; flush == Z_NO_FLUSH) <span class="keywordflow">return</span> need_more;
01105 
01106             <span class="keywordflow">if</span> (s-&gt;lookahead == 0) <span class="keywordflow">break</span>; <span class="comment">/* flush the current block */</span>
01107         }
01108     Assert(s-&gt;block_start &gt;= 0L, <span class="stringliteral">"block gone"</span>);
01109 
01110     s-&gt;strstart += s-&gt;lookahead;
01111     s-&gt;lookahead = 0;
01112 
01113     <span class="comment">/* Emit a stored block if pending_buf will be full: */</span>
01114     max_start = s-&gt;block_start + max_block_size;
01115         <span class="keywordflow">if</span> (s-&gt;strstart == 0 || (ulg)s-&gt;strstart &gt;= max_start) {
01116         <span class="comment">/* strstart == 0 is possible when wraparound on 16-bit machine */</span>
01117         s-&gt;lookahead = (uInt)(s-&gt;strstart - max_start);
01118         s-&gt;strstart = (uInt)max_start;
01119             FLUSH_BLOCK(s, 0);
01120     }
01121     <span class="comment">/* Flush if we may have to slide, otherwise block_start may become</span>
01122 <span class="comment">         * negative and the data will be gone:</span>
01123 <span class="comment">         */</span>
01124         <span class="keywordflow">if</span> (s-&gt;strstart - (uInt)s-&gt;block_start &gt;= MAX_DIST(s)) {
01125             FLUSH_BLOCK(s, 0);
01126     }
01127     }
01128     FLUSH_BLOCK(s, flush == Z_FINISH);
01129     <span class="keywordflow">return</span> flush == Z_FINISH ? finish_done : block_done;
01130 }
01131 
01132 <span class="comment">/* ===========================================================================</span>
01133 <span class="comment"> * Compress as much as possible from the input stream, return the current</span>
01134 <span class="comment"> * block state.</span>
01135 <span class="comment"> * This function does not perform lazy evaluation of matches and inserts</span>
01136 <span class="comment"> * new strings in the dictionary only for unmatched strings or for short</span>
01137 <span class="comment"> * matches. It is used only for the fast compression options.</span>
01138 <span class="comment"> */</span>
01139 local block_state deflate_fast(s, flush)
01140     deflate_state *s;
01141     <span class="keywordtype">int</span> flush;
01142 {
01143     IPos hash_head = NIL; <span class="comment">/* head of the hash chain */</span>
01144     <span class="keywordtype">int</span> bflush;           <span class="comment">/* set if current block must be flushed */</span>
01145 
01146     <span class="keywordflow">for</span> (;;) {
01147         <span class="comment">/* Make sure that we always have enough lookahead, except</span>
01148 <span class="comment">         * at the end of the input file. We need MAX_MATCH bytes</span>
01149 <span class="comment">         * for the next match, plus MIN_MATCH bytes to insert the</span>
01150 <span class="comment">         * string following the next match.</span>
01151 <span class="comment">         */</span>
01152         <span class="keywordflow">if</span> (s-&gt;lookahead &lt; MIN_LOOKAHEAD) {
01153             fill_window(s);
01154             <span class="keywordflow">if</span> (s-&gt;lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush == Z_NO_FLUSH) {
01155             <span class="keywordflow">return</span> need_more;
01156         }
01157             <span class="keywordflow">if</span> (s-&gt;lookahead == 0) <span class="keywordflow">break</span>; <span class="comment">/* flush the current block */</span>
01158         }
01159 
01160         <span class="comment">/* Insert the string window[strstart .. strstart+2] in the</span>
01161 <span class="comment">         * dictionary, and set hash_head to the head of the hash chain:</span>
01162 <span class="comment">         */</span>
01163         <span class="keywordflow">if</span> (s-&gt;lookahead &gt;= MIN_MATCH) {
01164             INSERT_STRING(s, s-&gt;strstart, hash_head);
01165         }
01166 
01167         <span class="comment">/* Find the longest match, discarding those &lt;= prev_length.</span>
01168 <span class="comment">         * At this point we have always match_length &lt; MIN_MATCH</span>
01169 <span class="comment">         */</span>
01170         <span class="keywordflow">if</span> (hash_head != NIL &amp;&amp; s-&gt;strstart - hash_head &lt;= MAX_DIST(s)) {
01171             <span class="comment">/* To simplify the code, we prevent matches with the string</span>
01172 <span class="comment">             * of window index 0 (in particular we have to avoid a match</span>
01173 <span class="comment">             * of the string with itself at the start of the input file).</span>
01174 <span class="comment">             */</span>
01175             <span class="keywordflow">if</span> (s-&gt;strategy != Z_HUFFMAN_ONLY) {
01176                 s-&gt;match_length = longest_match (s, hash_head);
01177             }
01178             <span class="comment">/* longest_match() sets match_start */</span>
01179         }
01180         <span class="keywordflow">if</span> (s-&gt;match_length &gt;= MIN_MATCH) {
01181             check_match(s, s-&gt;strstart, s-&gt;match_start, s-&gt;match_length);
01182 
01183             _tr_tally_dist(s, s-&gt;strstart - s-&gt;match_start,
01184                            s-&gt;match_length - MIN_MATCH, bflush);
01185 
01186             s-&gt;lookahead -= s-&gt;match_length;
01187 
01188             <span class="comment">/* Insert new strings in the hash table only if the match length</span>
01189 <span class="comment">             * is not too large. This saves time but degrades compression.</span>
01190 <span class="comment">             */</span>
01191 <span class="preprocessor">#ifndef FASTEST</span>
01192 <span class="preprocessor"></span>            <span class="keywordflow">if</span> (s-&gt;match_length &lt;= s-&gt;max_insert_length &amp;&amp;
01193                 s-&gt;lookahead &gt;= MIN_MATCH) {
01194                 s-&gt;match_length--; <span class="comment">/* string at strstart already in hash table */</span>
01195                 <span class="keywordflow">do</span> {
01196                     s-&gt;strstart++;
01197                     INSERT_STRING(s, s-&gt;strstart, hash_head);
01198                     <span class="comment">/* strstart never exceeds WSIZE-MAX_MATCH, so there are</span>
01199 <span class="comment">                     * always MIN_MATCH bytes ahead.</span>
01200 <span class="comment">                     */</span>
01201                 } <span class="keywordflow">while</span> (--s-&gt;match_length != 0);
01202                 s-&gt;strstart++; 
01203             } <span class="keywordflow">else</span>
01204 <span class="preprocessor">#endif</span>
01205 <span class="preprocessor"></span>        {
01206                 s-&gt;strstart += s-&gt;match_length;
01207                 s-&gt;match_length = 0;
01208                 s-&gt;ins_h = s-&gt;window[s-&gt;strstart];
01209                 UPDATE_HASH(s, s-&gt;ins_h, s-&gt;window[s-&gt;strstart+1]);
01210 <span class="preprocessor">#if MIN_MATCH != 3</span>
01211 <span class="preprocessor"></span>                Call UPDATE_HASH() MIN_MATCH-3 more times
01212 <span class="preprocessor">#endif</span>
01213 <span class="preprocessor"></span>                <span class="comment">/* If lookahead &lt; MIN_MATCH, ins_h is garbage, but it does not</span>
01214 <span class="comment">                 * matter since it will be recomputed at next deflate call.</span>
01215 <span class="comment">                 */</span>
01216             }
01217         } <span class="keywordflow">else</span> {
01218             <span class="comment">/* No match, output a literal byte */</span>
01219             Tracevv((stderr,<span class="stringliteral">"%c"</span>, s-&gt;window[s-&gt;strstart]));
01220             _tr_tally_lit (s, s-&gt;window[s-&gt;strstart], bflush);
01221             s-&gt;lookahead--;
01222             s-&gt;strstart++; 
01223         }
01224         <span class="keywordflow">if</span> (bflush) FLUSH_BLOCK(s, 0);
01225     }
01226     FLUSH_BLOCK(s, flush == Z_FINISH);
01227     <span class="keywordflow">return</span> flush == Z_FINISH ? finish_done : block_done;
01228 }
01229 
01230 <span class="comment">/* ===========================================================================</span>
01231 <span class="comment"> * Same as above, but achieves better compression. We use a lazy</span>
01232 <span class="comment"> * evaluation for matches: a match is finally adopted only if there is</span>
01233 <span class="comment"> * no better match at the next window position.</span>
01234 <span class="comment"> */</span>
01235 local block_state deflate_slow(s, flush)
01236     deflate_state *s;
01237     <span class="keywordtype">int</span> flush;
01238 {
01239     IPos hash_head = NIL;    <span class="comment">/* head of hash chain */</span>
01240     <span class="keywordtype">int</span> bflush;              <span class="comment">/* set if current block must be flushed */</span>
01241 
01242     <span class="comment">/* Process the input block. */</span>
01243     <span class="keywordflow">for</span> (;;) {
01244         <span class="comment">/* Make sure that we always have enough lookahead, except</span>
01245 <span class="comment">         * at the end of the input file. We need MAX_MATCH bytes</span>
01246 <span class="comment">         * for the next match, plus MIN_MATCH bytes to insert the</span>
01247 <span class="comment">         * string following the next match.</span>
01248 <span class="comment">         */</span>
01249         <span class="keywordflow">if</span> (s-&gt;lookahead &lt; MIN_LOOKAHEAD) {
01250             fill_window(s);
01251             <span class="keywordflow">if</span> (s-&gt;lookahead &lt; MIN_LOOKAHEAD &amp;&amp; flush == Z_NO_FLUSH) {
01252             <span class="keywordflow">return</span> need_more;
01253         }
01254             <span class="keywordflow">if</span> (s-&gt;lookahead == 0) <span class="keywordflow">break</span>; <span class="comment">/* flush the current block */</span>
01255         }
01256 
01257         <span class="comment">/* Insert the string window[strstart .. strstart+2] in the</span>
01258 <span class="comment">         * dictionary, and set hash_head to the head of the hash chain:</span>
01259 <span class="comment">         */</span>
01260         <span class="keywordflow">if</span> (s-&gt;lookahead &gt;= MIN_MATCH) {
01261             INSERT_STRING(s, s-&gt;strstart, hash_head);
01262         }
01263 
01264         <span class="comment">/* Find the longest match, discarding those &lt;= prev_length.</span>
01265 <span class="comment">         */</span>
01266         s-&gt;prev_length = s-&gt;match_length, s-&gt;prev_match = s-&gt;match_start;
01267         s-&gt;match_length = MIN_MATCH-1;
01268 
01269         <span class="keywordflow">if</span> (hash_head != NIL &amp;&amp; s-&gt;prev_length &lt; s-&gt;max_lazy_match &amp;&amp;
01270             s-&gt;strstart - hash_head &lt;= MAX_DIST(s)) {
01271             <span class="comment">/* To simplify the code, we prevent matches with the string</span>
01272 <span class="comment">             * of window index 0 (in particular we have to avoid a match</span>
01273 <span class="comment">             * of the string with itself at the start of the input file).</span>
01274 <span class="comment">             */</span>
01275             <span class="keywordflow">if</span> (s-&gt;strategy != Z_HUFFMAN_ONLY) {
01276                 s-&gt;match_length = longest_match (s, hash_head);
01277             }
01278             <span class="comment">/* longest_match() sets match_start */</span>
01279 
01280             <span class="keywordflow">if</span> (s-&gt;match_length &lt;= 5 &amp;&amp; (s-&gt;strategy == Z_FILTERED ||
01281                  (s-&gt;match_length == MIN_MATCH &amp;&amp;
01282                   s-&gt;strstart - s-&gt;match_start &gt; TOO_FAR))) {
01283 
01284                 <span class="comment">/* If prev_match is also MIN_MATCH, match_start is garbage</span>
01285 <span class="comment">                 * but we will ignore the current match anyway.</span>
01286 <span class="comment">                 */</span>
01287                 s-&gt;match_length = MIN_MATCH-1;
01288             }
01289         }
01290         <span class="comment">/* If there was a match at the previous step and the current</span>
01291 <span class="comment">         * match is not better, output the previous match:</span>
01292 <span class="comment">         */</span>
01293         <span class="keywordflow">if</span> (s-&gt;prev_length &gt;= MIN_MATCH &amp;&amp; s-&gt;match_length &lt;= s-&gt;prev_length) {
01294             uInt max_insert = s-&gt;strstart + s-&gt;lookahead - MIN_MATCH;
01295             <span class="comment">/* Do not insert strings in hash table beyond this. */</span>
01296 
01297             check_match(s, s-&gt;strstart-1, s-&gt;prev_match, s-&gt;prev_length);
01298 
01299             _tr_tally_dist(s, s-&gt;strstart -1 - s-&gt;prev_match,
01300                s-&gt;prev_length - MIN_MATCH, bflush);
01301 
01302             <span class="comment">/* Insert in hash table all strings up to the end of the match.</span>
01303 <span class="comment">             * strstart-1 and strstart are already inserted. If there is not</span>
01304 <span class="comment">             * enough lookahead, the last two strings are not inserted in</span>
01305 <span class="comment">             * the hash table.</span>
01306 <span class="comment">             */</span>
01307             s-&gt;lookahead -= s-&gt;prev_length-1;
01308             s-&gt;prev_length -= 2;
01309             <span class="keywordflow">do</span> {
01310                 <span class="keywordflow">if</span> (++s-&gt;strstart &lt;= max_insert) {
01311                     INSERT_STRING(s, s-&gt;strstart, hash_head);
01312                 }
01313             } <span class="keywordflow">while</span> (--s-&gt;prev_length != 0);
01314             s-&gt;match_available = 0;
01315             s-&gt;match_length = MIN_MATCH-1;
01316             s-&gt;strstart++;
01317 
01318             <span class="keywordflow">if</span> (bflush) FLUSH_BLOCK(s, 0);
01319 
01320         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (s-&gt;match_available) {
01321             <span class="comment">/* If there was no match at the previous position, output a</span>
01322 <span class="comment">             * single literal. If there was a match but the current match</span>
01323 <span class="comment">             * is longer, truncate the previous match to a single literal.</span>
01324 <span class="comment">             */</span>
01325             Tracevv((stderr,<span class="stringliteral">"%c"</span>, s-&gt;window[s-&gt;strstart-1]));
01326         _tr_tally_lit(s, s-&gt;window[s-&gt;strstart-1], bflush);
01327         <span class="keywordflow">if</span> (bflush) {
01328                 FLUSH_BLOCK_ONLY(s, 0);
01329             }
01330             s-&gt;strstart++;
01331             s-&gt;lookahead--;
01332             <span class="keywordflow">if</span> (s-&gt;strm-&gt;avail_out == 0) <span class="keywordflow">return</span> need_more;
01333         } <span class="keywordflow">else</span> {
01334             <span class="comment">/* There is no previous match to compare with, wait for</span>
01335 <span class="comment">             * the next step to decide.</span>
01336 <span class="comment">             */</span>
01337             s-&gt;match_available = 1;
01338             s-&gt;strstart++;
01339             s-&gt;lookahead--;
01340         }
01341     }
01342     Assert (flush != Z_NO_FLUSH, <span class="stringliteral">"no flush?"</span>);
01343     <span class="keywordflow">if</span> (s-&gt;match_available) {
01344         Tracevv((stderr,<span class="stringliteral">"%c"</span>, s-&gt;window[s-&gt;strstart-1]));
01345         _tr_tally_lit(s, s-&gt;window[s-&gt;strstart-1], bflush);
01346         s-&gt;match_available = 0;
01347     }
01348     FLUSH_BLOCK(s, flush == Z_FINISH);
01349     <span class="keywordflow">return</span> flush == Z_FINISH ? finish_done : block_done;
01350 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:40 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>

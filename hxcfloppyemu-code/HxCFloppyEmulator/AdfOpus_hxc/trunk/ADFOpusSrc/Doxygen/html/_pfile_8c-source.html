<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Pfile.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="globals.html">Globals</a> &nbsp; </center>
<hr><h1>Pfile.c</h1><div class="fragment"><pre>00001 
00002 <span class="comment">/*</span>
00003 <span class="comment"> *     xDMS  v1.3  -  Portable DMS archive unpacker  -  Public Domain</span>
00004 <span class="comment"> *     Written by     Andre Rodrigues de la Rocha  &lt;adlroc@usa.net&gt;</span>
00005 <span class="comment"> *</span>
00006 <span class="comment"> *     Handles the processing of a single DMS archive</span>
00007 <span class="comment"> *</span>
00008 <span class="comment"> */</span>
00009 
00010 
00011 <span class="preprocessor">#define HEADLEN 56</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#define THLEN 20</span>
00013 <span class="preprocessor"></span><span class="preprocessor">#define TRACK_BUFFER_LEN 32000</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#define TEMP_BUFFER_LEN 32000</span>
00015 <span class="preprocessor"></span>
00016 
00017 <span class="preprocessor">#include &lt;stdio.h&gt;</span>
00018 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00019 <span class="preprocessor">#include &lt;string.h&gt;</span>
00020 <span class="preprocessor">#include &lt;time.h&gt;</span>
00021 
00022 <span class="preprocessor">#include "cdata.h"</span>
00023 <span class="preprocessor">#include "u_init.h"</span>
00024 <span class="preprocessor">#include "u_rle.h"</span>
00025 <span class="preprocessor">#include "u_quick.h"</span>
00026 <span class="preprocessor">#include "u_medium.h"</span>
00027 <span class="preprocessor">#include "u_deep.h"</span>
00028 <span class="preprocessor">#include "u_heavy.h"</span>
00029 <span class="preprocessor">#include "crc_csum.h"</span>
00030 <span class="preprocessor">#include "pfile.h"</span>
00031 
00032 
00033 
00034 <span class="keyword">static</span> USHORT Process_Track(FILE *, FILE *, UCHAR *, UCHAR *, USHORT, USHORT);
00035 <span class="keyword">static</span> USHORT Unpack_Track(UCHAR *, UCHAR *, USHORT, USHORT, UCHAR, UCHAR);
00036 <span class="keyword">static</span> <span class="keywordtype">void</span> dms_decrypt(UCHAR *, USHORT);
00037 
00038 
00039 <span class="keyword">static</span> <span class="keywordtype">char</span> modes[7][7]={<span class="stringliteral">"NOCOMP"</span>,<span class="stringliteral">"SIMPLE"</span>,<span class="stringliteral">"QUICK "</span>,<span class="stringliteral">"MEDIUM"</span>,<span class="stringliteral">"DEEP  "</span>,<span class="stringliteral">"HEAVY1"</span>,<span class="stringliteral">"HEAVY2"</span>};
00040 <span class="keyword">static</span> USHORT PWDCRC;
00041 
00042 UCHAR *text;
00043 
00044 
00045 
00046 USHORT Process_File(<span class="keywordtype">char</span> *iname, <span class="keywordtype">char</span> *oname, USHORT opt, USHORT PCRC, USHORT pwd){
00047     FILE *fi, *fo=NULL;
00048     USHORT from, to, geninfo, c_version, cmode, hcrc, disktype, ret;
00049     ULONG pkfsize, unpkfsize;
00050     UCHAR *b1, *b2;
00051     time_t date;
00052 
00053 
00054     b1 = (UCHAR *)calloc((size_t)TRACK_BUFFER_LEN,1);
00055     <span class="keywordflow">if</span> (!b1) <span class="keywordflow">return</span> ERR_NOMEMORY;
00056     b2 = (UCHAR *)calloc((size_t)TRACK_BUFFER_LEN,1);
00057     <span class="keywordflow">if</span> (!b2) {
00058         free(b1);
00059         <span class="keywordflow">return</span> ERR_NOMEMORY;
00060     }
00061     text = (UCHAR *)calloc((size_t)TEMP_BUFFER_LEN,1);
00062     <span class="keywordflow">if</span> (!text) {
00063         free(b1);
00064         free(b2);
00065         <span class="keywordflow">return</span> ERR_NOMEMORY;
00066     }
00067 
00068     fi = fopen(iname,<span class="stringliteral">"rb"</span>);
00069     <span class="keywordflow">if</span> (!fi) {
00070         free(b1);
00071         free(b2);
00072         free(text);
00073         <span class="keywordflow">return</span> ERR_CANTOPENIN;
00074     }
00075 
00076     <span class="keywordflow">if</span> (fread(b1,1,HEADLEN,fi) != HEADLEN) {
00077         <span class="keywordflow">if</span> (iname) fclose(fi);
00078         free(b1);
00079         free(b2);
00080         free(text);
00081         <span class="keywordflow">return</span> ERR_SREAD;
00082     }
00083 
00084     <span class="keywordflow">if</span> ( (b1[0] != <span class="charliteral">'D'</span>) || (b1[1] != <span class="charliteral">'M'</span>) || (b1[2] != <span class="charliteral">'S'</span>) || (b1[3] != <span class="charliteral">'!'</span>) ) {
00085         <span class="comment">/*  Check the first 4 bytes of file to see if it is "DMS!"  */</span>
00086         <span class="keywordflow">if</span> (iname) fclose(fi);
00087         free(b1);
00088         free(b2);
00089         free(text);
00090         <span class="keywordflow">return</span> ERR_NOTDMS;
00091     }
00092 
00093     hcrc = (USHORT)((b1[HEADLEN-2]&lt;&lt;8) | b1[HEADLEN-1]);
00094     <span class="comment">/* Header CRC */</span>
00095 
00096     <span class="keywordflow">if</span> (hcrc != CreateCRC(b1+4,(ULONG)(HEADLEN-6))) {
00097         <span class="keywordflow">if</span> (iname) fclose(fi);
00098         free(b1);
00099         free(b2);
00100         free(text);
00101         <span class="keywordflow">return</span> ERR_HCRC;
00102     }
00103     
00104     geninfo = (USHORT) ((b1[10]&lt;&lt;8) | b1[11]);  <span class="comment">/* General info about archive */</span>
00105     date = (time_t) ((((ULONG)b1[12])&lt;&lt;24) | (((ULONG)b1[13])&lt;&lt;16) | (((ULONG)b1[14])&lt;&lt;8) | (ULONG)b1[15]); <span class="comment">/* date in standard UNIX/ANSI format */</span>
00106     from = (USHORT) ((b1[16]&lt;&lt;8) | b1[17]);     <span class="comment">/*  Lowest track in archive. May be incorrect if archive is "appended" */</span>
00107     to = (USHORT) ((b1[18]&lt;&lt;8) | b1[19]);       <span class="comment">/*  Highest track in archive. May be incorrect if archive is "appended" */</span>
00108 
00109     pkfsize = (ULONG) ((((ULONG)b1[21])&lt;&lt;16) | (((ULONG)b1[22])&lt;&lt;8) | (ULONG)b1[23]);   <span class="comment">/*  Length of total packed data as in archive   */</span>
00110     unpkfsize = (ULONG) ((((ULONG)b1[25])&lt;&lt;16) | (((ULONG)b1[26])&lt;&lt;8) | (ULONG)b1[27]); <span class="comment">/*  Length of unpacked data. Usually 901120 bytes  */</span>
00111 
00112     c_version = (USHORT) ((b1[46]&lt;&lt;8) | b1[47]);    <span class="comment">/*  version of DMS used to generate it  */</span>
00113     disktype = (USHORT) ((b1[50]&lt;&lt;8) | b1[51]);     <span class="comment">/*  Type of compressed disk  */</span>
00114     cmode = (USHORT) ((b1[52]&lt;&lt;8) | b1[53]);        <span class="comment">/*  Compression mode mostly used in this archive  */</span>
00115 
00116     PWDCRC = PCRC;
00117 
00118     <span class="keywordflow">if</span> (disktype == 7) {
00119         <span class="comment">/*  It's not a DMS compressed disk image, but a FMS archive  */</span>
00120         <span class="keywordflow">if</span> (iname) fclose(fi);
00121         free(b1);
00122         free(b2);
00123         free(text);
00124         <span class="keywordflow">return</span> ERR_FMS;
00125     }
00126 
00127     <span class="keywordflow">if</span> ((geninfo &amp; 2) &amp;&amp; (!pwd))
00128         <span class="keywordflow">return</span> ERR_NOPASSWD;
00129 
00130     fo = fopen(oname,<span class="stringliteral">"wb"</span>);
00131     <span class="keywordflow">if</span> (!fo) {
00132         <span class="keywordflow">if</span> (iname) fclose(fi);
00133         free(b1);
00134         free(b2);
00135         free(text);
00136         <span class="keywordflow">return</span> ERR_CANTOPENOUT;
00137     }
00138 
00139     ret=NO_PROBLEM;
00140 
00141     Init_Decrunchers();
00142 
00143     <span class="keywordflow">while</span> ( (ret=Process_Track(fi,fo,b1,b2,opt,(geninfo &amp; 2)?pwd:0)) == NO_PROBLEM ) ;
00144 
00145     <span class="keywordflow">if</span> (ret == DMS_FILE_END) ret = NO_PROBLEM;
00146 
00147     <span class="comment">/*  Used to give an error message, but I have seen some DMS  */</span>
00148     <span class="comment">/*  files with texts or zeros at the end of the valid data   */</span>
00149     <span class="comment">/*  So, when we find something that is not a track header,   */</span>
00150     <span class="comment">/*  we suppose that the valid data is over. And say it's ok. */</span>
00151     <span class="keywordflow">if</span> (ret == ERR_NOTTRACK) ret = NO_PROBLEM;
00152 
00153 
00154     fclose(fi);
00155     fclose(fo);
00156 
00157     free(b1);
00158     free(b2);
00159     free(text);
00160 
00161     <span class="keywordflow">return</span> ret;
00162 }
00163 
00164 
00165 
00166 <span class="keyword">static</span> USHORT Process_Track(FILE *fi, FILE *fo, UCHAR *b1, UCHAR *b2, USHORT opt, USHORT pwd){
00167     USHORT hcrc, dcrc, usum, number, pklen1, pklen2, unpklen, l, r;
00168     UCHAR cmode, flags;
00169 
00170     l = (USHORT)fread(b1,1,THLEN,fi);
00171 
00172     <span class="keywordflow">if</span> (l != THLEN) {
00173         <span class="keywordflow">if</span> (l==0)
00174             <span class="keywordflow">return</span> DMS_FILE_END;
00175         <span class="keywordflow">else</span>
00176             <span class="keywordflow">return</span> ERR_SREAD;
00177     }
00178 
00179     <span class="comment">/*  "TR" identifies a Track Header  */</span>
00180     <span class="keywordflow">if</span> ((b1[0] != <span class="charliteral">'T'</span>)||(b1[1] != <span class="charliteral">'R'</span>)) <span class="keywordflow">return</span> ERR_NOTTRACK;
00181 
00182     <span class="comment">/*  Track Header CRC  */</span>
00183     hcrc = (USHORT)((b1[THLEN-2] &lt;&lt; 8) | b1[THLEN-1]);
00184 
00185     <span class="keywordflow">if</span> (CreateCRC(b1,(ULONG)(THLEN-2)) != hcrc) <span class="keywordflow">return</span> ERR_THCRC;
00186 
00187     number = (USHORT)((b1[2] &lt;&lt; 8) | b1[3]);    <span class="comment">/*  Number of track  */</span>
00188     pklen1 = (USHORT)((b1[6] &lt;&lt; 8) | b1[7]);    <span class="comment">/*  Length of packed track data as in archive  */</span>
00189     pklen2 = (USHORT)((b1[8] &lt;&lt; 8) | b1[9]);    <span class="comment">/*  Length of data after first unpacking  */</span>
00190     unpklen = (USHORT)((b1[10] &lt;&lt; 8) | b1[11]); <span class="comment">/*  Length of data after subsequent rle unpacking */</span>
00191     flags = b1[12];     <span class="comment">/*  control flags  */</span>
00192     cmode = b1[13];     <span class="comment">/*  compression mode used  */</span>
00193     usum = (USHORT)((b1[14] &lt;&lt; 8) | b1[15]);    <span class="comment">/*  Track Data CheckSum AFTER unpacking  */</span>
00194     dcrc = (USHORT)((b1[16] &lt;&lt; 8) | b1[17]);    <span class="comment">/*  Track Data CRC BEFORE unpacking  */</span>
00195 
00196     <span class="keywordflow">if</span> ((pklen1 &gt; TRACK_BUFFER_LEN) || (pklen2 &gt;TRACK_BUFFER_LEN) || (unpklen &gt; TRACK_BUFFER_LEN)) <span class="keywordflow">return</span> ERR_BIGTRACK;
00197 
00198     <span class="keywordflow">if</span> (fread(b1,1,(size_t)pklen1,fi) != pklen1) <span class="keywordflow">return</span> ERR_SREAD;
00199 
00200     <span class="keywordflow">if</span> (CreateCRC(b1,(ULONG)pklen1) != dcrc) <span class="keywordflow">return</span> ERR_TDCRC;
00201 
00202     <span class="comment">/*  track 80 is FILEID.DIZ, track 0xffff (-1) is Banner  */</span>
00203     <span class="comment">/*  and track 0 with 1024 bytes only is a fake boot block with more advertising */</span>
00204     <span class="comment">/*  FILE_ID.DIZ is never encrypted  */</span>
00205 
00206     <span class="keywordflow">if</span> (pwd &amp;&amp; (number!=80)) dms_decrypt(b1,pklen1);
00207 
00208     <span class="keywordflow">if</span> ((number&lt;80) &amp;&amp; (unpklen&gt;2048)) {
00209         r = Unpack_Track(b1, b2, pklen2, unpklen, cmode, flags);
00210         <span class="keywordflow">if</span> (r != NO_PROBLEM) 
00211             <span class="keywordflow">if</span> (pwd)
00212                 <span class="keywordflow">return</span> ERR_BADPASSWD;
00213             <span class="keywordflow">else</span>
00214                 <span class="keywordflow">return</span> r;
00215         <span class="keywordflow">if</span> (usum != Calc_CheckSum(b2,(ULONG)unpklen))
00216             <span class="keywordflow">if</span> (pwd)
00217                 <span class="keywordflow">return</span> ERR_BADPASSWD;
00218             <span class="keywordflow">else</span>
00219                 <span class="keywordflow">return</span> ERR_CSUM;
00220         <span class="keywordflow">if</span> (fwrite(b2,1,(size_t)unpklen,fo) != unpklen) <span class="keywordflow">return</span> ERR_CANTWRITE;
00221         <span class="keywordflow">if</span> (opt == OPT_VERBOSE) {
00222             fprintf(stderr,<span class="stringliteral">"#"</span>);
00223             fflush(stderr);
00224         }
00225     }
00226     <span class="keywordflow">return</span> NO_PROBLEM;
00227 }
00228 
00229 <span class="keyword">static</span> USHORT Unpack_Track(UCHAR *b1, UCHAR *b2, USHORT pklen2, USHORT unpklen, UCHAR cmode, UCHAR flags){
00230     <span class="keywordflow">switch</span> (cmode){
00231         <span class="keywordflow">case</span> 0:
00232             <span class="comment">/*   No Compression   */</span>
00233             memcpy(b2,b1,(size_t)unpklen);
00234             <span class="keywordflow">break</span>;
00235         <span class="keywordflow">case</span> 1:
00236             <span class="comment">/*   Simple Compression   */</span>
00237             <span class="keywordflow">if</span> (Unpack_RLE(b1,b2,unpklen)) <span class="keywordflow">return</span> ERR_BADDECR;
00238             <span class="keywordflow">break</span>;
00239         <span class="keywordflow">case</span> 2:
00240             <span class="comment">/*   Quick Compression   */</span>
00241             <span class="keywordflow">if</span> (Unpack_QUICK(b1,b2,pklen2)) <span class="keywordflow">return</span> ERR_BADDECR;
00242             <span class="keywordflow">if</span> (Unpack_RLE(b2,b1,unpklen)) <span class="keywordflow">return</span> ERR_BADDECR;
00243             memcpy(b2,b1,(size_t)unpklen);
00244             <span class="keywordflow">break</span>;
00245         <span class="keywordflow">case</span> 3:
00246             <span class="comment">/*   Medium Compression   */</span>
00247             <span class="keywordflow">if</span> (Unpack_MEDIUM(b1,b2,pklen2)) <span class="keywordflow">return</span> ERR_BADDECR;
00248             <span class="keywordflow">if</span> (Unpack_RLE(b2,b1,unpklen)) <span class="keywordflow">return</span> ERR_BADDECR;
00249             memcpy(b2,b1,(size_t)unpklen);
00250             <span class="keywordflow">break</span>;
00251         <span class="keywordflow">case</span> 4:
00252             <span class="comment">/*   Deep Compression   */</span>
00253             <span class="keywordflow">if</span> (Unpack_DEEP(b1,b2,pklen2)) <span class="keywordflow">return</span> ERR_BADDECR;
00254             <span class="keywordflow">if</span> (Unpack_RLE(b2,b1,unpklen)) <span class="keywordflow">return</span> ERR_BADDECR;
00255             memcpy(b2,b1,(size_t)unpklen);
00256             <span class="keywordflow">break</span>;
00257         <span class="keywordflow">case</span> 5:
00258         <span class="keywordflow">case</span> 6:
00259             <span class="comment">/*   Heavy Compression   */</span>
00260             <span class="keywordflow">if</span> (cmode==5) {
00261                 <span class="comment">/*   Heavy 1   */</span>
00262                 <span class="keywordflow">if</span> (Unpack_HEAVY(b1,b2,flags &amp; 7,pklen2)) <span class="keywordflow">return</span> ERR_BADDECR;
00263             } <span class="keywordflow">else</span> {
00264                 <span class="comment">/*   Heavy 2   */</span>
00265                 <span class="keywordflow">if</span> (Unpack_HEAVY(b1,b2,flags | 8,pklen2)) <span class="keywordflow">return</span> ERR_BADDECR;
00266             }
00267             <span class="keywordflow">if</span> (flags &amp; 4) {
00268                 <span class="comment">/*  Unpack with RLE only if this flag is set  */</span>
00269                 <span class="keywordflow">if</span> (Unpack_RLE(b2,b1,unpklen)) <span class="keywordflow">return</span> ERR_BADDECR;
00270                 memcpy(b2,b1,(size_t)unpklen);
00271             }
00272             <span class="keywordflow">break</span>;
00273         <span class="keywordflow">default</span>:
00274             <span class="keywordflow">return</span> ERR_UNKNMODE;
00275     }
00276 
00277     <span class="keywordflow">if</span> (!(flags &amp; 1)) Init_Decrunchers();
00278 
00279     <span class="keywordflow">return</span> NO_PROBLEM;
00280 
00281 }
00282 
00283 
00284 <span class="comment">/*  DMS uses a lame encryption  */</span>
00285 <span class="keyword">static</span> <span class="keywordtype">void</span> dms_decrypt(UCHAR *p, USHORT len){
00286     USHORT t;
00287 
00288     <span class="keywordflow">while</span> (len--){
00289         t = (USHORT) *p;
00290         *p++ ^= (UCHAR)PWDCRC;
00291         PWDCRC = (USHORT)((PWDCRC &gt;&gt; 1) + t);
00292     }
00293 }
</pre></div><hr><address style="align: right;"><small>Generated on Tue Nov 5 12:21:42 2002 for dynlib by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
